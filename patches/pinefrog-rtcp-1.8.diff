Index: patches/pinefrog-1.4.diff
===================================================================
--- patches/pinefrog-1.4.diff	(.../branches/1.8)	(revision 0)
+++ patches/pinefrog-1.4.diff	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -0,0 +1,2281 @@
+Index: channels/chan_sip.c
+===================================================================
+--- channels/chan_sip.c	(.../branches/1.4)	(revision 382456)
++++ channels/chan_sip.c	(.../team/oej/pinefrog-1.4)	(revision 382456)
+@@ -478,6 +478,13 @@
+ 	{ SIP_OPT_RESPRIORITY,	NOT_SUPPORTED,	"resource-priority" },
+ };
+ 
++/*! Media types for declaration of RTP streams */
++enum media_type {
++	SDP_AUDIO,	/* AUDIO class */
++	SDP_VIDEO,
++	SDP_IMAGE,
++/* For later versions that 1.4 we need to add SDP_TEXT for T.140 */
++};
+ 
+ /*! \brief SIP Methods we support */
+ #define ALLOWED_METHODS "INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, SUBSCRIBE, NOTIFY, INFO"
+@@ -574,6 +581,8 @@
+ static char global_useragent[AST_MAX_EXTENSION];	/*!< Useragent for the SIP channel */
+ static int allow_external_domains;	/*!< Accept calls to external SIP domains? */
+ static int global_callevents;		/*!< Whether we send manager events or not */
++static int global_rtcpevents;		/*!< Whether we send manager RTCP events or not */
++static int global_rtcptimer;		/*!< How often, during a call, to report RTCP stats */
+ static int global_t1min;		/*!< T1 roundtrip time minimum */
+ static int global_autoframing;          /*!< Turn autoframing on or off. */
+ static enum transfermodes global_allowtransfer;	/*!< SIP Refer restriction scheme */
+@@ -1042,6 +1051,7 @@
+ 	int initid;				/*!< Auto-congest ID if appropriate (scheduler) */
+ 	int waitid;				/*!< Wait ID for scheduler after 491 or other delays */
+ 	int autokillid;				/*!< Auto-kill ID (scheduler) */
++	int rtcpeventid;			/*!< Scheduler ID for RTCP Events */
+ 	enum transfermodes allowtransfer;	/*!< REFER: restriction scheme */
+ 	struct sip_refer *refer;		/*!< REFER: SIP transfer data structure */
+ 	enum subscriptiontype subscribed;	/*!< SUBSCRIBE: Is this dialog a subscription?  */
+@@ -1068,6 +1078,8 @@
+ 	struct sip_invite_param *options;	/*!< Options for INVITE */
+ 	int autoframing;
+ 	int hangupcause;			/*!< Storage of hangupcause copied from our owner before we disconnect from the AST channel (only used at hangup) */
++	struct ast_rtp_quality *audioqual;		/*!< Audio: The latest quality report, for realtime storage */
++	struct ast_rtp_quality *videoqual;		/*!< Video: The latest quality report, for realtime storage */
+ 	/*! When receiving an SDP offer, it is important to take note of what media types were offered.
+ 	 * By doing this, even if we don't want to answer a particular media stream with something meaningful, we can
+ 	 * still put an m= line in our answer with the port set to 0.
+@@ -1421,7 +1433,11 @@
+ 				char **m_buf, size_t *m_size, char **a_buf, size_t *a_size,
+ 				int debug);
+ static enum sip_result add_sdp(struct sip_request *resp, struct sip_pvt *p, int add_audio, int add_t38);
++static int send_rtcp_events(const void *data);
++static void start_rtcp_events(struct sip_pvt *dialog);
++static void sip_rtcp_report(struct sip_pvt *p, struct ast_rtp *rtp, enum media_type type, int reporttype);
+ static void stop_media_flows(struct sip_pvt *p);
++static void qos_write_realtime(struct sip_pvt *dialog, struct ast_rtp_quality *qual);
+ 
+ /*--- Authentication stuff */
+ static int reply_digest(struct sip_pvt *p, struct sip_request *req, char *header, int sipmethod, char *digest, int digest_len);
+@@ -2754,9 +2770,12 @@
+ 	if (option_debug > 2)
+ 		ast_log(LOG_DEBUG, "Destroying SIP peer %s\n", peer->name);
+ 
++
+ 	/* Delete it, it needs to disappear */
+-	if (peer->call)
++	if (peer->call) {
+ 		sip_destroy(peer->call);
++		peer->call = NULL;
++	}
+ 
+ 	if (peer->mwipvt) 	/* We have an active subscription, delete it */
+ 		sip_destroy(peer->mwipvt);
+@@ -3441,11 +3460,25 @@
+ 	if (dumphistory)
+ 		sip_dump_history(p);
+ 
++	if (p->audioqual) {
++		/* We have a quality report to write to realtime before we leave this world. */
++		qos_write_realtime(p, p->audioqual);
++		free(p->audioqual);
++		p->audioqual = NULL;
++	}
++	if (p->videoqual) {
++		/* We have a quality report to write to realtime before we leave this world. */
++		qos_write_realtime(p, p->videoqual);
++		free(p->videoqual);
++		p->videoqual = NULL;
++	}
++
+ 	if (p->options)
+ 		free(p->options);
+ 
+ 	if (p->stateid > -1)
+ 		ast_extension_state_del(p->stateid, NULL);
++	AST_SCHED_DEL(sched, p->rtcpeventid);
+ 
+ 	/* remove any pending extension notify that could be left in
+ 	 * the extension update queue relating to this dialog. */
+@@ -3957,10 +3990,12 @@
+ 			if (!p->pendinginvite) {
+ 				char *audioqos = "";
+ 				char *videoqos = "";
+-				if (p->rtp)
+-					audioqos = ast_rtp_get_quality(p->rtp, NULL);
+-				if (p->vrtp)
+-					videoqos = ast_rtp_get_quality(p->vrtp, NULL);
++				if (p->rtp) {
++					audioqos = ast_rtp_get_quality(p->rtp);
++				}
++				if (p->vrtp) {
++					videoqos = ast_rtp_get_quality(p->vrtp);
++				}
+ 				/* Send a hangup */
+ 				if (oldowner->_state == AST_STATE_UP) {
+ 					transmit_request_with_auth(p, SIP_BYE, 0, XMIT_RELIABLE, 1);
+@@ -4035,6 +4070,7 @@
+ 		ast_rtp_new_source(p->rtp);
+ 		res = transmit_response_with_sdp(p, "200 OK", &p->initreq, XMIT_CRITICAL);
+ 		ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
++		start_rtcp_events(p);
+ 	}
+ 	ast_mutex_unlock(&p->lock);
+ 	return res;
+@@ -4846,6 +4882,7 @@
+ 	ast_mutex_init(&p->lock);
+ 
+ 	p->method = intended_method;
++	p->rtcpeventid = -1;
+ 	p->initid = -1;
+ 	p->waitid = -1;
+ 	p->autokillid = -1;
+@@ -4877,8 +4914,9 @@
+ 	if (sip_methods[intended_method].need_rtp) {
+ 		p->rtp = ast_rtp_new_with_bindaddr(sched, io, 1, 0, bindaddr.sin_addr);
+ 		/* If the global videosupport flag is on, we always create a RTP interface for video */
+-		if (ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT))
++		if (ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT)) {
+ 			p->vrtp = ast_rtp_new_with_bindaddr(sched, io, 1, 0, bindaddr.sin_addr);
++		}
+ 		if (ast_test_flag(&p->flags[1], SIP_PAGE2_T38SUPPORT))
+ 			p->udptl = ast_udptl_new_with_bindaddr(sched, io, 0, bindaddr.sin_addr);
+ 		if (!p->rtp || (ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) && !p->vrtp)) {
+@@ -4936,6 +4974,12 @@
+ 	else
+ 		ast_string_field_set(p, callid, callid);
+ 	/* Assign default music on hold class */
++	if (p->rtp) {
++		ast_rtcp_setcname(p->rtp, p->callid, strlen(p->callid));
++	}
++	if (p->vrtp) {
++		ast_rtcp_setcname(p->vrtp, p->callid, strlen(p->callid));
++	}
+ 	ast_string_field_set(p, mohinterpret, default_mohinterpret);
+ 	ast_string_field_set(p, mohsuggest, default_mohsuggest);
+ 	p->capability = global_capability;
+@@ -5603,11 +5647,6 @@
+ 	return;
+ }
+ 
+-enum media_type {
+-	SDP_AUDIO,
+-	SDP_VIDEO,
+-	SDP_IMAGE,
+-};
+ 
+ static int get_ip_and_port_from_sdp(struct sip_request *req, const enum media_type media, struct sockaddr_in *sin)
+ {
+@@ -12019,6 +12058,10 @@
+ 	int realtimepeers;
+ 	int realtimeusers;
+ 	char codec_buf[SIPBUFSIZE];
++	int realtimertpqos = FALSE;
++#ifdef REALTIME2
++	realtimertpqos = ast_check_realtime("rtpqos");
++#endif
+ 
+ 	realtimepeers = ast_check_realtime("sippeers");
+ 	realtimeusers = ast_check_realtime("sipusers");
+@@ -12050,6 +12093,8 @@
+ 	ast_cli(fd, "  From: Domain:           %s\n", default_fromdomain);
+ 	ast_cli(fd, "  Record SIP history:     %s\n", recordhistory ? "On" : "Off");
+ 	ast_cli(fd, "  Call Events:            %s\n", global_callevents ? "On" : "Off");
++	ast_cli(fd, "  RTCP Events:            %s\n", global_rtcpevents ? "On" : "Off");
++	ast_cli(fd, "  RTCP Event timer:       %d\n", global_rtcptimer);
+ 	ast_cli(fd, "  IP ToS SIP:             %s\n", ast_tos2str(global_tos_sip));
+ 	ast_cli(fd, "  IP ToS RTP audio:       %s\n", ast_tos2str(global_tos_audio));
+ 	ast_cli(fd, "  IP ToS RTP video:       %s\n", ast_tos2str(global_tos_video));
+@@ -12063,6 +12108,7 @@
+ 		ast_cli(fd, "  SIP realtime:           Disabled\n" );
+ 	else
+ 		ast_cli(fd, "  SIP realtime:           Enabled\n" );
++	ast_cli(fd, "  QOS realtime reports:   %s\n", realtimertpqos ? "Enabled" : "Disabled" );
+ 
+ 	ast_cli(fd, "\nGlobal Signalling Settings:\n");
+ 	ast_cli(fd, "---------------------------\n");
+@@ -13650,6 +13696,7 @@
+ 		ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
+ 		xmitres = transmit_request(p, SIP_ACK, seqno, XMIT_UNRELIABLE, TRUE);
+ 		check_pendings(p);
++		start_rtcp_events(p);
+ 		break;
+ 	case 407: /* Proxy authentication */
+ 	case 401: /* Www auth */
+@@ -14046,14 +14093,286 @@
+ 	}
+ }
+ 
++/*! \brief send manager report of RTCP 
++	reporttype = 0  means report during call (if configured)
++	reporttype = 1  means endof-call (hangup) report
++	reporttype = 10  means report at end of call leg (like transfer)
++*/
++static void sip_rtcp_report(struct sip_pvt *p, struct ast_rtp *rtp, enum media_type type, int reporttype)
++{
++	struct ast_rtp_quality *qual;
++	char *rtpqstring = NULL;
++	int qosrealtime = ast_check_realtime("rtpqos");
++	unsigned int duration;	/* Duration in secs */
++ 	int readtrans = FALSE, writetrans = FALSE;
++
++	memset(&qual, sizeof(qual), 0);
++  
++	if (p && p->owner) {
++		struct ast_channel *bridgepeer = ast_bridged_channel(p->owner);
++		if (bridgepeer) {
++			/* Store the bridged peer data while we have it */
++			ast_rtcp_set_bridged(rtp, p->owner->name, p->owner->uniqueid, S_OR(bridgepeer->name,""), S_OR(bridgepeer->uniqueid,""));
++			ast_log(LOG_DEBUG, "---- Setting bridged peer name to %s\n", bridgepeer->name);
++		} else {
++			ast_rtcp_set_bridged(rtp, p->owner->name, p->owner->uniqueid, NULL, NULL);
++		}
++
++ 		/* Try to find out if there's active transcoding */
++		/* Currently, the only media stream that has translation is the audio stream. At some point
++		   we might have transcoding for other types of media. */
++		if (type == SDP_AUDIO) {
++			/* if we have a translator, the bridge delay is increased, which affects the QoS of the call.  */
++ 			readtrans = p->owner->readtrans != NULL;
++ 			writetrans = p->owner->writetrans != NULL;
++			ast_rtcp_settranslator(rtp, readtrans ? p->owner->readtrans->t->name : NULL, readtrans ? p->owner->readtrans->t->cost : 0,
++					writetrans ? p->owner->writetrans->t->name : NULL, writetrans ? p->owner->writetrans->t->cost : 0);
++		
++			if (option_debug > 1) {
++ 				if (readtrans && p->owner->readtrans->t) {
++ 					ast_log(LOG_DEBUG, "--- Audio Read translator: %s Cost %d\n", p->owner->readtrans->t->name, p->owner->readtrans->t->cost);
++ 				}
++ 				if (writetrans && p->owner->writetrans->t) {
++ 					ast_log(LOG_DEBUG, "--- Audio Write translator: %s Cost %d\n", p->owner->writetrans->t->name, p->owner->writetrans->t->cost);
++ 				}
++			}
++		}
++
++	}
++
++	rtpqstring =  ast_rtp_get_quality(rtp);
++	qual = ast_rtp_get_qualdata(rtp);
++	if (!qual) {
++		/* Houston, we got a problem */
++		return;
++	}
++	
++	if (global_rtcpevents) {
++		/* 
++		   If numberofreports == 0 we have no incoming RTCP active, thus we can't
++		   get any reliable data to handle packet loss or any RTT timing.
++		*/
++
++		duration = (unsigned int)(ast_tvdiff_ms(ast_tvnow(), qual->start) / 1000);
++		manager_event(EVENT_FLAG_CALL, "RTPQuality", 
++			"Channel: %s\r\n"			/* AST_CHANNEL for this call */
++			"Uniqueid: %s\r\n"			/* AST_CHANNEL for this call */
++			"BridgedChannel: %s\r\n"
++			"BridgedUniqueid: %s\r\n"
++			"RTPreporttype: %s\r\n"
++			"RTPrtcpstatus: %s\r\n"
++			"Duration: %u\r\n"		/* used in cdr_manager */
++			"PvtCallid: %s\r\n"		/* ??? Generic PVT identifier */
++			"RTPipaddress: %s\r\n"
++			"RTPmedia: %s\r\n"		/* Audio, video, text */
++			"RTPsendformat: %s\r\n"
++			"RTPrecvformat: %s\r\n"
++			"RTPlocalssrc: %u\r\n"
++			"RTPremotessrc: %u\r\n"
++			"RTPrtt: %f\r\n"
++			"RTPrttMax: %f\r\n"
++			"RTPrttMin: %f\r\n"
++			"RTPLocalJitter: %f\r\n"
++			"RTPRemoteJitter: %f\r\n" 
++			"RTPInPacketLoss: %d\r\n" 
++			"RTPInLocalPlPercent: %5.2f\r\n"
++			"RTPOutPacketLoss: %d\r\n"
++			"RTPOutPlPercent: %5.2f\r\n"
++			"TranslateRead: %s\r\n"
++			"TranslateReadCost: %d\r\n"
++			"TranslateWrite: %s\r\n"
++			"TranslateWriteCost: %d\r\n"
++			"\r\n", 
++			p->owner ? p->owner->name : "",
++			p->owner ? p->owner->uniqueid : "",
++			qual->bridgedchan[0] ? qual->bridgedchan : "" ,
++			qual->bridgeduniqueid[0] ? qual->bridgeduniqueid : "",
++			reporttype == 1 ? "Final" : "Update",
++			qual->numberofreports == 0 ? "Inactive" : "Active",
++			duration,
++			p->callid, 
++			ast_inet_ntoa(qual->them.sin_addr), 	
++			type == SDP_AUDIO ? "audio" : (type == SDP_VIDEO ? "video" : "fax") ,
++			ast_getformatname(qual->lasttxformat),
++			ast_getformatname(qual->lastrxformat),
++			qual->local_ssrc, 
++			qual->remote_ssrc,
++			qual->rtt,
++			qual->rttmax,
++			qual->rttmin,
++			qual->local_jitter,
++			qual->remote_jitter,
++			qual->local_lostpackets,
++			/* The local counter of lost packets in inbound stream divided with received packets plus lost packets */
++			(qual->remote_count + qual->local_lostpackets) > 0 ? (double) qual->local_lostpackets / (qual->remote_count + qual->local_lostpackets) * 100 : 0,
++			qual->remote_lostpackets,
++			/* The remote counter of lost packets (if we got the reports)
++			   divided with our counter of sent packets
++			 */
++			(qual->local_count + qual->remote_lostpackets) > 0 ? (double) qual->remote_lostpackets / qual->local_count  * 100 : 0,
++			qual->readtranslator, qual->readcost,
++			qual->writetranslator, qual->writecost
++		);
++	}
++
++	/* CDR records are not reliable when it comes to near-death-of-channel events, so we need to store the RTCP
++	   report in realtime when we have it.
++	   Tests have proven that storing to realtime from the call thread is NOT a good thing. Therefore, we just save
++	   the quality report structure in the PVT and let the function that kills the pvt store the stuff in the
++	   monitor thread instead.
++	 */
++	if (reporttype == 1 {
++		if (type == SDP_AUDIO) {  /* Audio */
++			p->audioqual = ast_calloc(sizeof(struct ast_rtp_quality), 1);
++			(* p->audioqual) = *qual;
++			p->audioqual->end = ast_tvnow();
++ 			p->audioqual->mediatype = type;
++		} else if (type == SDP_VIDEO) {  /* Video */
++			p->videoqual = ast_calloc(sizeof(struct ast_rtp_quality), 1);
++			(* p->videoqual) = *qual;
++ 			p->videoqual->mediatype = type;
++			p->videoqual->end = ast_tvnow();
++		}
++	}
++}
++
++/*! \brief Write quality report to realtime storage */
++void qos_write_realtime(struct sip_pvt *dialog, struct ast_rtp_quality *qual)
++{
++	unsigned int duration;	/* Duration in secs */
++	char buf_duration[10], buf_lssrc[30], buf_rssrc[30];
++	char buf_rtt[10], buf_rttmin[10], buf_rttmax[10];
++	char localjitter[10], remotejitter[10];
++	char buf_readcost[5], buf_writecost[5];
++	char buf_mediatype[10];
++	char buf_remoteip[25];
++	char buf_inpacketloss[25], buf_outpacketloss[25];
++	char buf_outpackets[25], buf_inpackets[25];
++
++	/* Since the CDR is already gone, we need to calculate our own duration.
++	   The CDR duration is the definitive resource for billing, this is
++	   the RTP stream duration which may include early media (ringing and
++	   provider messages). Only useful for measurements.
++	 */
++	if (!ast_tvzero(qual->end)) {
++		duration = (unsigned int)(ast_tvdiff_ms(qual->end, qual->start) / 1000);
++	} else {
++		duration = 0;
++	}
++
++	/* Realtime is based on strings, so let's make strings */
++	sprintf(localjitter, "%f", qual->local_jitter);
++	sprintf(remotejitter, "%f", qual->remote_jitter);
++	sprintf(buf_lssrc, "%u", qual->local_ssrc);
++	sprintf(buf_rssrc, "%u", qual->remote_ssrc);
++	sprintf(buf_rtt, "%.0f", qual->rtt);
++	sprintf(buf_rttmax, "%.0f", qual->rttmax);
++	sprintf(buf_rttmin, "%.0f", qual->rttmin);
++	sprintf(buf_duration, "%u", duration);
++	sprintf(buf_readcost, "%d", qual->readcost);
++	sprintf(buf_writecost, "%d", qual->writecost);
++	sprintf(buf_mediatype,"%s", qual->mediatype == SDP_AUDIO ? "audio" : (qual->mediatype == SDP_VIDEO ? "video" : "fax") );
++	sprintf(buf_remoteip,"%s", ast_inet_ntoa(qual->them.sin_addr));
++	sprintf(buf_inpacketloss, "%d", qual->local_lostpackets);
++	sprintf(buf_outpacketloss, "%d", qual->remote_lostpackets);
++	sprintf(buf_inpackets, "%d", qual->remote_count);	/* Do check again */
++	sprintf(buf_outpackets, "%d", qual->local_count);
++
++	ast_log(LOG_NOTICE,"RTPQOS Channel: %s Uid %s Bch %s Buid %s Pvt %s Media %s Lssrc %s Rssrc %s Rip %s Rtt %s:%s:%s Ljitter %s Rjitter %s Rtcpstatus %s Dur %s Pout %s Plossout %s Pin %s Plossin %s\n",
++		qual->channel[0] ? qual->channel : "",
++		qual->uniqueid[0] ? qual->uniqueid : "",
++		qual->bridgedchan[0] ? qual->bridgedchan : "" ,
++		qual->bridgeduniqueid[0] ? qual->bridgeduniqueid : "",
++		dialog->callid,
++		buf_mediatype,
++		buf_lssrc,
++		buf_rssrc,
++		buf_remoteip,
++		buf_rtt, buf_rttmax, buf_rttmin,
++		localjitter,
++		remotejitter,
++		qual->numberofreports == 0 ? "Inactive" : "Active",
++		buf_duration,
++		buf_outpackets,
++		buf_outpacketloss,
++		buf_inpackets,
++		buf_inpacketloss);
++
++#ifdef REALTIME2
++	ast_store_realtime("rtpqos", 
++		"channel", qual->channel[0] ? qual->channel : "--no channel--",
++		"uniqueid", qual->uniqueid[0] ? qual->uniqueid : "--no uniqueid --",
++		"bridgedchan", qual->bridgedchan[0] ? qual->bridgedchan : "" ,
++		"bridgeduniqueid", qual->bridgeduniqueid[0] ? qual->bridgeduniqueid : "",
++		"pvtcallid", dialog->callid, 
++		"rtpmedia", buf_mediatype, 
++		"localssrc", buf_lssrc, 
++		"remotessrc", buf_rssrc,
++		"remoteip", buf_remoteip,
++		"rtt", buf_rtt, 
++		"rttmax", buf_rttmax, 
++		"rttmin", buf_rttmin, 
++		"localjitter", localjitter, 
++		"remotejitter", remotejitter, 
++		"sendformat", ast_getformatname(qual->lasttxformat),
++		"receiveformat", ast_getformatname(qual->lastrxformat),
++		"rtcpstatus", qual->numberofreports == 0 ? "Inactive" : "Active",
++		"duration", buf_duration,
++		"writetranslator", qual->writetranslator[0] ? qual->writetranslator : "",
++		"writecost", buf_writecost,
++		"readtranslator", qual->readtranslator[0] ? qual->readtranslator : "",
++		"readcost", buf_readcost,
++		"packetlossin", buf_inpacketloss,
++		"packetlossout", buf_outpacketloss,
++		"packetsent", buf_outpackets,
++		"packetreceived", buf_inpackets,
++		NULL);
++#endif
++}
++
++/*! \brief Send RTCP manager events */
++static int send_rtcp_events(const void *data)
++{
++	struct sip_pvt *dialog = (struct sip_pvt *) data;
++
++	if (dialog->rtp && ast_rtp_isactive(dialog->rtp)) {
++		sip_rtcp_report(dialog, dialog->rtp, SDP_AUDIO, FALSE);
++	}
++	if (dialog->vrtp && ast_rtp_isactive(dialog->vrtp)) {
++		sip_rtcp_report(dialog, dialog->vrtp, SDP_VIDEO, FALSE);
++	}
++	return global_rtcptimer;
++}
++
++/*! \brief Activate RTCP events at start of call */
++static void start_rtcp_events(struct sip_pvt *dialog)
++{
++	if (!global_rtcpevents || !global_rtcptimer) {
++		return;
++	}
++	/* Check if it's already active */
++	if (dialog->rtcpeventid != -1) {
++		return;
++	}
++
++	/*! \brief Schedule events */
++	dialog->rtcpeventid = ast_sched_add(sched, global_rtcptimer * 1000, send_rtcp_events, dialog);
++}
++
++
+ /*! \brief Immediately stop RTP, VRTP and UDPTL as applicable */
+ static void stop_media_flows(struct sip_pvt *p)
+ {
++
+ 	/* Immediately stop RTP, VRTP and UDPTL as applicable */
+-	if (p->rtp)
++	if (p->rtp && ast_rtp_isactive(p->rtp)) {
+ 		ast_rtp_stop(p->rtp);
+-	if (p->vrtp)
++		sip_rtcp_report(p, p->rtp, SDP_AUDIO, TRUE);
++	}
++	if (p->vrtp && ast_rtp_isactive(p->vrtp)) {
+ 		ast_rtp_stop(p->vrtp);
++		sip_rtcp_report(p, p->vrtp, SDP_VIDEO, TRUE);
++	}
+ 	if (p->udptl)
+ 		ast_udptl_stop(p->udptl);
+ }
+@@ -16523,9 +16842,10 @@
+ 
+ static int acf_channel_read(struct ast_channel *chan, char *funcname, char *preparse, char *buf, size_t buflen)
+ {
+-	struct ast_rtp_quality qos;
+ 	struct sip_pvt *p = chan->tech_pvt;
+ 	char *all = "", *parse = ast_strdupa(preparse);
++	struct ast_rtp_quality *qos;
++
+ 	AST_DECLARE_APP_ARGS(args,
+ 		AST_APP_ARG(param);
+ 		AST_APP_ARG(type);
+@@ -16549,36 +16869,41 @@
+ 		args.field = "all";
+ 
+ 	memset(buf, 0, buflen);
+-	memset(&qos, 0, sizeof(qos));
+ 
+ 	if (p == NULL) {
+ 		return -1;
+ 	}
+ 
+ 	if (strcasecmp(args.type, "AUDIO") == 0) {
+-		all = ast_rtp_get_quality(p->rtp, &qos);
++		all = ast_rtp_get_quality(p->rtp);
++		qos = ast_rtp_get_qualdata(p->rtp);
+ 	} else if (strcasecmp(args.type, "VIDEO") == 0) {
+-		all = ast_rtp_get_quality(p->vrtp, &qos);
++		all = ast_rtp_get_quality(p->vrtp);
++		qos = ast_rtp_get_qualdata(p->vrtp);
++	} else {
++		ast_log(LOG_WARNING, "Unrecognized stream '%s in call to %s'\n", args.typecname, funcname);
++		return -1;
++		
+ 	}
+ 
+ 	if (strcasecmp(args.field, "local_ssrc") == 0)
+-		snprintf(buf, buflen, "%u", qos.local_ssrc);
++		snprintf(buf, buflen, "%u", qos->local_ssrc);
+ 	else if (strcasecmp(args.field, "local_lostpackets") == 0)
+-		snprintf(buf, buflen, "%u", qos.local_lostpackets);
++		snprintf(buf, buflen, "%u", qos->local_lostpackets);
+ 	else if (strcasecmp(args.field, "local_jitter") == 0)
+-		snprintf(buf, buflen, "%.0lf", qos.local_jitter * 1000.0);
++		snprintf(buf, buflen, "%.0lf", qos->local_jitter * 1000.0);
+ 	else if (strcasecmp(args.field, "local_count") == 0)
+-		snprintf(buf, buflen, "%u", qos.local_count);
++		snprintf(buf, buflen, "%u", qos->local_count);
+ 	else if (strcasecmp(args.field, "remote_ssrc") == 0)
+-		snprintf(buf, buflen, "%u", qos.remote_ssrc);
++		snprintf(buf, buflen, "%u", qos->remote_ssrc);
+ 	else if (strcasecmp(args.field, "remote_lostpackets") == 0)
+-		snprintf(buf, buflen, "%u", qos.remote_lostpackets);
++		snprintf(buf, buflen, "%u", qos->remote_lostpackets);
+ 	else if (strcasecmp(args.field, "remote_jitter") == 0)
+-		snprintf(buf, buflen, "%.0lf", qos.remote_jitter * 1000.0);
++		snprintf(buf, buflen, "%.0lf", qos->remote_jitter * 1000.0);
+ 	else if (strcasecmp(args.field, "remote_count") == 0)
+-		snprintf(buf, buflen, "%u", qos.remote_count);
++		snprintf(buf, buflen, "%u", qos->remote_count);
+ 	else if (strcasecmp(args.field, "rtt") == 0)
+-		snprintf(buf, buflen, "%.0lf", qos.rtt * 1000.0);
++		snprintf(buf, buflen, "%.0lf", qos->rtt * 1000.0);
+ 	else if (strcasecmp(args.field, "all") == 0)
+ 		ast_copy_string(buf, all, buflen);
+ 	else {
+@@ -16611,14 +16936,14 @@
+ 	if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY) || p->owner) {
+ 		char *audioqos, *videoqos;
+ 		if (p->rtp) {
+-			audioqos = ast_rtp_get_quality(p->rtp, NULL);
++			audioqos = ast_rtp_get_quality(p->rtp);
+ 			if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY))
+ 				append_history(p, "RTCPaudio", "Quality:%s", audioqos);
+ 			if (p->owner)
+ 				pbx_builtin_setvar_helper(p->owner, "RTPAUDIOQOS", audioqos);
+ 		}
+ 		if (p->vrtp) {
+-			videoqos = ast_rtp_get_quality(p->vrtp, NULL);
++			videoqos = ast_rtp_get_quality(p->vrtp);
+ 			if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY))
+ 				append_history(p, "RTCPvideo", "Quality:%s", videoqos);
+ 			if (p->owner)
+@@ -19120,6 +19445,8 @@
+ 	/* Misc settings for the channel */
+ 	global_relaxdtmf = FALSE;
+ 	global_callevents = FALSE;
++	global_rtcpevents = FALSE;
++	global_rtcptimer = 0;	/* Only report at end of call (if enabled) */
+ 	global_t1min = DEFAULT_T1MIN;
+ 	global_shrinkcallerid = 1;
+ 
+@@ -19366,6 +19693,13 @@
+ 				ast_log(LOG_WARNING, "Qualification default should be 'yes', 'no', or a number of milliseconds at line %d of sip.conf\n", v->lineno);
+ 				default_qualify = 0;
+ 			}
++		} else if (!strcasecmp(v->name, "rtcpevents")) {
++			global_rtcpevents = ast_true(v->value);
++		} else if (!strcasecmp(v->name, "rtcpeventtimer")) {
++			if (sscanf(v->value, "%30d", &global_rtcptimer) != 1) {
++				ast_log(LOG_WARNING, "RTCP event timer needs to be value (seconds between reports) at line %d of sip.conf\n", v->lineno);
++				global_rtcptimer = 0;
++			}
+ 		} else if (!strcasecmp(v->name, "callevents")) {
+ 			global_callevents = ast_true(v->value);
+ 		} else if (!strcasecmp(v->name, "maxcallbitrate")) {
+Index: README.pinefrog-rtcp
+===================================================================
+--- README.pinefrog-rtcp	(.../branches/1.4)	(revision 0)
++++ README.pinefrog-rtcp	(.../team/oej/pinefrog-1.4)	(revision 382456)
+@@ -0,0 +1,97 @@
++Olle E. Johansson
++oej@edvina.net
++
++
++
++
++
++
++Pinefrog - RTCP cleanup and additions
++-------------------------------------
++
++RTCP, as defined in RFC 3550, is a protocol that co-exists with RTP, the protocol used
++for realtime multimedia in VoIP. RTCP gives the endpoints a tool to exchange data about
++the media streams exchanged. As a result, both ends can get informaiton about the
++latency for data sent in both directions, packet loss and jitter for each media stream.
++
++A VoIP call is at least two media streams and they can have different properties in
++regards of quality. A router or switch in the middle could have a lot of outbound traffic,
++causing delays and possible packet loss. This might not affect inbound traffic.
++
++In Asterisk, the RTCP handler is part of the RTP module. The RTP module produces RTCP
++report that can be added to channel variables, cdr logs or sent through AMI.
++
++In 1.4, the data used is mostly based on the latest report, it's not aggregated. This
++is fixed in trunk.
++
++In both implementations (and the 1.6 releases in between) the RTCP support is not
++very complete.
++
++- It doesn't handle RTCP SDES packets
++- It doesn't send RTCP END packets at end of session
++- It doesn't handle receiving END packets
++- It doesn't handle re-invites in a good way.
++- It seems to mix sender and receiver reports, thus mixing data from two streams 
++    - when does this happen, if at all?
++
++RTCP and NAT
++------------
++I suspect that RTCP doesn't traverse NAT very well in our implementation. For RTP,
++we start with sending media to probe NAT. I've added emtpy RTCP RR+SDES CNAME packets
++to start probing a NAT (if Asterisk is behind a NAT). I am afraid that very few devices
++do that early on.
++The idea is (like RTP)
++ - Send a few RTCP packets in the start of the session.
++ - The receiver can then apply symmetric RTCP and start sending to the NAT outside port
++   that we're sending from and we'll get their packets.
++
++Todo
++----
++- When CNAME changes, we have a different stream and need to restart the stats.
++  Should we add ability to produce multiple RTCP reports for one "call" and aggregate them?
++  The different parts might have different properties.
++- Document realtime storage format. Add missing fields.
++- BUG: RTCP is halted during hold. It should not stop.
++- During HOLD, send RTCP SR reports without report block, only the header and no chunks 
++
++Done
++----
++- Added support of outbound and inbound SDES. The SDES includes a stream identifier, CNAME. 
++- Added support of outbound SDES end and goodbye
++- Added manager events at end-of call
++- Added realtime storage of RTCP reports
++- Added time manager events (configured in sip.conf)
++- Added more information to RTCP debug
++- Added more data aggregation to ast_rtcp structure (from svn trunk really)
++- Added RTCP for p2p RTP bridges. Needs to be tested and validated.
++
++Open Issues
++-----------
++The final manager report lacks (in the case of the second channel) the bridged channel. We could save that data.  This will affect realtime as well, so we need to copy the channel name to a stored variable while it exists.
++
++Do we have a counter of consecutive lost packets? How do we measure lost packets on inbound
++stream? Gaps in seq numbers or just the sender reports from the other end compared with received 
++no of packets?
++
++
++Ideas and thoughts for the future
++---------------------------------
++- Asterisk propagates jitter and packet loss over a bridge (especially the p2p RTP bridge).
++  If the call is transfered on the OTHER side of the bridge, we have a new call with new
++  properties. Maybe events like this should generate a new SDES and reset RTCP?
++  Part A of the call can have very different properties than part B. If I have a call with
++  someone internally, that then transfers me to a call with someone on the Internet, the
++  call quality (jitter etc) will change dramatically. This will require some sort of CONTROL
++  packet over the bridge, informing about changes on the other side of the bridge (masq).
++- Can we have some sort of ring buffer for the latest RTCP reports for a device (peer) 
++  and use that to determine the status of the connection to the peer?
++- Can we use the RTCP APP packet for relaying events in joined bridges, like meetme?
++- What should we use as CNAME? Currently SIP call ID.
++- Separate on the IPs of different media servers. IE we can have one SIP peer with
++  multiple media IPs with different properties
++
++Scenarios to test
++------------------
++- normal bridged call
++- RTP p2p bridged call
++- Nat traversal - Asterisk outside of NAT and inside (as client to external service)
+
+Egenskapsändringar för: README.pinefrog-rtcp
+___________________________________________________________________
+Added: svn:mime-type
+## -0,0 +1 ##
++text/plain
+\ No newline at end of property
+Added: svn:keywords
+## -0,0 +1 ##
++Author Date Id Revision
+\ No newline at end of property
+Added: svn:eol-style
+## -0,0 +1 ##
++native
+\ No newline at end of property
+Index: include/asterisk/rtp.h
+===================================================================
+--- include/asterisk/rtp.h	(.../branches/1.4)	(revision 382456)
++++ include/asterisk/rtp.h	(.../team/oej/pinefrog-1.4)	(revision 382456)
+@@ -77,16 +77,38 @@
+ 	AST_LIST_ENTRY(ast_rtp_protocol) list;
+ };
+ 
++/*! \brief Data structure only used for RTCP reports */
+ struct ast_rtp_quality {
+-	unsigned int local_ssrc;          /* Our SSRC */
+-	unsigned int local_lostpackets;   /* Our lost packets */
+-	double       local_jitter;        /* Our calculated jitter */
+-	unsigned int local_count;         /* Number of received packets */
+-	unsigned int remote_ssrc;         /* Their SSRC */
+-	unsigned int remote_lostpackets;  /* Their lost packets */
+-	double       remote_jitter;       /* Their reported jitter */
+-	unsigned int remote_count;        /* Number of transmitted packets */
+-	double       rtt;                 /* Round trip time */
++	char channel[AST_MAX_EXTENSION];	/*!< Name of channel */
++	char uniqueid[AST_MAX_EXTENSION];	/*!< uniqueid of channel */
++	char bridgedchan[AST_MAX_EXTENSION];	/*!< Name of bridged channel */
++	char bridgeduniqueid[AST_MAX_EXTENSION];	/*!< uniqueid of bridged channel */
++	unsigned int numberofreports;	  /*!< Number of reports received from remote end */
++	unsigned int local_ssrc;          /*!< Our SSRC */
++	unsigned int local_lostpackets;   /*!< Our lost packets */
++	double       local_jitter;        /*!< Our calculated jitter */
++	double       local_jitter_max;    /*!< Our calculated jitter */
++	double       local_jitter_min;    /*!< Our calculated jitter */
++	unsigned int local_count;         /*!< Number of received packets */
++	unsigned int remote_ssrc;         /*!< Their SSRC */
++	unsigned int remote_lostpackets;  /*!< Their lost packets */
++	double       remote_jitter;       /*!< Their reported jitter */
++	double       remote_jitter_max;   /*!< Their reported jitter */
++	double       remote_jitter_min;   /*!< Their reported jitter */
++	unsigned int remote_count;        /*!< Number of transmitted packets */
++	double       rtt;                 /*!< Round trip time */
++	double       rttmax;              /*!< Max observed round trip time */
++	double       rttmin;              /*!< Max observed round trip time */
++	int lasttxformat;		  /*!< Last used codec on transmitted stream */
++	int lastrxformat;		  /*!< Last used codec on received stream */
++	struct sockaddr_in them;	  /*!< The IP address used for media by remote end */
++	struct timeval start;		  /*!< When the call started */
++	struct timeval end;		  /*!< When the call ended */
++	char writetranslator[80];	  /*!< Translator used when writing */
++	char readtranslator[80];		  /*!< Translator providing frames when reading */
++	int writecost;		  /*!< Cost in milliseconds for encoding/decoding 1 second of outbound media */
++	int readcost;		  /*!< Cost in milliseconds for encoding/decoding 1 second of inbound media */
++	int mediatype;			/*! Type of media */
+ };
+ 
+ 
+@@ -180,9 +202,35 @@
+ 
+ int ast_rtp_settos(struct ast_rtp *rtp, int tos);
+ 
++void ast_rtcp_setcname(struct ast_rtp *rtp, const char *cname, size_t length);
++
++/*! \brief Set the transcoding variables for the QoS reports */
++void ast_rtcp_settranslator(struct ast_rtp *rtp, const char *readtranslator, const int readcost, const char *writetranslator, const int writecost);
++
++/*! \brief set the name of the channel and the bridged channel (if any)
++
++At the time when we write the report there might not be a bridge, so we need
++to store this so we can correlate the reports. If a channel changes bridge,
++it can be reset by first setting it to an empty string, then setting to 
++a new name 
++*/
++void ast_rtcp_set_bridged(struct ast_rtp *rtp, const char *channel, const char *uniqueid, const char *bridged_name, const char *bridged_uniqueid);
++
++/*! \brief Store translator information
++
++In order to measure quality of a phone call, information about transcoding is very useful. Translation
++adds processing and latency to the bridged call.
++*/
++void ast_rtcp_set_translation(struct ast_rtp *rtp, const char *writetranslator, const int writecost,
++				const char *readtranslator, const int readcost);
++
++/*! \brief When changing sources, don't generate a new SSRC */
++void ast_rtp_set_constantssrc(struct ast_rtp *rtp);
++
+ /*! \brief Indicate that we need to set the marker bit */
+ void ast_rtp_new_source(struct ast_rtp *rtp);
+ 
++
+ /*! \brief Indicate that we need to set the marker bit and change the ssrc */
+ void ast_rtp_change_source(struct ast_rtp *rtp);
+ 
+@@ -246,9 +294,13 @@
+ int ast_rtp_early_bridge(struct ast_channel *dest, struct ast_channel *src);
+ 
+ void ast_rtp_stop(struct ast_rtp *rtp);
++int ast_rtp_isactive(struct ast_rtp *rtp);
+ 
+ /*! \brief Return RTCP quality string */
+-char *ast_rtp_get_quality(struct ast_rtp *rtp, struct ast_rtp_quality *qual);
++char *ast_rtp_get_quality(struct ast_rtp *rtp);
++  
++/*! \brief Return RTCP quality data structure */
++struct ast_rtp_quality *ast_rtp_get_qualdata(struct ast_rtp *rtp);
+ 
+ /*! \brief Send an H.261 fast update request. Some devices need this rather than the XML message  in SIP */
+ int ast_rtcp_send_h261fur(void *data);
+Index: main/channel.c
+===================================================================
+--- main/channel.c	(.../branches/1.4)	(revision 382456)
++++ main/channel.c	(.../team/oej/pinefrog-1.4)	(revision 382456)
+@@ -1601,6 +1601,7 @@
+ {
+ 	if (option_debug)
+ 		ast_log(LOG_DEBUG, "Soft-Hanging up channel '%s'\n", chan->name);
++
+ 	/* Inform channel driver that we need to be hung up, if it cares */
+ 	chan->_softhangup |= cause;
+ 	ast_queue_frame(chan, &ast_null_frame);
+Index: main/rtp.c
+===================================================================
+--- main/rtp.c	(.../branches/1.4)	(revision 382456)
++++ main/rtp.c	(.../team/oej/pinefrog-1.4)	(revision 382456)
+@@ -64,13 +64,32 @@
+ #define RTCP_MIN_INTERVALMS       500	/*!< Min milli-seconds between RTCP reports we send */
+ #define RTCP_MAX_INTERVALMS       60000	/*!< Max milli-seconds between RTCP reports we send */
+ 
+-#define RTCP_PT_FUR     192
+-#define RTCP_PT_SR      200
+-#define RTCP_PT_RR      201
+-#define RTCP_PT_SDES    202
+-#define RTCP_PT_BYE     203
+-#define RTCP_PT_APP     204
++#define RTCP_PT_FUR     192		/*!< FIR  - Full Intra-frame request (h.261) */
++#define RTCP_PT_NACK    193		/*!< NACK - Negative acknowledgement (h.261) */
++#define RTCP_PT_IJ      195		/*!< IJ   - RFC 5450 Extended Inter-arrival jitter report */
++#define RTCP_PT_SR      200		/*!< SR   - RFC 3550 Sender report */
++#define RTCP_PT_RR      201		/*!< RR   - RFC 3550 Receiver report */
++#define RTCP_PT_SDES    202		/*!< SDES - Source Description */
++#define RTCP_PT_BYE     203		/*!< BYE  - Goodbye */
++#define RTCP_PT_APP     204		/*!< APP  - Application defined */
++#define RTCP_PT_RTPFB   205		/*!< RTPFB - Generic RTP feedback RFC 4585 */
++#define RTCP_PT_PSFB    206		/*!< PSFB - Payload specific data  RFC 4585 */
++#define RTCP_PT_XR      207		/*!< XR   - Extended report - RFC3611 */
+ 
++/*! \brief RFC 3550 RTCP SDES Item types */
++enum rtcp_sdes {
++	SDES_END	= 0,		/*!< End of SDES list */
++	SDES_CNAME	= 1,		/*!< Canonical name */
++	SDES_NAME	= 2,		/*!< User name */
++	SDES_EMAIL	= 3,		/*!< User's e-mail address */
++	SDES_PHONE	= 4,		/*!< User's phone number */
++	SDES_LOC	= 5,		/*!< Geographic user location */
++	SDES_TOOL	= 6,		/*!< Name of application or tool */
++	SDES_NOTE	= 7,		/*!< Notice about the source */
++	SDES_PRIV	= 8,		/*!< SDES Private extensions */
++	SDES_H323_CADDR	= 9,		/*!< H.323 Callable address */
++};
++
+ #define RTP_MTU		1200
+ 
+ #define DEFAULT_DTMF_TIMEOUT (150 * (8000 / 1000))	/*!< samples */
+@@ -155,14 +174,17 @@
+ 	struct timeval rxcore;
+ 	struct timeval txcore;
+ 	double drxcore;                 /*!< The double representation of the first received packet */
++	struct timeval start;		/*!< When the stream started (we can't depend on CDRs) */
+ 	struct timeval lastrx;          /*!< timeval when we last received a packet */
+ 	struct timeval dtmfmute;
+ 	struct ast_smoother *smoother;
+ 	int *ioid;
++	int *ioidrtcp;
+ 	unsigned short seqno;		/*!< Sequence number, RFC 3550, page 13. */
+ 	unsigned short rxseqno;
+-	struct sched_context *sched;
+-	struct io_context *io;
++	struct sched_context *sched;	/*!< The scheduler context */
++	struct io_context *io;		/*!< for RTP callback */
++	struct io_context *iortcp;	/*!< for RTCP callback */
+ 	void *data;
+ 	ast_rtp_callback callback;
+ 	ast_mutex_t bridge_lock;
+@@ -173,7 +195,9 @@
+ 	struct ast_rtcp *rtcp;
+ 	struct ast_codec_pref pref;
+ 	struct ast_rtp *bridged;        /*!< Who we are Packet bridged to */
++	struct ast_rtp_quality *qual;	/*!< Optional QoS data storage for this stream */
+ 	int set_marker_bit:1;           /*!< Whether to set the marker bit or not */
++	int isactive:2;                 /*!< Whether the RTP stream is active or not */
+ };
+ 
+ AST_LIST_HEAD_NOLOCK(frame_list, ast_frame);
+@@ -181,11 +205,15 @@
+ /* Forward declarations */
+ static int ast_rtcp_write(const void *data);
+ static void timeval2ntp(struct timeval tv, unsigned int *msw, unsigned int *lsw);
+-static int ast_rtcp_write_sr(const void *data);
+-static int ast_rtcp_write_rr(const void *data);
++static int ast_rtcp_write_sr(const void *data, int goodbye);
++static int ast_rtcp_write_rr(const void *data, int goodbye);
+ static unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp);
+ static int ast_rtp_senddigit_continuation(struct ast_rtp *rtp);
+ int ast_rtp_senddigit_end(struct ast_rtp *rtp, char digit);
++static struct ast_frame *ast_rtcp_read_fd(int fd, struct ast_rtp *rtp);
++static int ast_rtcp_write_empty(struct ast_rtp *rtp, int fd);
++static int p2p_rtcp_callback(int *id, int fd, short events, void *cbdata);
++static unsigned int calc_txstamp(struct ast_rtp *rtp, struct timeval *delivery);
+ int ast_rtp_senddigit_end_with_duration(struct ast_rtp *rtp, char digit, unsigned int duration);
+ 
+ #define FLAG_3389_WARNING		(1 << 0)
+@@ -211,6 +239,10 @@
+  */
+ struct ast_rtcp {
+ 	int s;				/*!< Socket */
++	char ourcname[255];		/*!< Our SDES RTP session name (CNAME) */
++	size_t ourcnamelength;		/*!< Length of CNAME (utf8) */
++	char theircname[255];		/*!< Their SDES RTP session name (CNAME) */
++	size_t theircnamelength;	/*!< Length of CNAME (utf8) */
+ 	struct sockaddr_in us;		/*!< Socket representation of the local endpoint. */
+ 	struct sockaddr_in them;	/*!< Socket representation of the remote endpoint. */
+ 	struct sockaddr_in altthem;	/*!< Alternate source for RTCP */
+@@ -224,17 +256,38 @@
+ 	int schedid;			/*!< Schedid returned from ast_sched_add() to schedule RTCP-transmissions*/
+ 	unsigned int rr_count;		/*!< number of RRs we've sent, not including report blocks in SR's */
+ 	unsigned int sr_count;		/*!< number of SRs we've sent */
++	unsigned int rec_rr_count;	/*!< Number of RRs we've received */
++	unsigned int rec_sr_count;	/*!< Number of SRs we've received */
+ 	unsigned int lastsrtxcount;     /*!< Transmit packet count when last SR sent */
+ 	double accumulated_transit;	/*!< accumulated a-dlsr-lsr */
+ 	double rtt;			/*!< Last reported rtt */
+ 	unsigned int reported_jitter;	/*!< The contents of their last jitter entry in the RR */
++	double reported_maxjitter;	/*!< The contents of their max jitter entry received by us */
++	double reported_minjitter;	/*!< The contents of their min jitter entry received by us */
++	unsigned int reported_jitter_count;	/*! Number of reports received */
+ 	unsigned int reported_lost;	/*!< Reported lost packets in their RR */
++	double reported_maxlost;
++	double reported_minlost;
++	double rxlost;
++	double maxrxlost;
++	double minrxlost;
++	unsigned int rxlost_count;	/*! Number of reports received */
+ 	char quality[AST_MAX_USER_FIELD];
+ 	double maxrxjitter;
+ 	double minrxjitter;
++	unsigned int rxjitter_count;	/*! Number of reports received */
+ 	double maxrtt;
+ 	double minrtt;
++	unsigned int rtt_count;		/*! Number of reports received */
+ 	int sendfur;
++	char bridgedchan[AST_MAX_EXTENSION];		/*!< Bridged channel name */
++	char bridgeduniqueid[AST_MAX_EXTENSION];	/*!< Bridged channel uniqueid */
++	char channel[AST_MAX_EXTENSION];		/*!< Our channel name */
++	char uniqueid[AST_MAX_EXTENSION];	/*!< Our channel uniqueid */
++	char readtranslator[80];	/* Translation done on reading audio from PBX */
++	char writetranslator[80];	/* Translation done on writing audio to PBX - bridged channel */
++	int readcost;			/* Delay in milliseconds for translation of 1 second of audio */
++	int writecost;			/* Delay in milliseconds for translation of 1 second of audio */
+ };
+ 
+ 
+@@ -532,6 +585,17 @@
+ 	return (subclass == AST_FORMAT_G722) ? 8000 : ast_format_rate(subclass);
+ }
+ 
++/*! \brief Schedule RTCP transmissions for RTP channel */
++static void ast_rtcp_schedule(struct ast_rtp *rtp)
++{
++	/* Do not schedule RR if RTCP isn't run */
++	if (rtp->rtcp && rtp->rtcp->them.sin_addr.s_addr && rtp->rtcp->schedid < 1) {
++		/* Schedule transmission of Receiver Report */
++		ast_rtcp_write_empty(rtp, rtp->rtcp->s);
++		rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
++	}
++}
++
+ unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp)
+ {
+ 	unsigned int interval;
+@@ -884,12 +948,27 @@
+ 	return 1;
+ }
+ 
++static int p2p_rtcp_callback(int *id, int fd, short events, void *cbdata)
++{
++	struct ast_rtp *rtp = cbdata;
++	ast_rtcp_read_fd(fd, rtp);
++	/* For now, skip any frames that is output. Which is bad for FUR's, but well. DEBUG */
++	return 1;
++}
++
+ struct ast_frame *ast_rtcp_read(struct ast_rtp *rtp)
+ {
++	return ast_rtcp_read_fd(rtp->rtcp->s, rtp);
++}
++
++static struct ast_frame *ast_rtcp_read_fd(int fd, struct ast_rtp *rtp)
++{
+ 	socklen_t len;
+-	int position, i, packetwords;
++	int position, i, j, packetwords;
+ 	int res;
+ 	struct sockaddr_in sin;
++	char *sdes;
++	unsigned int sdeslength, sdestype;
+ 	unsigned int rtcpdata[8192 + AST_FRIENDLY_OFFSET];
+ 	unsigned int *rtcpheader;
+ 	int pt;
+@@ -903,6 +982,7 @@
+ 	unsigned int msw;
+ 	unsigned int lsw;
+ 	unsigned int comp;
++	double reported_jitter, reported_lost;
+ 	struct ast_frame *f = &ast_null_frame;
+ 	
+ 	if (!rtp || !rtp->rtcp)
+@@ -910,8 +990,9 @@
+ 
+ 	len = sizeof(sin);
+ 	
+-	res = recvfrom(rtp->rtcp->s, rtcpdata + AST_FRIENDLY_OFFSET, sizeof(rtcpdata) - sizeof(unsigned int) * AST_FRIENDLY_OFFSET,
+-					0, (struct sockaddr *)&sin, &len);
++	res = recvfrom(fd, rtcpdata + AST_FRIENDLY_OFFSET, sizeof(rtcpdata) - sizeof(unsigned int) * AST_FRIENDLY_OFFSET,
++			0, (struct sockaddr *)&sin, &len);
++
+ 	rtcpheader = (unsigned int *)(rtcpdata + AST_FRIENDLY_OFFSET);
+ 	
+ 	if (res < 0) {
+@@ -923,7 +1004,7 @@
+ 		return &ast_null_frame;
+ 	}
+ 
+-	packetwords = res / 4;
++	packetwords = res / 4;	/* Each RTCP segment is 32 bits */
+ 
+ 	if (rtp->nat) {
+ 		/* Send to whoever sent to us */
+@@ -932,62 +1013,91 @@
+ 		    ((rtp->rtcp->altthem.sin_addr.s_addr != sin.sin_addr.s_addr) ||
+ 		    (rtp->rtcp->altthem.sin_port != sin.sin_port))) {
+ 			memcpy(&rtp->rtcp->them, &sin, sizeof(rtp->rtcp->them));
+-			if (option_debug || rtpdebug)
++			if (option_debug || rtpdebug) {
+ 				ast_log(LOG_DEBUG, "RTCP NAT: Got RTCP from other end. Now sending to address %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
++			}
+ 		}
+ 	}
+ 
+-	if (option_debug)
+-		ast_log(LOG_DEBUG, "Got RTCP report of %d bytes\n", res);
++	if (option_debug && rtcp_debug_test_addr(&sin)) {
++		ast_log(LOG_DEBUG, "Got RTCP report of %d bytes - %d messages\n", res, packetwords);
++	}
+ 
+-	/* Process a compound packet */
++	/* Process a compound packet 
++	   - A compound packet should start with a sender or receiver report. BYE can start as well
++		(seen in implementations) 
++	   -  Packet length should be a multiple of four bytes
++	*/
+ 	position = 0;
+ 	while (position < packetwords) {
+ 		i = position;
++		if (option_debug>3 && rtcp_debug_test_addr(&sin)) {
++			ast_log(LOG_DEBUG, "***** Debug - position = %d\n", position);
++		}
++
+ 		length = ntohl(rtcpheader[i]);
+-		pt = (length & 0xff0000) >> 16;
+-		rc = (length & 0x1f000000) >> 24;
++
++		pt = (length & 0xff0000) >> 16;		/* Packet type */
++		rc = (length & 0x1f000000) >> 24;	/* Number of chunks, i.e. streams reported */
+ 		length &= 0xffff;
+     
+ 		if ((i + length) > packetwords) {
+-			ast_log(LOG_WARNING, "RTCP Read too short\n");
+-			return &ast_null_frame;
++			ast_log(LOG_WARNING, "RTCP Read too short - packet type %d position %d\n", pt, i);
++			return f;
+ 		}
+ 		
+ 		if (rtcp_debug_test_addr(&sin)) {
+-		  	ast_verbose("\n\nGot RTCP from %s:%d\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
+-		  	ast_verbose("PT: %d(%s)\n", pt, (pt == 200) ? "Sender Report" : (pt == 201) ? "Receiver Report" : (pt == 192) ? "H.261 FUR" : "Unknown");
+-		  	ast_verbose("Reception reports: %d\n", rc);
+-		  	ast_verbose("SSRC of sender: %u\n", rtcpheader[i + 1]);
++		  	ast_verbose("\n-- Got RTCP from %s:%d\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
++		  	ast_verbose("   Length : %d Chunks: %d\n", length, rc);
++		  	ast_verbose("   SSRC of packet sender: %u (%x)", ntohl(rtcpheader[i + 1]), ntohl(rtcpheader[i + 1]));
++		  	ast_verbose("   (Position %d of %d)\n", i, packetwords);
++			if (rc == 0) {
++		  		ast_verbose("   Empty - no reports! \n");
++			}
+ 		}
+     
+ 		i += 2; /* Advance past header and ssrc */
+-		if (rc == 0 && pt == RTCP_PT_RR) {      /* We're receiving a receiver report with no reports, which is ok */
+-                        position += (length + 1);
+-                        continue;
+-                }
+-		
+-		switch (pt) {
+-		case RTCP_PT_SR:
+-			gettimeofday(&rtp->rtcp->rxlsr,NULL); /* To be able to populate the dlsr */
+-			rtp->rtcp->spc = ntohl(rtcpheader[i+3]);
+-			rtp->rtcp->soc = ntohl(rtcpheader[i + 4]);
++		if (rc == 0 && pt == RTCP_PT_RR) {	/* We're receiving a receiver report with no reports, which is ok */
++			position += (length + 1);
++			continue;
++		}
++		if (pt == RTCP_PT_SR) {
++			rtp->rtcp->rec_sr_count++;
++		} else if (pt == RTCP_PT_RR) {
++			rtp->rtcp->rec_rr_count++;
++		}
++
++		switch (pt) {	/* Find the RTCP Packet type */
++		case RTCP_PT_SR:	/* Sender's report - about what they have sent us */
++			if (rtcp_debug_test_addr(&sin)) {
++				ast_verbose("    - RTCP SR (sender report) from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
++			}
++			/* Don't handle multiple reception reports (rc > 1) yet */
++			gettimeofday(&rtp->rtcp->rxlsr, NULL); /* To be able to populate the dlsr */
++			rtp->rtcp->spc = ntohl(rtcpheader[i + 3]);	/* Sender packet count */
++			rtp->rtcp->soc = ntohl(rtcpheader[i + 4]);	/* Sender octet count */
++
+ 			rtp->rtcp->themrxlsr = ((ntohl(rtcpheader[i]) & 0x0000ffff) << 16) | ((ntohl(rtcpheader[i + 1]) & 0xffff0000) >> 16); /* Going to LSR in RR*/
+     
+ 			if (rtcp_debug_test_addr(&sin)) {
+-				ast_verbose("NTP timestamp: %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[i]), (unsigned long) ntohl(rtcpheader[i + 1]) * 4096);
+-				ast_verbose("RTP timestamp: %lu\n", (unsigned long) ntohl(rtcpheader[i + 2]));
+-				ast_verbose("SPC: %lu\tSOC: %lu\n", (unsigned long) ntohl(rtcpheader[i + 3]), (unsigned long) ntohl(rtcpheader[i + 4]));
++				ast_verbose("      NTP timestamp: %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[i]), (unsigned long) ntohl(rtcpheader[i + 1]) * 4096);
++				ast_verbose("      RTP timestamp: %lu\n", (unsigned long) ntohl(rtcpheader[i + 2]));
++				ast_verbose("      SPC: %lu\tSOC: %lu\n", (unsigned long) ntohl(rtcpheader[i + 3]), (unsigned long) ntohl(rtcpheader[i + 4]));
++				ast_verbose("      RC (number of reports) %d\n", rc);
+ 			}
+-			i += 5;
++			i += 5;	/* Sender's info report is five bytes */
+ 			if (rc < 1)
+ 				break;
+-			/* Intentional fall through */
+-		case RTCP_PT_RR:
++			/* Intentional fall through - the report blocks are the same for RR and SR */
++		case RTCP_PT_RR:	/* Receiver report - data about what we have sent to them */
++			if (rtcp_debug_test_addr(&sin)) {
++				ast_verbose("Received a RTCP RR (receiver report) from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
++			}
+ 			/* Don't handle multiple reception reports (rc > 1) yet */
+ 			/* Calculate RTT per RFC */
+ 			gettimeofday(&now, NULL);
+ 			timeval2ntp(now, &msw, &lsw);
++			/* Get timing */
+ 			if (ntohl(rtcpheader[i + 4]) && ntohl(rtcpheader[i + 5])) { /* We must have the LSR && DLSR */
+ 				comp = ((msw & 0xffff) << 16) | ((lsw & 0xffff0000) >> 16);
+ 				lsr = ntohl(rtcpheader[i + 4]);
+@@ -997,21 +1107,27 @@
+ 				/* Convert end to end delay to usec (keeping the calculation in 64bit space)
+ 				   sess->ee_delay = (eedelay * 1000) / 65536; */
+ 				if (rtt < 4294) {
+-				    rtt = (rtt * 1000000) >> 16;
++					rtt = (rtt * 1000000) >> 16;
+ 				} else {
+-				    rtt = (rtt * 1000) >> 16;
+-				    rtt *= 1000;
++					rtt = (rtt * 1000) >> 16;
++					rtt *= 1000;
+ 				}
+ 				rtt = rtt / 1000.;
+-				rttsec = rtt / 1000.;
++				// What is this?
++				//rttsec = rtt / 1000.;
++				rttsec = rtt;		//DEBUG OEJ
+ 
+ 				if (comp - dlsr >= lsr) {
+-					rtp->rtcp->accumulated_transit += rttsec;
+ 					rtp->rtcp->rtt = rttsec;
+-					if (rtp->rtcp->maxrtt<rttsec)
++					if (rtp->rtcp->maxrtt < rttsec) {
+ 						rtp->rtcp->maxrtt = rttsec;
+-					if (rtp->rtcp->minrtt>rttsec)
++					}
++					if (rtp->rtcp->minrtt > rttsec || rtp->rtcp->minrtt == 0) {
+ 						rtp->rtcp->minrtt = rttsec;
++					}
++					/* Calculation base for average rtt */
++					rtp->rtcp->accumulated_transit += rttsec;
++					rtp->rtcp->rtt_count++;
+ 				} else if (rtcp_debug_test_addr(&sin)) {
+ 					ast_verbose("Internal RTCP NTP clock skew detected: "
+ 							   "lsr=%u, now=%u, dlsr=%u (%d:%03dms), "
+@@ -1020,25 +1136,44 @@
+ 							   (dlsr % 65536) * 1000 / 65536,
+ 							   dlsr - (comp - lsr));
+ 				}
+-			}
++			} 
+ 
+ 			rtp->rtcp->reported_jitter = ntohl(rtcpheader[i + 3]);
++			reported_jitter = (double) rtp->rtcp->reported_jitter;
++			if (rtp->rtcp->reported_jitter > rtp->rtcp->reported_maxjitter) {
++				rtp->rtcp->reported_maxjitter = reported_jitter;
++			} else if (rtp->rtcp->reported_jitter < rtp->rtcp->reported_minjitter || rtp->rtcp->reported_minjitter == 0) {
++				rtp->rtcp->reported_minjitter = reported_jitter;
++			}
++		
+ 			rtp->rtcp->reported_lost = ntohl(rtcpheader[i + 1]) & 0xffffff;
++			reported_lost = (double) rtp->rtcp->reported_lost;
++			if (rtp->rtcp->reported_lost > rtp->rtcp->reported_maxlost) {
++				rtp->rtcp->reported_maxlost = reported_lost;
++			} else if (rtp->rtcp->reported_lost < rtp->rtcp->reported_minlost || rtp->rtcp->reported_jitter_count == 0) {
++				rtp->rtcp->reported_minlost = reported_lost;
++			}
++			rtp->rtcp->reported_jitter_count++;
+ 			if (rtcp_debug_test_addr(&sin)) {
+ 				ast_verbose("  Fraction lost: %ld\n", (((long) ntohl(rtcpheader[i + 1]) & 0xff000000) >> 24));
+ 				ast_verbose("  Packets lost so far: %d\n", rtp->rtcp->reported_lost);
+ 				ast_verbose("  Highest sequence number: %ld\n", (long) (ntohl(rtcpheader[i + 2]) & 0xffff));
+ 				ast_verbose("  Sequence number cycles: %ld\n", (long) (ntohl(rtcpheader[i + 2]) & 0xffff) >> 16);
+-				ast_verbose("  Interarrival jitter: %u\n", rtp->rtcp->reported_jitter);
+-				ast_verbose("  Last SR(our NTP): %lu.%010lu\n",(unsigned long) ntohl(rtcpheader[i + 4]) >> 16,((unsigned long) ntohl(rtcpheader[i + 4]) << 16) * 4096);
+-				ast_verbose("  DLSR: %4.4f (sec)\n",ntohl(rtcpheader[i + 5])/65536.0);
+-				if (rtt)
+-					ast_verbose("  RTT: %lu(sec)\n", (unsigned long) rtt);
++				ast_verbose("  Interarrival jitter: %u Max %f Min %f\n", rtp->rtcp->reported_jitter,
++					rtp->rtcp->reported_maxjitter, rtp->rtcp->reported_minjitter);
++				ast_verbose("  Last SR (our NTP): %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[i + 4]) >> 16,((unsigned long) ntohl(rtcpheader[i + 4]) << 16) * 4096);
++				ast_verbose("  DLSR: %4.4f (sec)\n", ntohl(rtcpheader[i + 5])/65536.0);
++				if (rtt) {
++					ast_verbose("  RTT: %lu (msec) Max %lu Min %lu\n", (unsigned long) rtt, 
++						(unsigned long) rtp->rtcp->maxrtt,
++						(unsigned long) rtp->rtcp->minrtt );
++				}
+ 			}
+ 			break;
+ 		case RTCP_PT_FUR:
+-			if (rtcp_debug_test_addr(&sin))
++			if (rtcp_debug_test_addr(&sin)) {
+ 				ast_verbose("Received an RTCP Fast Update Request\n");
++			}
+ 			rtp->f.frametype = AST_FRAME_CONTROL;
+ 			rtp->f.subclass = AST_CONTROL_VIDUPDATE;
+ 			rtp->f.datalen = 0;
+@@ -1048,24 +1183,139 @@
+ 			f = &rtp->f;
+ 			break;
+ 		case RTCP_PT_SDES:
+-			if (rtcp_debug_test_addr(&sin))
+-				ast_verbose("Received an SDES from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
++			/* SDES messages are divided into chunks, each one containing one or
++			   several items. Each chunk is for a different CSRC, so it's not really
++			   relevant in most cases of voip calls - unless you have an advanced
++			   mixer in the network that separates the different streams with CSRC 
++
++			   A chunk starts with SSRC/CSRC (four bytes), then SDES items 
++			   In the SDES message, there can be several items, ending with SDES_END
++			   The length of the all items is length - header 
++			   Chunk starts on a 32-bit boundary and needs padding by 0's
++		
++			   the "rc" variable contains the number of chunks 
++			   When we start, we're beyond the SSRC and starts with SDES items in the
++			   first chunk.
++			
++				an SDES item is one byte of type, one byte of length then data 
++				(no null termination). Text is UTF-8.
++				the last item is a zero (END) type with no length indication.
++			*/
++			
++			j = i * 4;
++			sdes = (char *) &rtcpheader[i];
++			if (rtcp_debug_test_addr(&sin)) {
++				ast_verbose("   Received an SDES from %s:%d - Total length %d (%d bytes)\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port), length-i, ((length-i)*4) - 6);
++			}
++			while (j < length * 4) {
++				sdestype = (int) *sdes;
++				sdes++;
++				sdeslength = (int) *sdes;
++				sdes++;
++				if (rtcp_debug_test_addr(&sin)) {
++					ast_verbose(" --- SDES Type %u, Length %u Curj %d)\n", sdestype, sdeslength, j);
++				}
++				switch (sdestype) {
++				case SDES_CNAME:
++					if (!ast_strlen_zero(rtp->rtcp->theircname)) {
++						if (strncmp(rtp->rtcp->theircname, sdes, sdeslength)) {
++							ast_log(LOG_WARNING, "New RTP stream received (new RTCP CNAME for session. Old name: %s\n", rtp->rtcp->theircname);
++						}
++					}
++					strncpy(rtp->rtcp->theircname, sdes, sdeslength);
++					rtp->rtcp->theircname[sdeslength + 1] = '\0';
++					rtp->rtcp->theircnamelength = sdeslength;
++					if (rtcp_debug_test_addr(&sin)) {
++						ast_verbose(" --- SDES CNAME (utf8) %s\n", rtp->rtcp->theircname);
++					}
++					break;
++				case SDES_TOOL:
++					if (rtcp_debug_test_addr(&sin)) {
++						ast_verbose(" --- SDES TOOL \n");
++					}
++					break;
++				case SDES_NAME:
++					if (rtcp_debug_test_addr(&sin)) {
++						ast_verbose(" --- SDES NAME \n");
++					}
++					break;
++				case SDES_EMAIL:
++					if (rtcp_debug_test_addr(&sin)) {
++						ast_verbose(" --- SDES EMAIL \n");
++					}
++					break;
++				case SDES_PHONE:
++					if (rtcp_debug_test_addr(&sin)) {
++						ast_verbose(" --- SDES PHONE \n");
++					}
++					break;
++				case SDES_LOC:
++					if (rtcp_debug_test_addr(&sin)) {
++						ast_verbose(" --- SDES LOC \n");
++					}
++					break;
++				case SDES_NOTE:
++					if (rtcp_debug_test_addr(&sin)) {
++						ast_verbose(" --- SDES NOTE \n");
++					}
++					break;
++				case SDES_PRIV:
++					if (rtcp_debug_test_addr(&sin)) {
++						ast_verbose(" --- SDES PRIV \n");
++					}
++					break;
++				case SDES_END:
++					if (rtcp_debug_test_addr(&sin)) {
++						ast_verbose(" --- SDES END \n");
++					}
++					break;
++				}
++				j += 2 + sdeslength;	/* Header (1 byte) + length */
++				sdes += sdeslength;
++				if (sdestype == SDES_END) {
++					break;	/* The while loop */
++				}
++			}
++
+ 			break;
++		case RTCP_PT_NACK:
++			if (rtcp_debug_test_addr(&sin)) {
++				ast_verbose("   Received a RTCP NACK from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
++			}
++			break;
+ 		case RTCP_PT_BYE:
+-			if (rtcp_debug_test_addr(&sin))
+-				ast_verbose("Received a BYE from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
++			if (rtcp_debug_test_addr(&sin)) {
++				ast_verbose("   Received a RTCP BYE from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
++			}
+ 			break;
++		case RTCP_PT_XR:
++			if (rtcp_debug_test_addr(&sin)) {
++				ast_verbose("   Received a RTCP Extended Report (XR) packet from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
++			}
++			break;
++		case RTCP_PT_APP:
++			if (rtcp_debug_test_addr(&sin)) {
++				ast_verbose("   Received a RTCP APP packet from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
++			}
++			break;
++		case RTCP_PT_IJ:
++			if (rtcp_debug_test_addr(&sin)) {
++				ast_verbose("   Received a RTCP IJ from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
++			}
++			break;
+ 		default:
+ 			if (option_debug)
+ 				ast_log(LOG_DEBUG, "Unknown RTCP packet (pt=%d) received from %s:%d\n", pt, ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+ 			break;
+ 		}
+ 		position += (length + 1);
+-	}
+-			
++	} /* While */
++
+ 	return f;
+ }
+ 
++			
++
+ static void sanitize_tv(struct timeval *tv)
+ {
+ 	while (tv->tv_usec < 0) {
+@@ -1101,6 +1351,7 @@
+ 	}
+ 
+ 	gettimeofday(&now,NULL);
++
+ 	/* rxcore is the mapping between the RTP timestamp and _our_ real time from gettimeofday() */
+ 	tv->tv_sec = rtp->rxcore.tv_sec + timestamp / rate;
+ 	tv->tv_usec = rtp->rxcore.tv_usec + (timestamp % rate) * 125;
+@@ -1114,10 +1365,18 @@
+ 	if (d<0)
+ 		d=-d;
+ 	rtp->rxjitter += (1./16.) * (d - rtp->rxjitter);
+-	if (rtp->rtcp && rtp->rxjitter > rtp->rtcp->maxrxjitter)
++	if (!rtp->rtcp) {
++		return;
++	}
++
++	if (rtp->rxjitter > rtp->rtcp->maxrxjitter)
+ 		rtp->rtcp->maxrxjitter = rtp->rxjitter;
+-	if (rtp->rtcp && rtp->rxjitter < rtp->rtcp->minrxjitter)
++	if (rtp->rtcp->rxjitter_count == 1) {
+ 		rtp->rtcp->minrxjitter = rtp->rxjitter;
++	}
++	if (rtp->rxjitter < rtp->rtcp->minrxjitter)
++		rtp->rtcp->minrxjitter = rtp->rxjitter;
++	rtp->rtcp->rxjitter_count++;
+ }
+ 
+ /*! \brief Perform a Packet2Packet RTP write */
+@@ -1126,6 +1385,11 @@
+ 	int res = 0, payload = 0, bridged_payload = 0, mark;
+ 	struct rtpPayloadType rtpPT;
+ 	int reconstruct = ntohl(rtpheader[0]);
++	unsigned int timestamp;
++	struct timeval rxtime;
++	//int header = 12;
++	int rate;
++	unsigned int ms;
+ 
+ 	/* Get fields from packet */
+ 	payload = (reconstruct & 0x7f0000) >> 16;
+@@ -1134,6 +1398,7 @@
+ 	/* Check what the payload value should be */
+ 	rtpPT = ast_rtp_lookup_pt(rtp, payload);
+ 
++
+ 	/* If the payload is DTMF, and we are listening for DTMF - then feed it into the core */
+ 	if (ast_test_flag(rtp, FLAG_P2P_NEED_DTMF) && !rtpPT.isAstFormat && rtpPT.code == AST_RTP_DTMF)
+ 		return -1;
+@@ -1152,12 +1417,29 @@
+ 		ast_set_flag(rtp, FLAG_P2P_SENT_MARK);
+ 	}
+ 
++	/* Calculate timestamp for reception of the packet */
++	timestamp = ntohl(rtpheader[1]);
++	calc_rxstamp(&rxtime, rtp, timestamp, mark);
++
++ 	rate = rtp_get_rate(bridged_payload) / 1000;
++
++	/* Now, calculate tx timestamp */
++        ms = calc_txstamp(rtp, &rxtime);
++        if (bridged_payload == AST_FRAME_VOICE) {
++                bridged->lastts = bridged->lastts + ms * rate;
++	} else if (bridged_payload == AST_FRAME_VIDEO) {
++		bridged->lastts = bridged->lastts + ms * 90;
++		/* This is not exact, but a best effort example that can be improved */
++	}
++
+ 	/* Reconstruct part of the packet */
+ 	reconstruct &= 0xFF80FFFF;
+ 	reconstruct |= (bridged_payload << 16);
+ 	reconstruct |= (mark << 23);
+ 	rtpheader[0] = htonl(reconstruct);
+ 
++	bridged->lasttxformat = rtp->lastrxformat = bridged_payload;
++
+ 	/* Send the packet back out */
+ 	res = sendto(bridged->s, (void *)rtpheader, len, 0, (struct sockaddr *)&bridged->them, sizeof(bridged->them));
+ 	if (res < 0) {
+@@ -1169,8 +1451,12 @@
+ 			ast_set_flag(bridged, FLAG_NAT_INACTIVE_NOWARN);
+ 		}
+ 		return 0;
+-	} else if (rtp_debug_test_addr(&bridged->them))
+-			ast_verbose("Sent RTP P2P packet to %s:%u (type %-2.2d, len %-6.6u)\n", ast_inet_ntoa(bridged->them.sin_addr), ntohs(bridged->them.sin_port), bridged_payload, len - hdrlen);
++	} 
++	bridged->txcount++;
++	bridged->txoctetcount +=(res - hdrlen);
++	if (rtp_debug_test_addr(&bridged->them)) {
++			ast_verbose("Sent RTP P2P packet %d to %s:%u (type %-2.2d, len %-6.6u)\n", rtp->txcount, ast_inet_ntoa(bridged->them.sin_addr), ntohs(bridged->them.sin_port), bridged_payload, len - hdrlen);
++	}
+ 
+ 	return 0;
+ }
+@@ -1216,7 +1502,7 @@
+ 	}
+ 	
+ 	if (res < hdrlen) {
+-		ast_log(LOG_WARNING, "RTP Read too short\n");
++		ast_log(LOG_WARNING, "RTP Read too short (%d, expecting %d)\n", res, hdrlen);
+ 		return &ast_null_frame;
+ 	}
+ 
+@@ -1256,26 +1542,13 @@
+ 				ast_log(LOG_DEBUG, "RTP NAT: Got audio from other end. Now sending to address %s:%d\n", ast_inet_ntoa(rtp->them.sin_addr), ntohs(rtp->them.sin_port));
+ 		}
+ 	}
+-
+-	/* If we are bridged to another RTP stream, send direct */
+-	if ((bridged = ast_rtp_get_bridged(rtp)) && !bridge_p2p_rtp_write(rtp, bridged, rtpheader, res, hdrlen))
+-		return &ast_null_frame;
+-
+-	if (version != 2)
+-		return &ast_null_frame;
+-
+-	payloadtype = (seqno & 0x7f0000) >> 16;
+-	padding = seqno & (1 << 29);
++	/* Stuff that is needed for RTCP - regardless of p2p bridge or not */
+ 	mark = seqno & (1 << 23);
+-	ext = seqno & (1 << 28);
+-	cc = (seqno & 0xF000000) >> 24;
+-	seqno &= 0xffff;
+ 	timestamp = ntohl(rtpheader[1]);
+ 	ssrc = ntohl(rtpheader[2]);
+ 
+- 	AST_LIST_HEAD_INIT_NOLOCK(&frames);
+- 	/* Force a marker bit and change SSRC if the SSRC changes */
+- 	if (rtp->rxssrc && rtp->rxssrc != ssrc) {
++	AST_LIST_HEAD_INIT_NOLOCK(&frames);
++	if (!mark && rtp->rxssrc && rtp->rxssrc != ssrc) {
+  		struct ast_frame *f, srcupdate = {
+  			AST_FRAME_CONTROL,
+  			.subclass = AST_CONTROL_SRCCHANGE,
+@@ -1292,27 +1565,22 @@
+ 	}
+ 
+ 	rtp->rxssrc = ssrc;
+-	
+-	if (padding) {
+-		/* Remove padding bytes */
+-		res -= rtp->rawdata[AST_FRIENDLY_OFFSET + res - 1];
+-	}
+-	
+-	if (cc) {
+-		/* CSRC fields present */
+-		hdrlen += cc*4;
+-	}
+ 
+-	if (ext) {
+-		/* RTP Extension present */
+-		hdrlen += (ntohl(rtpheader[hdrlen/4]) & 0xffff) << 2;
+-		hdrlen += 4;
+-	}
++	if (rtp->themssrc==0)
++		rtp->themssrc = ntohl(rtpheader[2]); /* Record their SSRC to put in future RR */
+ 
++	if (version != 2)
++		return &ast_null_frame;
++
+ 	if (res < hdrlen) {
+ 		ast_log(LOG_WARNING, "RTP Read too short (%d, expecting %d)\n", res, hdrlen);
+ 		return AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;
+ 	}
++	payloadtype = (seqno & 0x7f0000) >> 16;
++	padding = seqno & (1 << 29);
++	ext = seqno & (1 << 28);
++	cc = (seqno & 0xF000000) >> 24;
++	seqno &= 0xffff;
+ 
+ 	rtp->rxcount++; /* Only count reasonably valid packets, this'll make the rtcp stats more accurate */
+ 
+@@ -1321,19 +1589,39 @@
+ 		rtp->seedrxseqno = seqno;
+ 	}
+ 
+-	/* Do not schedule RR if RTCP isn't run */
+-	if (rtp->rtcp && rtp->rtcp->them.sin_addr.s_addr && rtp->rtcp->schedid < 1) {
+-		/* Schedule transmission of Receiver Report */
+-		rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
+-	}
+ 	if ( (int)rtp->lastrxseqno - (int)seqno  > 100) /* if so it would indicate that the sender cycled; allow for misordering */
+ 		rtp->cycles += RTP_SEQ_MOD;
+ 
+ 	rtp->lastrxseqno = seqno;
++
++	/* Schedule RTCP report transmissions if possible */
++	ast_rtcp_schedule(rtp);
++
++
++	/* If we are bridged to another RTP stream, send direct */
++	if ((bridged = ast_rtp_get_bridged(rtp)) && !bridge_p2p_rtp_write(rtp, bridged, rtpheader, res, hdrlen))
++		return &ast_null_frame;
++
++
+ 	
+-	if (rtp->themssrc==0)
+-		rtp->themssrc = ntohl(rtpheader[2]); /* Record their SSRC to put in future RR */
+ 	
++	if (padding) {
++		/* Remove padding bytes */
++		res -= rtp->rawdata[AST_FRIENDLY_OFFSET + res - 1];
++	}
++	
++	if (cc) {
++		/* CSRC fields present */
++		hdrlen += cc*4;
++	}
++
++	if (ext) {
++		/* RTP Extension present */
++		hdrlen += (ntohl(rtpheader[hdrlen/4]) & 0xffff) << 2;
++		hdrlen += 4;
++	}
++
++	
+ 	if (rtp_debug_test_addr(&sin))
+ 		ast_verbose("Got  RTP packet from    %s:%u (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
+ 			ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port), payloadtype, seqno, timestamp,res - hdrlen);
+@@ -2002,7 +2290,10 @@
+ 	rtp->ssrc = ast_random();
+ 	rtp->seqno = ast_random() & 0xffff;
+ 	ast_set_flag(rtp, FLAG_HAS_DTMF);
++	rtp->isactive = 1;
+ 
++	gettimeofday(&rtp->start, NULL);
++
+ 	return;
+ }
+ 
+@@ -2088,6 +2379,7 @@
+ 	if (callbackmode) {
+ 		rtp->ioid = ast_io_add(rtp->io, rtp->s, rtpread, AST_IO_IN, rtp);
+ 		ast_set_flag(rtp, FLAG_CALLBACK_MODE);
++		rtp->ioidrtcp = ast_io_add(rtp->iortcp, rtp->rtcp->s, p2p_rtcp_callback, AST_IO_IN, rtp);
+ 	}
+ 	ast_rtp_pt_default(rtp);
+ 	return rtp;
+@@ -2101,6 +2393,71 @@
+ 	return ast_rtp_new_with_bindaddr(sched, io, rtcpenable, callbackmode, ia);
+ }
+ 
++/*! \brief set RTP cname used to describe session in RTCP sdes messages */
++void ast_rtcp_setcname(struct ast_rtp *rtp, const char *cname, size_t length)
++{
++	if (!rtp || !rtp->rtcp) {
++		return;
++	}
++	if (length > 255) {
++		length=255;
++	}
++	ast_copy_string(rtp->rtcp->ourcname, cname, length+1);
++	rtp->rtcp->ourcnamelength = length;
++	if (option_debug > 3) {
++		ast_log(LOG_DEBUG, "--- Copied CNAME %s to RTCP structure (length %d)\n", cname, (int) length);
++	}
++}
++
++/*! \brief Set the transcoding variables for the QoS reports */
++void ast_rtcp_settranslator(struct ast_rtp *rtp, const char *readtranslator, const int readcost, const char *writetranslator, const int writecost)
++{
++	if (!rtp || !rtp->rtcp) {
++		return;
++	}
++	ast_copy_string(rtp->rtcp->readtranslator, S_OR(readtranslator,""), sizeof(rtp->rtcp->readtranslator));
++	ast_copy_string(rtp->rtcp->writetranslator, S_OR(writetranslator,""), sizeof(rtp->rtcp->writetranslator));
++	rtp->rtcp->readcost = readcost;
++	rtp->rtcp->writecost = writecost;
++	
++}
++
++/*! \brief set the name of the bridged channel
++
++At the time when we write the report there might not be a bridge, so we need
++to store this so we can correlate the reports. If a channel changes bridge,
++it can be reset by first setting it to an empty string, then setting to 
++a new name 
++*/
++void ast_rtcp_set_bridged(struct ast_rtp *rtp, const char *channel, const char *uniqueid, const char *bridgedchan, const char *bridgeduniqueid)
++{
++	if (!rtp) {		/* For some reason, there's no RTP */
++		return;
++	}
++	if (!rtp->rtcp) {	/* No RTCP? Strange */
++		return;
++	}
++	/* If we already have data, don't replace it. 
++		NOTE: Should we replace it at a masquerade or something? Hmm.
++	*/
++	if (channel && !rtp->rtcp->channel[0]) {
++		ast_copy_string(rtp->rtcp->channel, channel, sizeof(rtp->rtcp->channel));
++	}
++	if (uniqueid && !rtp->rtcp->uniqueid[0]) {
++		ast_copy_string(rtp->rtcp->uniqueid, uniqueid, sizeof(rtp->rtcp->uniqueid));
++	}
++	if (bridgedchan) {
++		ast_copy_string(rtp->rtcp->bridgedchan, bridgedchan, sizeof(rtp->rtcp->bridgedchan));
++	} else {
++		rtp->rtcp->bridgedchan[0] = '\0';
++	}
++	if (bridgeduniqueid) {
++		ast_copy_string(rtp->rtcp->bridgeduniqueid, bridgeduniqueid, sizeof(rtp->rtcp->bridgeduniqueid));
++	} else {
++		rtp->rtcp->bridgeduniqueid[0] = '\0';
++	}
++}
++
+ int ast_rtp_settos(struct ast_rtp *rtp, int tos)
+ {
+ 	int res;
+@@ -2183,11 +2540,21 @@
+ 	return bridged;
+ }
+ 
++int ast_rtp_isactive(struct ast_rtp *rtp)
++{
++	return rtp->isactive;
++}
++
+ void ast_rtp_stop(struct ast_rtp *rtp)
+ {
+-	if (rtp->rtcp) {
++	if (rtp->rtcp && rtp->rtcp->schedid != -1) {
+ 		AST_SCHED_DEL(rtp->sched, rtp->rtcp->schedid);
++		rtp->rtcp->schedid = -1;
+ 	}
++	/* Send RTCP goodbye packet */
++	if (rtp->isactive) {
++		ast_rtcp_write_sr((const void *) rtp, 1);
++	}
+ 
+ 	memset(&rtp->them.sin_addr, 0, sizeof(rtp->them.sin_addr));
+ 	memset(&rtp->them.sin_port, 0, sizeof(rtp->them.sin_port));
+@@ -2197,6 +2564,7 @@
+ 	}
+ 	
+ 	ast_clear_flag(rtp, FLAG_P2P_SENT_MARK);
++	rtp->isactive = 0;
+ }
+ 
+ void ast_rtp_reset(struct ast_rtp *rtp)
+@@ -2218,8 +2586,13 @@
+ 	rtp->rxseqno = 0;
+ }
+ 
+-char *ast_rtp_get_quality(struct ast_rtp *rtp, struct ast_rtp_quality *qual)
++struct ast_rtp_quality *ast_rtp_get_qualdata(struct ast_rtp *rtp)
+ {
++	return(rtp->qual);
++}
++
++char *ast_rtp_get_quality(struct ast_rtp *rtp)
++{
+ 	/*
+ 	*ssrc          our ssrc
+ 	*themssrc      their ssrc
+@@ -2232,19 +2605,65 @@
+ 	*rtt           round trip time
+ 	*/
+ 
+-	if (qual && rtp) {
+-		qual->local_ssrc = rtp->ssrc;
+-		qual->local_jitter = rtp->rxjitter;
+-		qual->local_count = rtp->rxcount;
+-		qual->remote_ssrc = rtp->themssrc;
+-		qual->remote_count = rtp->txcount;
++	if (!rtp->qual) {
++		if (!(rtp->qual = ast_calloc(1, sizeof(*rtp->qual)))) {
++			ast_log(LOG_ERROR, "Memory allocation error.\n");
++		}
++	}
++	if (rtp->qual && rtp) {
++		rtp->qual->start = rtp->start;
++		rtp->qual->lasttxformat = rtp->lasttxformat;
++		rtp->qual->lastrxformat = rtp->lastrxformat;
++		rtp->qual->local_ssrc = rtp->ssrc;
++		rtp->qual->local_jitter = rtp->rxjitter;
++		rtp->qual->local_count = rtp->rxcount;
++		rtp->qual->remote_ssrc = rtp->themssrc;
++		rtp->qual->remote_count = rtp->txcount;
+ 		if (rtp->rtcp) {
+-			qual->local_lostpackets = rtp->rtcp->expected_prior - rtp->rtcp->received_prior;
+-			qual->remote_lostpackets = rtp->rtcp->reported_lost;
+-			qual->remote_jitter = rtp->rtcp->reported_jitter / 65536.0;
+-			qual->rtt = rtp->rtcp->rtt;
++			if (rtp->rtcp->them.sin_addr.s_addr) {
++				/* Do not change to empty address */
++				memcpy(&rtp->qual->them, &rtp->rtcp->them, sizeof(rtp->qual->them));
++			}
++			rtp->qual->numberofreports = rtp->rtcp->reported_jitter_count;	/* use the jitter counter */
++			rtp->qual->local_jitter_max = rtp->rtcp->maxrxjitter;
++			rtp->qual->local_jitter_min = rtp->rtcp->minrxjitter;
++			rtp->qual->local_lostpackets = rtp->rtcp->expected_prior - rtp->rtcp->received_prior;
++			rtp->qual->remote_lostpackets = rtp->rtcp->reported_lost;
++			rtp->qual->remote_jitter = rtp->rtcp->reported_jitter / 65536.0;
++			rtp->qual->remote_jitter_max = rtp->rtcp->reported_maxjitter;
++			rtp->qual->remote_jitter_min = rtp->rtcp->reported_minjitter;
++			rtp->qual->rtt = rtp->rtcp->rtt;
++			rtp->qual->rttmax = rtp->rtcp->maxrtt;
++			rtp->qual->rttmin = rtp->rtcp->minrtt;
++			rtp->qual->channel[0] = '\0';
++			rtp->qual->uniqueid[0] = '\0';
++			rtp->qual->bridgedchan[0] = '\0';
++			rtp->qual->bridgeduniqueid[0] = '\0';
++			rtp->qual->readtranslator[0] = '\0';
++			rtp->qual->writetranslator[0] = '\0';
++			if (!ast_strlen_zero(rtp->rtcp->bridgedchan)) {
++				ast_copy_string(rtp->qual->bridgedchan, rtp->rtcp->bridgedchan, sizeof(rtp->qual->bridgedchan));
++			}
++			if (!ast_strlen_zero(rtp->rtcp->bridgeduniqueid)) {
++				ast_copy_string(rtp->qual->bridgeduniqueid, rtp->rtcp->bridgeduniqueid, sizeof(rtp->qual->bridgeduniqueid));
++			}
++			if (!ast_strlen_zero(rtp->rtcp->channel)) {
++				ast_copy_string(rtp->qual->channel, rtp->rtcp->channel, sizeof(rtp->qual->channel));
++			}
++			if (!ast_strlen_zero(rtp->rtcp->uniqueid)) {
++				ast_copy_string(rtp->qual->uniqueid, rtp->rtcp->uniqueid, sizeof(rtp->qual->uniqueid));
++			}
++			rtp->qual->readcost = rtp->rtcp->readcost;
++			rtp->qual->writecost = rtp->rtcp->writecost;
++			if (!ast_strlen_zero(rtp->rtcp->readtranslator)) {
++				ast_copy_string(rtp->qual->readtranslator, rtp->rtcp->readtranslator, sizeof(rtp->qual->readtranslator));
++			}
++			if (!ast_strlen_zero(rtp->rtcp->writetranslator)) {
++				ast_copy_string(rtp->qual->writetranslator, rtp->rtcp->writetranslator, sizeof(rtp->qual->writetranslator));
++			}
+ 		}
+ 	}
++	/* The old way */
+ 	if (rtp->rtcp) {
+ 		snprintf(rtp->rtcp->quality, sizeof(rtp->rtcp->quality),
+ 			"ssrc=%u;themssrc=%u;lp=%u;rxjitter=%f;rxcount=%u;txjitter=%f;txcount=%u;rlp=%u;rtt=%f",
+@@ -2258,35 +2677,59 @@
+ 			rtp->rtcp->reported_lost,
+ 			rtp->rtcp->rtt);
+ 		return rtp->rtcp->quality;
+-	} else
++	} else {
+ 		return "<Unknown> - RTP/RTCP has already been destroyed";
++	}
+ }
+ 
+ void ast_rtp_destroy(struct ast_rtp *rtp)
+ {
+ 	if (rtcp_debug_test_addr(&rtp->them) || rtcpstats) {
+ 		/*Print some info on the call here */
+-		ast_verbose("  RTP-stats\n");
++		ast_verbose(" RTP-stats\n");
+ 		ast_verbose("* Our Receiver:\n");
+-		ast_verbose("  SSRC:		 %u\n", rtp->themssrc);
+-		ast_verbose("  Received packets: %u\n", rtp->rxcount);
+-		ast_verbose("  Lost packets:	 %u\n", rtp->rtcp ? (rtp->rtcp->expected_prior - rtp->rtcp->received_prior) : 0);
+-		ast_verbose("  Jitter:		 %.4f\n", rtp->rxjitter);
+-		ast_verbose("  Transit:		 %.4f\n", rtp->rxtransit);
+-		ast_verbose("  RR-count:	 %u\n", rtp->rtcp ? rtp->rtcp->rr_count : 0);
++		ast_verbose("   SSRC:		     %u\n", rtp->themssrc);
++		ast_verbose("   CNAME:		     %s\n", rtp->rtcp ? rtp->rtcp->theircname : "");
++		ast_verbose("   Received packets:    %u\n", rtp->rxcount);
++		ast_verbose("   Lost packets:	     %u\n", rtp->rtcp ? (rtp->rtcp->expected_prior - rtp->rtcp->received_prior) : 0);
++		ast_verbose("   Jitter:		     %.4f Max %.4f Min %.4f\n", rtp->rxjitter, 
++				rtp->rtcp ? rtp->rtcp->maxrxjitter : 0, 
++				rtp->rtcp ? rtp->rtcp->minrxjitter : 0);
++		ast_verbose("   Transit:	     %.4f\n", rtp->rxtransit);
++		ast_verbose("   Received RTCP RR/SR: %u\n", rtp->rtcp ? rtp->rtcp->rec_rr_count + rtp->rtcp->rec_sr_count : 0);
++
+ 		ast_verbose("* Our Sender:\n");
+-		ast_verbose("  SSRC:		 %u\n", rtp->ssrc);
+-		ast_verbose("  Sent packets:	 %u\n", rtp->txcount);
+-		ast_verbose("  Lost packets:	 %u\n", rtp->rtcp ? rtp->rtcp->reported_lost : 0);
+-		ast_verbose("  Jitter:		 %u\n", rtp->rtcp ? (rtp->rtcp->reported_jitter / (unsigned int)65536.0) : 0);
+-		ast_verbose("  SR-count:	 %u\n", rtp->rtcp ? rtp->rtcp->sr_count : 0);
+-		ast_verbose("  RTT:		 %f\n", rtp->rtcp ? rtp->rtcp->rtt : 0);
++		ast_verbose("   SSRC:		     %u\n", rtp->ssrc);
++		ast_verbose("   CNAME:		     %s\n", rtp->rtcp ? rtp->rtcp->ourcname : "");
++		ast_verbose("   Sent packets:	     %u\n", rtp->txcount);
++		if (rtp->rtcp && rtp->rtcp->rec_rr_count + rtp->rtcp->rec_sr_count == 0) {
++			ast_verbose("   No RTCP reports received. No stats available for packet loss, jitter and delay\n");
++		} else if (rtp->rtcp) {
++			ast_verbose("   Lost packets:	     %u\n", rtp->rtcp->reported_lost);
++			ast_verbose("   Jitter:		     %u\n", (rtp->rtcp->reported_jitter / (unsigned int)65536.0));
++			ast_verbose("   RTT:		     %lu\n", (unsigned long) rtp->rtcp->rtt);
++			ast_verbose("   RTT Max:	     %lu\n", (unsigned long) rtp->rtcp->maxrtt);
++			ast_verbose("   RTT Min:	     %lu\n", (unsigned long) rtp->rtcp->minrtt);
++			ast_verbose("	RTT count:           %u\n", rtp->rtcp->rtt_count  );
++			ast_verbose("	RTT avg:             %lu\n", rtp->rtcp->rtt_count ? 
++				 (unsigned long) rtp->rtcp->accumulated_transit / rtp->rtcp->rtt_count : 0);
++		}
++		ast_verbose("   RR-count:	     %u\n", rtp->rtcp ? rtp->rtcp->rr_count : 0);
++		ast_verbose("   SR-count:	     %u\n", rtp->rtcp ? rtp->rtcp->sr_count : 0);
++
++		ast_verbose("* Media\n");
++		ast_verbose("   Last format sent: %s\n", ast_getformatname(rtp->lasttxformat));
++		ast_verbose("   Last format recv: %s\n", ast_getformatname(rtp->lastrxformat));
++
++		ast_verbose("\n");
+ 	}
+ 
+ 	if (rtp->smoother)
+ 		ast_smoother_free(rtp->smoother);
+ 	if (rtp->ioid)
+ 		ast_io_remove(rtp->io, rtp->ioid);
++	if (rtp->ioidrtcp)
++		ast_io_remove(rtp->iortcp, rtp->ioidrtcp);
+ 	if (rtp->s > -1)
+ 		close(rtp->s);
+ 	if (rtp->rtcp) {
+@@ -2295,6 +2738,10 @@
+ 		free(rtp->rtcp);
+ 		rtp->rtcp=NULL;
+ 	}
++	if (rtp->qual) {
++		free(rtp->qual);
++		rtp->qual=NULL;
++	}
+ 
+ 	ast_mutex_destroy(&rtp->bridge_lock);
+ 
+@@ -2503,16 +2950,121 @@
+ 	return res;
+ }
+ 
++/*! \brief Basically add SSRC */
++static int add_sdes_header(struct ast_rtp *rtp, unsigned int *rtcp_packet, int len)
++{
++	/* 2 is version, 1 is number of chunks, then RTCP packet type (SDES) and length */
++	*rtcp_packet = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | ((len/4)-1));
++
++	rtcp_packet++;	/* Move 32 bits ahead for the header */
++	*rtcp_packet = htonl(rtp->ssrc);               /* Our SSRC */
++	rtcp_packet ++;
++
++	/* Header + SSRC */
++	return len + 8;
++}
++
++static int add_sdes_bodypart(struct ast_rtp *rtp, unsigned int *rtcp_packet, int len, int type)
++{
++	int cnamelen;
++	int sdeslen = 0;
++	char *sdes;
++
++	sdes = (char *) rtcp_packet;
++	switch (type) {
++	case SDES_CNAME:
++		cnamelen = (int) rtp->rtcp->ourcnamelength;
++
++		*sdes = SDES_CNAME;
++		sdes++;
++		*sdes = (char) cnamelen;
++		sdes++;
++		strncpy(sdes, rtp->rtcp->ourcname, cnamelen);	/* NO terminating 0 */
++
++		/* THere must be a multiple of four bytes in the packet */
++		sdeslen = cnamelen;
++		break;
++	case SDES_END:
++		*sdes = SDES_END;
++		sdes++;
++		*sdes = (char) 0;
++		sdes++;
++		sdeslen = 2;
++	}
++	len += sdeslen + (sdeslen % 4 == 0 ? 0 : 4 - (sdeslen % 4)) ;
++
++	return len;
++}
++
++/*! \brief Send emtpy RTCP receiver's report and SDES message 
++ 	Mainly used to open NAT sessions  */
++static int ast_rtcp_write_empty(struct ast_rtp *rtp, int fd)
++{
++	char bdata[512];
++	unsigned int *rtcpheader, *start;
++	int len, res;
++
++	if (!rtp || !rtp->rtcp) {
++		return 0;
++	} 
++	if (fd == -1) {
++		ast_log(LOG_DEBUG, "--- No file descriptor to use \n");
++	}
++	
++	if (!rtp->rtcp->them.sin_addr.s_addr) {  /* This'll stop rtcp for this rtp session */
++		ast_verbose("RTCP SR transmission error, rtcp halted\n");
++		AST_SCHED_DEL(rtp->sched, rtp->rtcp->schedid);
++		return 0;
++	}
++	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
++		ast_log(LOG_DEBUG,  "---- About to send empty RTCP packet\n");
++	}
++	rtcpheader = (unsigned int *)bdata;
++	/* Add a RR header with no reports (chunks = 0) - The RFC says that it's always needed 
++		first in a compound packet.
++	 */
++	rtcpheader[0] = htonl((2 << 30) | (0 << 24) | (RTCP_PT_RR << 16) | 1);
++	rtcpheader[1] = htonl(rtp->ssrc);
++	len = 8;
++	start = &rtcpheader[len/4];
++	len +=8; /* SKip header for now */
++	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_CNAME);
++	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_END);
++	/* Now, add header when we know the actual length */
++	add_sdes_header(rtp, start, len);
++
++	res = sendto(fd, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&rtp->rtcp->them, sizeof(rtp->rtcp->them));
++
++	if (res < 0) {
++		ast_log(LOG_ERROR, "RTCP RR transmission error, rtcp halted: %s\n",strerror(errno));
++		/* Remove the scheduler */
++		AST_SCHED_DEL(rtp->sched, rtp->rtcp->schedid);
++		return 0;
++	}
++
++	rtp->rtcp->rr_count++;
++
++	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
++		ast_verbose("\n* Sending Empty RTCP RR to %s:%d  Our SSRC: %u\n",
++			ast_inet_ntoa(rtp->rtcp->them.sin_addr),
++			ntohs(rtp->rtcp->them.sin_port),
++			rtp->ssrc);
++	}
++
++	return res;
++}
++
+ /*! \brief Send RTCP sender's report */
+-static int ast_rtcp_write_sr(const void *data)
++static int ast_rtcp_write_sr(const void *data, int goodbye)
+ {
+ 	struct ast_rtp *rtp = (struct ast_rtp *)data;
+ 	int res;
+-	int len = 0;
++	int len = 0;	/* Measured in chunks of four bytes */
++	int srlen = 0;
+ 	struct timeval now;
+ 	unsigned int now_lsw;
+ 	unsigned int now_msw;
+-	unsigned int *rtcpheader;
++	unsigned int *rtcpheader, *start;
+ 	unsigned int lost;
+ 	unsigned int extended;
+ 	unsigned int expected;
+@@ -2523,8 +3075,7 @@
+ 	struct timeval dlsr;
+ 	char bdata[512];
+ 
+-	/* Commented condition is always not NULL if rtp->rtcp is not NULL */
+-	if (!rtp || !rtp->rtcp/* || (&rtp->rtcp->them.sin_addr == 0)*/)
++	if (!rtp || !rtp->rtcp)
+ 		return 0;
+ 	
+ 	if (!rtp->rtcp->them.sin_addr.s_addr) {  /* This'll stop rtcp for this rtp session */
+@@ -2534,7 +3085,7 @@
+ 	}
+ 
+ 	gettimeofday(&now, NULL);
+-	timeval2ntp(now, &now_msw, &now_lsw); /* fill thses ones in from utils.c*/
++	timeval2ntp(now, &now_msw, &now_lsw); /* fill theses ones in from utils.c*/
+ 	rtcpheader = (unsigned int *)bdata;
+ 	rtcpheader[1] = htonl(rtp->ssrc);               /* Our SSRC */
+ 	rtcpheader[2] = htonl(now_msw);                 /* now, MSW. gettimeofday() + SEC_BETWEEN_1900_AND_1970*/
+@@ -2567,6 +3118,7 @@
+ 	rtcpheader[12] = htonl((((dlsr.tv_sec * 1000) + (dlsr.tv_usec / 1000)) * 65536) / 1000);
+ 	len += 24;
+ 	
++	/* Set the header for sender's report */
+ 	rtcpheader[0] = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SR << 16) | ((len/4)-1));
+ 
+ 	if (rtp->rtcp->sendfur) {
+@@ -2575,14 +3127,23 @@
+ 		len += 8;
+ 		rtp->rtcp->sendfur = 0;
+ 	}
++
++	start = &rtcpheader[len/4];
++	srlen = len;
++	len +=8; /* SKip header for now */
++	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_CNAME);
++	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_END);
++	/* Now, add header when we know the actual length */
++	add_sdes_header(rtp, start, len - srlen);
++
++	if (goodbye) {
++		/* An additional RTCP block */
++		rtcpheader[len/4] = htonl((2 << 30) | (1 << 24) | (RTCP_PT_BYE << 16) | 1);
++		len += 4;
++		rtcpheader[len/4] = htonl(rtp->ssrc);               /* Our SSRC */
++		len += 4;
++	}
+ 	
+-	/* Insert SDES here. Probably should make SDES text equal to mimetypes[code].type (not subtype 'cos */ 
+-	/* it can change mid call, and SDES can't) */
+-	rtcpheader[len/4]     = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | 2);
+-	rtcpheader[(len/4)+1] = htonl(rtp->ssrc);               /* Our SSRC */
+-	rtcpheader[(len/4)+2] = htonl(0x01 << 24);                    /* Empty for the moment */
+-	len += 12;
+-	
+ 	res = sendto(rtp->rtcp->s, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&rtp->rtcp->them, sizeof(rtp->rtcp->them));
+ 	if (res < 0) {
+ 		ast_log(LOG_ERROR, "RTCP SR transmission error to %s:%d, rtcp halted %s\n",ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port), strerror(errno));
+@@ -2600,21 +3161,22 @@
+ 		ast_verbose("* Sent RTCP SR to %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+ 		ast_verbose("  Our SSRC: %u\n", rtp->ssrc);
+ 		ast_verbose("  Sent(NTP): %u.%010u\n", (unsigned int)now.tv_sec, (unsigned int)now.tv_usec*4096);
++		ast_verbose("  Send NTP variant: %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[2]),((unsigned long) ntohl(rtcpheader[3])) * 4096);
+ 		ast_verbose("  Sent(RTP): %u\n", rtp->lastts);
+ 		ast_verbose("  Sent packets: %u\n", rtp->txcount);
+ 		ast_verbose("  Sent octets: %u\n", rtp->txoctetcount);
+ 		ast_verbose("  Report block:\n");
+-		ast_verbose("  Fraction lost: %u\n", fraction);
+-		ast_verbose("  Cumulative loss: %u\n", lost);
+-		ast_verbose("  IA jitter: %.4f\n", rtp->rxjitter);
+-		ast_verbose("  Their last SR: %u\n", rtp->rtcp->themrxlsr);
+-		ast_verbose("  DLSR: %4.4f (sec)\n\n", (double)(ntohl(rtcpheader[12])/65536.0));
++		ast_verbose("    Fraction lost (since last report): %u\n", fraction);
++		ast_verbose("    Cumulative loss: %u\n", lost);
++		ast_verbose("    IA jitter: %.4f\n", rtp->rxjitter);
++		ast_verbose("    Their last SR: %u\n", rtp->rtcp->themrxlsr);
++		ast_verbose("    Delay since last SR (DLSR): %4.4f (sec)\n\n", (double)(ntohl(rtcpheader[12])/65536.0));
+ 	}
+ 	return res;
+ }
+ 
+ /*! \brief Send RTCP recepient's report */
+-static int ast_rtcp_write_rr(const void *data)
++static int ast_rtcp_write_rr(const void *data, int goodbye)
+ {
+ 	struct ast_rtp *rtp = (struct ast_rtp *)data;
+ 	int res;
+@@ -2626,7 +3188,7 @@
+ 	unsigned int received_interval;
+ 	int lost_interval;
+ 	struct timeval now;
+-	unsigned int *rtcpheader;
++	unsigned int *rtcpheader, *start;
+ 	char bdata[1024];
+ 	struct timeval dlsr;
+ 	int fraction;
+@@ -2648,6 +3210,8 @@
+ 	received_interval = rtp->rxcount - rtp->rtcp->received_prior;
+ 	rtp->rtcp->received_prior = rtp->rxcount;
+ 	lost_interval = expected_interval - received_interval;
++
++	rtp->rtcp->rxlost_count++;
+ 	if (expected_interval == 0 || lost_interval <= 0)
+ 		fraction = 0;
+ 	else
+@@ -2671,13 +3235,13 @@
+ 		rtp->rtcp->sendfur = 0;
+ 	}
+ 
+-	/*! \note Insert SDES here. Probably should make SDES text equal to mimetypes[code].type (not subtype 'cos 
+-	it can change mid call, and SDES can't) */
+-	rtcpheader[len/4]     = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | 2);
+-	rtcpheader[(len/4)+1] = htonl(rtp->ssrc);               /* Our SSRC */
+-	rtcpheader[(len/4)+2] = htonl(0x01 << 24);              /* Empty for the moment */
+-	len += 12;
+-	
++	start = &rtcpheader[len/4];
++	len +=8; /* SKip header for now */
++	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_CNAME);
++	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_END);
++	/* Now, add header when we know the actual length */
++	add_sdes_header(rtp, start, len);
++
+ 	res = sendto(rtp->rtcp->s, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&rtp->rtcp->them, sizeof(rtp->rtcp->them));
+ 
+ 	if (res < 0) {
+@@ -2718,9 +3282,9 @@
+ 		return 0;
+ 
+ 	if (rtp->txcount > rtp->rtcp->lastsrtxcount)
+-		res = ast_rtcp_write_sr(data);
++		res = ast_rtcp_write_sr(data, 0);
+ 	else
+-		res = ast_rtcp_write_rr(data);
++		res = ast_rtcp_write_rr(data, 0);
+ 	
+ 	return res;
+ }
+@@ -2852,10 +3416,8 @@
+ 			rtp->txcount++;
+ 			rtp->txoctetcount +=(res - hdrlen);
+ 			
+-			/* Do not schedule RR if RTCP isn't run */
+-			if (rtp->rtcp && rtp->rtcp->them.sin_addr.s_addr && rtp->rtcp->schedid < 1) {
+-			    rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
+-			}
++			/* Schedule RTCP report transmissions if possible */
++			ast_rtcp_schedule(rtp);
+ 		}
+ 				
+ 		if (rtp_debug_test_addr(&rtp->them))
+@@ -3234,6 +3796,7 @@
+ 
+ /*! \brief P2P RTP Callback */
+ #ifdef P2P_INTENSE
++
+ static int p2p_rtp_callback(int *id, int fd, short events, void *cbdata)
+ {
+ 	int res = 0, hdrlen = 12;
+@@ -3249,6 +3812,11 @@
+ 	if ((res = recvfrom(fd, rtp->rawdata + AST_FRIENDLY_OFFSET, sizeof(rtp->rawdata) - AST_FRIENDLY_OFFSET, 0, (struct sockaddr *)&sin, &len)) < 0)
+ 		return 1;
+ 
++	rtp->rxcount++;
++
++	/* Schedule RTCP report transmissions if possible */
++	ast_rtcp_schedule(rtp);
++
+ 	header = (unsigned int *)(rtp->rawdata + AST_FRIENDLY_OFFSET);
+ 
+ 	/* If NAT support is turned on, then see if we need to change their address */
+@@ -3283,12 +3851,19 @@
+ 	}
+ 
+ 	/* Steal the file descriptors from the channel and stash them away */
+-	fds[0] = chan->fds[0];
++	fds[0] = chan->fds[0];	/* RTP */
++	fds[1] = chan->fds[1];	/* RTCP */
+ 	chan->fds[0] = -1;
++	chan->fds[1] = -1;
+ 
+ 	/* Now, fire up callback mode */
+ 	iod[0] = ast_io_add(rtp->io, fds[0], p2p_rtp_callback, AST_IO_IN, rtp);
++	iod[1] = ast_io_add(rtp->ioc, fds[1], p2p_rtcp_callback, AST_IO_IN, rtp);
+ 
++	/* Kick the RTCP stream going by sending one empty stupid little packet */
++	ast_rtcp_write_empty(rtp, rtp->rtcp->s);
++	ast_log(LOG_DEBUG, "--- Enabled p2p callback for RTCP reads \n");
++
+ 	return 1;
+ }
+ #else
+@@ -3305,14 +3880,18 @@
+ 
+ 	/* Remove the callback from the IO context */
+ 	ast_io_remove(rtp->io, iod[0]);
++	ast_io_remove(rtp->iortcp, iod[1]);
+ 
+ 	/* Restore file descriptors */
+ 	chan->fds[0] = fds[0];
++	chan->fds[1] = fds[1];
+ 	ast_channel_unlock(chan);
+ 
+ 	/* Restore callback mode if previously used */
+-	if (ast_test_flag(rtp, FLAG_CALLBACK_MODE))
++	if (ast_test_flag(rtp, FLAG_CALLBACK_MODE)) {
+ 		rtp->ioid = ast_io_add(rtp->io, rtp->s, rtpread, AST_IO_IN, rtp);
++		rtp->ioidrtcp = ast_io_add(rtp->iortcp, fds[1], p2p_rtcp_callback, AST_IO_IN, rtp);
++	}
+ 
+ 	return 0;
+ }
+@@ -3351,6 +3930,10 @@
+ 	ast_channel_unlock(c0);
+ 	ast_channel_unlock(c1);
+ 
++	/* Kick the RTCP stream going by sending one empty stupid little packet */
++	ast_rtcp_write_empty(p0, p0->rtcp->s);
++	ast_rtcp_write_empty(p1, p1->rtcp->s);
++
+ 	/* Go into a loop forwarding frames until we don't need to anymore */
+ 	cs[0] = c0;
+ 	cs[1] = c1;
+@@ -4011,4 +4594,3 @@
+ 	ast_cli_register_multiple(cli_rtp, sizeof(cli_rtp) / sizeof(struct ast_cli_entry));
+ 	ast_rtp_reload();
+ }
+-
+Index: configs/sip.conf.sample
+===================================================================
+--- configs/sip.conf.sample	(.../branches/1.4)	(revision 382456)
++++ configs/sip.conf.sample	(.../team/oej/pinefrog-1.4)	(revision 382456)
+@@ -165,6 +165,9 @@
+                                  ; for peers and users as well
+ ;callevents=no                   ; generate manager events when sip ua 
+                                  ; performs events (e.g. hold)
++;rtcpevents=no			 ; Enable this to get QoS reports for each call in AMI
++;rtcpeventtimer=0		 ; How often during a call to send reports. 0 = only at end of call
++				 ; Other value means how many seconds between each report.
+ ;alwaysauthreject = yes          ; When an incoming INVITE or REGISTER is to be rejected,
+                                  ; for any reason, always reject with an identical response
+                                  ; equivalent to valid username and invalid password/hash

Egenskapsändringar för: patches/pinefrog-1.4.diff
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+Author Date Id Revision
\ No newline at end of property
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: channels/chan_sip.c
===================================================================
--- channels/chan_sip.c	(.../branches/1.8)	(revision 383011)
+++ channels/chan_sip.c	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -275,6 +275,7 @@
 #include "asterisk/xml.h"
 #include "sip/include/dialog.h"
 #include "sip/include/dialplan_functions.h"
+#include "sip/include/rtcp.h"
 
 
 /*** DOCUMENTATION
@@ -670,7 +671,6 @@
 	{ AST_REDIRECTING_REASON_CALL_FWD_DTE, "unknown"}
 };
 
-
 /*! \name DefaultSettings
 	Default setttings are used as a channel setting and as a default when
 	configuring devices
@@ -6164,6 +6164,22 @@
 	if (dumphistory)
 		sip_dump_history(p);
 
+	AST_SCHED_DEL(sched, p->rtcpeventid);
+
+ 	if (p->audioqual) {
+ 		/* We have a quality report to write to realtime before we leave this world. */
+ 		qos_write_realtime(p, p->audioqual);
+ 		free(p->audioqual);
+ 		p->audioqual = NULL;
+ 	}
+ 	if (p->videoqual) {
+ 		/* We have a quality report to write to realtime before we leave this world. */
+ 		qos_write_realtime(p, p->videoqual);
+ 		free(p->videoqual);
+ 		p->videoqual = NULL;
+ 	}
+
+
 	if (p->options) {
 		if (p->options->outboundproxy) {
 			ao2_ref(p->options->outboundproxy, -1);
@@ -6880,6 +6896,7 @@
 		ast_rtp_instance_update_source(p->rtp);
 		res = transmit_response_with_sdp(p, "200 OK", &p->initreq, XMIT_CRITICAL, FALSE, TRUE);
 		ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
+		start_rtcp_events(p, sched);
 	}
 	sip_pvt_unlock(p);
 	return res;
@@ -8105,8 +8122,10 @@
 		set_socket_transport(&p->socket, SIP_TRANSPORT_UDP);
 	}
 
+	p->sip_cfg = &sip_cfg;
 	p->socket.fd = -1;
 	p->method = intended_method;
+	p->rtcpeventid = -1;
 	p->initid = -1;
 	p->waitid = -1;
 	p->reinviteid = -1;
@@ -8168,6 +8187,14 @@
 		build_callid_pvt(p);
 	else
 		ast_string_field_set(p, callid, callid);
+
+	/* Set cnames for the RTCP SDES */
+	if (p->rtp) {
+		ast_rtp_instance_setcname(p->rtp, p->callid, strlen(p->callid));
+	}
+	if (p->vrtp) {
+		ast_rtp_instance_setcname(p->vrtp, p->callid, strlen(p->callid));
+	}
 	/* Assign default music on hold class */
 	ast_string_field_set(p, mohinterpret, default_mohinterpret);
 	ast_string_field_set(p, mohsuggest, default_mohsuggest);
@@ -9091,6 +9118,7 @@
 			      dialog->owner->uniqueid);
 	append_history(dialog, holdstate ? "Hold" : "Unhold", "%s", ast_str_buffer(req->data));
 	if (!holdstate) {	/* Put off remote hold */
+		ast_rtp_instance_hold(dialog->rtp, 0);	/* Turn off RTP hold */
 		ast_clear_flag(&dialog->flags[1], SIP_PAGE2_CALL_ONHOLD);	/* Clear both flags */
 		return;
 	}
@@ -9859,9 +9887,9 @@
 		ast_queue_control_data(p->owner, AST_CONTROL_HOLD,
 				       S_OR(p->mohsuggest, NULL),
 				       !ast_strlen_zero(p->mohsuggest) ? strlen(p->mohsuggest) + 1 : 0);
-		if (sendonly)
-			ast_rtp_instance_stop(p->rtp);
-		/* RTCP needs to go ahead, even if we're on hold!!! */
+		if (sendonly == 1 || sendonly == 2) {	/* sendonly (from the other side) or inactive */
+			ast_rtp_instance_hold(p->rtp, 1);
+		}
 		/* Activate a re-invite */
 		ast_queue_frame(p->owner, &ast_null_frame);
 		change_hold_state(p, req, TRUE, sendonly);
@@ -18010,8 +18038,10 @@
 	int x = 0, load_realtime;
 	format_t codec = 0;
 	int realtimepeers;
+	int realtimertpqos = FALSE;
 
 	realtimepeers = ast_check_realtime("sippeers");
+	realtimertpqos = ast_check_realtime("rtpcqr");
 
 	if (argc < 4)
 		return CLI_SHOWUSAGE;
@@ -18626,10 +18656,12 @@
 {
 	int realtimepeers;
 	int realtimeregs;
+	int realtimertpqos;
 	char codec_buf[SIPBUFSIZE];
 	const char *msg;	/* temporary msg pointer */
 	struct sip_auth_container *credentials;
 
+
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "sip show settings";
@@ -18646,6 +18678,7 @@
 
 	realtimepeers = ast_check_realtime("sippeers");
 	realtimeregs = ast_check_realtime("sipregs");
+	realtimertpqos = ast_check_realtime("rtpcqr");
 
 	ast_mutex_lock(&authl_lock);
 	credentials = authl;
@@ -18715,6 +18748,8 @@
 	}
 	ast_cli(a->fd, "  Record SIP history:     %s\n", AST_CLI_ONOFF(recordhistory));
 	ast_cli(a->fd, "  Call Events:            %s\n", AST_CLI_ONOFF(sip_cfg.callevents));
+	ast_cli(a->fd, "  RTCP Events:            %s\n", AST_CLI_ONOFF(sip_cfg.rtcpevents));
+	ast_cli(a->fd, "  RTCP Event timer:       %d\n", sip_cfg.rtcptimer);
 	ast_cli(a->fd, "  Auth. Failure Events:   %s\n", AST_CLI_ONOFF(global_authfailureevents));
 
 	ast_cli(a->fd, "  T.38 support:           %s\n", AST_CLI_YESNO(ast_test_flag(&global_flags[1], SIP_PAGE2_T38SUPPORT)));
@@ -18724,6 +18759,7 @@
 		ast_cli(a->fd, "  SIP realtime:           Disabled\n" );
 	else
 		ast_cli(a->fd, "  SIP realtime:           Enabled\n" );
+	ast_cli(a->fd, "  QoS realtime reports:   %s\n", realtimertpqos ? "Enabled" : "Disabled" );
 	ast_cli(a->fd, "  Qualify Freq :          %d ms\n", global_qualifyfreq);
 	ast_cli(a->fd, "  Q.850 Reason header:    %s\n", AST_CLI_YESNO(ast_test_flag(&global_flags[1], SIP_PAGE2_Q850_REASON)));
 	ast_cli(a->fd, "  Store SIP_CAUSE:        %s\n", AST_CLI_YESNO(global_store_sip_cause));
@@ -20665,6 +20701,7 @@
 		if (!req->ignore && p->invitestate != INV_CANCELLED && sip_cancel_destroy(p))
 			ast_log(LOG_WARNING, "Unable to cancel SIP destruction.  Expect bad things.\n");
 		check_pendings(p);
+		start_rtcp_events(p, sched);
 		break;
 
 	case 180:	/* 180 Ringing */
@@ -20929,6 +20966,7 @@
 		ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
 		xmitres = transmit_request(p, SIP_ACK, seqno, XMIT_UNRELIABLE, TRUE);
 		check_pendings(p);
+		start_rtcp_events(p, sched);
 		break;
 
 	case 407: /* Proxy authentication */
@@ -21578,16 +21616,21 @@
 	}
 }
 
-/*! \brief Immediately stop RTP, VRTP and UDPTL as applicable */
+/*! \brief Immediately stop RTP, VRTP, TEXT and UDPTL as applicable */
 static void stop_media_flows(struct sip_pvt *p)
 {
 	/* Immediately stop RTP, VRTP and UDPTL as applicable */
-	if (p->rtp)
+	if (p->rtp && !ast_rtp_instance_isactive(p->rtp)) {
+		sip_rtcp_report(p, p->rtp, SDP_AUDIO, TRUE);
 		ast_rtp_instance_stop(p->rtp);
-	if (p->vrtp)
+	}
+	if (p->vrtp && !ast_rtp_instance_isactive(p->vrtp)) {
+		sip_rtcp_report(p, p->vrtp, SDP_VIDEO, TRUE);
 		ast_rtp_instance_stop(p->vrtp);
-	if (p->trtp)
+	}
+	if (p->trtp && !ast_rtp_instance_isactive(p->trtp)) {
 		ast_rtp_instance_stop(p->trtp);
+	}
 	if (p->udptl)
 		ast_udptl_stop(p->udptl);
 }
@@ -24517,6 +24560,7 @@
 
 
 		if (p->rtp && (quality = ast_rtp_instance_get_quality(p->rtp, AST_RTP_INSTANCE_STAT_FIELD_QUALITY, quality_buf, sizeof(quality_buf)))) {
+			sip_rtcp_report(p, p->rtp, SDP_AUDIO, TRUE);
 			if (p->do_history) {
 				append_history(p, "RTCPaudio", "Quality:%s", quality);
 
@@ -24547,6 +24591,7 @@
 		}
 
 		if (p->vrtp && (quality = ast_rtp_instance_get_quality(p->vrtp, AST_RTP_INSTANCE_STAT_FIELD_QUALITY, quality_buf, sizeof(quality_buf)))) {
+			sip_rtcp_report(p, p->rtp, SDP_VIDEO, TRUE);
 			if (p->do_history) {
 				append_history(p, "RTCPvideo", "Quality:%s", quality);
 			}
@@ -28844,6 +28889,8 @@
 	/* Misc settings for the channel */
 	global_relaxdtmf = FALSE;
 	sip_cfg.callevents = DEFAULT_CALLEVENTS;
+	sip_cfg.rtcpevents = FALSE;
+	sip_cfg.rtcptimer = 0;	/* Only report at end of call (default) */
 	global_authfailureevents = FALSE;
 	global_t1 = DEFAULT_TIMER_T1;
 	global_timer_b = 64 * DEFAULT_TIMER_T1;
@@ -29266,6 +29313,13 @@
 				ast_log(LOG_WARNING, "Invalid qualifyfreq number '%s' at line %d of %s\n", v->value, v->lineno, config);
 				global_qualifyfreq = DEFAULT_QUALIFYFREQ;
 			}
+		} else if (!strcasecmp(v->name, "rtcpevents")) {
+			sip_cfg.rtcpevents = ast_true(v->value);
+		} else if (!strcasecmp(v->name, "rtcpeventtimer")) {
+			if (sscanf(v->value, "%30d", &sip_cfg.rtcptimer) != 1) {
+				ast_log(LOG_WARNING, "RTCP event timer needs to be value (seconds between reports) at line %d of sip.conf\n", v->lineno);
+				sip_cfg.rtcptimer = 0;
+			}
 		} else if (!strcasecmp(v->name, "callevents")) {
 			sip_cfg.callevents = ast_true(v->value);
 		} else if (!strcasecmp(v->name, "authfailureevents")) {
Index: channels/sip/include/sip.h
===================================================================
--- channels/sip/include/sip.h	(.../branches/1.8)	(revision 383011)
+++ channels/sip/include/sip.h	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -697,6 +697,8 @@
 	int compactheaders;         /*!< send compact sip headers */
 	int allow_external_domains; /*!< Accept calls to external SIP domains? */
 	int callevents;             /*!< Whether we send manager events or not */
+	int rtcpevents;             /*!< Whether we send manager RTCP events or not */
+	int rtcptimer;		    /*!< How often, during a call, to report RTCP stats */
 	int regextenonqualify;      /*!< Whether to add/remove regexten when qualifying peers */
 	int legacy_useroption_parsing; /*!< Whether to strip useroptions in URI via semicolons */
 	int matchexternaddrlocally;   /*!< Match externaddr/externhost setting against localnet setting */
@@ -1081,6 +1083,7 @@
 	int waitid;                         /*!< Wait ID for scheduler after 491 or other delays */
 	int reinviteid;                     /*!< Reinvite in case of provisional, but no final response */
 	int autokillid;                     /*!< Auto-kill ID (scheduler) */
+	int rtcpeventid;                        /*!< Scheduler ID for RTCP Events */
 	int t38id;                          /*!< T.38 Response ID */
 	struct sip_refer *refer;            /*!< REFER: SIP transfer data structure */
 	enum subscriptiontype subscribed;   /*!< SUBSCRIBE: Is this dialog a subscription?  */
@@ -1136,6 +1139,12 @@
 	 * The large-scale changes would be a good idea for implementing during an SDP rewrite.
 	 */
 	struct offered_media offered_media[OFFERED_MEDIA_COUNT];
+	//struct ast_rtp_quality *audioqual;              /*!< Audio: The latest quality report, for realtime storage */
+	//struct ast_rtp_quality *videoqual;              /*!< Video: The latest quality report, for realtime storage */
+	struct ast_rtp_instance_stats *audioqual;              /*!< Audio: The latest quality report, for realtime storage */
+	struct ast_rtp_instance_stats *videoqual;              /*!< Video: The latest quality report, for realtime storage */
+	struct sip_settings *sip_cfg;			/*! Which sip_cfg is associated with this dialog */
+
 	struct ast_cc_config_params *cc_params;
 	struct sip_epa_entry *epa_entry;
 	int fromdomainport;                 /*!< Domain port to show in from field */
Index: channels/sip/include/rtcp.h
===================================================================
--- channels/sip/include/rtcp.h	(.../branches/1.8)	(revision 0)
+++ channels/sip/include/rtcp.h	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -0,0 +1,50 @@
+/*
+ * Asterisk -- An open source telephony toolkit.
+ *
+ * Copyright (C) 2013 Olle E. Johansson, Edvina AB
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file rtcp.h
+ *
+ * \brief RTCP additional functions
+ *
+ * \author Olle E. Johansson <oej@edvina.net>
+ */
+
+#include "asterisk.h"
+
+#include "asterisk/utils.h"
+#include "asterisk/rtp_engine.h"
+#include "sip.h"
+
+#ifndef _SIP_RTCP_H
+#define _SIP_RTCP_H
+
+/*! \brief Set various data items in the RTP structure, like channel identifier.
+ */
+void sip_rtcp_set_data(struct sip_pvt *dialog, struct ast_rtp_instance *instance, enum media_type type);
+
+int send_rtcp_events(const void *data);
+void start_rtcp_events(struct sip_pvt *dialog, struct sched_context *sched);
+/*
+# For 1.4:
+# static void sip_rtcp_report(struct sip_pvt *p, struct ast_rtp *rtp, enum media_type type, int reporttype);
+*/
+
+void sip_rtcp_report(struct sip_pvt *dialog, struct ast_rtp_instance *instance, enum media_type type, int reporttype);
+//void qos_write_realtime(struct sip_pvt *dialog, struct ast_rtp_quality *qual);
+void qos_write_realtime(struct sip_pvt *dialog, struct ast_rtp_instance_stats *qual);
+
+
+
+#endif /* _SIP_RTCP_H */

Egenskapsändringar för: channels/sip/include/rtcp.h
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+Author Date Id Revision
\ No newline at end of property
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: channels/sip/rtcp.c
===================================================================
--- channels/sip/rtcp.c	(.../branches/1.8)	(revision 0)
+++ channels/sip/rtcp.c	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -0,0 +1,384 @@
+/*
+* Asterisk -- An open source telephony toolkit.
+*
+* Copyright (C) 2013 Olle E. Johansson, Edvina AB
+*
+* See http://www.asterisk.org for more information about
+* the Asterisk project. Please do not directly contact
+* any of the maintainers of this project for assistance;
+* the project provides a web site, mailing lists and IRC
+* channels for your use.
+*
+* This program is free software, distributed under the terms of
+* the GNU General Public License Version 2. See the LICENSE file
+* at the top of the source tree.
+*/
+
+/*! \file rtcp.c
+*
+* \brief RTCP additional functions
+*
+* \author Olle E. Johansson <oej@edvina.net>
+*/
+
+/*** MODULEINFO
+	<support_level>core</support_level>
+***/
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
+#include "asterisk/utils.h"
+#include "asterisk/manager.h"
+#include "asterisk/logger.h"
+#include "asterisk/translate.h"
+#include "asterisk/rtp_engine.h"
+#include "include/sip.h"
+#include "include/rtcp.h"
+
+/*! \brief Set various data items in the RTP structure, like channel identifier.
+ */
+void sip_rtcp_set_data(struct sip_pvt *dialog, struct ast_rtp_instance *instance, enum media_type type)
+{
+
+	if (dialog && dialog->owner) {
+ 		int readtrans = FALSE, writetrans = FALSE;
+		struct ast_channel *bridgepeer = ast_bridged_channel(dialog->owner);
+
+		if (bridgepeer) {
+			/* Store the bridged peer data while we have it */
+			ast_rtp_instance_set_bridged_chan(instance, dialog->owner->name, dialog->owner->uniqueid, S_OR(bridgepeer->name,""), S_OR(bridgepeer->uniqueid,""));
+			ast_debug(1, "---- Setting bridged peer name to %s\n", bridgepeer->name);
+		} else {
+			ast_rtp_instance_set_bridged_chan(instance, dialog->owner->name, dialog->owner->uniqueid, NULL, NULL);
+		}
+		ast_debug(1, "---- Setting channel name to %s\n", dialog->owner->name);
+
+ 		/* Try to find out if there's active transcoding */
+		/* Currently, the only media stream that has translation is the audio stream. At some point
+		   we might have transcoding for other types of media. */
+		if (type == SDP_AUDIO) {
+			struct ast_channel *chan = dialog->owner;
+			const char *rtname = NULL, *wtname = NULL;
+			/* if we have a translator, the bridge delay is increased, which affects the QoS of the call.  */
+ 			readtrans = (chan->readtrans != NULL);
+ 			writetrans = (chan->writetrans != NULL);
+			if (readtrans) {
+				rtname = chan->readtrans->t->name;
+			}
+			if (writetrans) {
+				wtname = chan->writetrans->t->name;
+			}
+			if (readtrans || writetrans) {
+				ast_rtp_instance_set_translator(instance, rtname, readtrans ? chan->readtrans->t->cost : (const int) 0,
+					wtname, writetrans ? chan->writetrans->t->cost : (const int) 0);
+			}
+		
+			if (option_debug > 1) {
+ 				if (readtrans && dialog->owner->readtrans->t) {
+ 					ast_debug(1, "--- Audio Read translator: %s Cost %d\n", dialog->owner->readtrans->t->name, dialog->owner->readtrans->t->cost);
+ 				}
+ 				if (writetrans && dialog->owner->writetrans->t) {
+ 					ast_debug(1, "--- Audio Write translator: %s Cost %d\n", dialog->owner->writetrans->t->name, dialog->owner->writetrans->t->cost);
+ 				}
+			}
+		}
+
+	} else {
+ 		ast_debug(1, "######## Not setting rtcp media data. Dialog %s Dialog owner %s \n", dialog ? "set" : "unset",  dialog->owner ? "set" : "unset");
+	}
+}
+
+/*! \brief send manager report of RTCP 
+	reporttype = 0  means report during call (if configured)
+	reporttype = 1  means endof-call (hangup) report
+	reporttype = 10  means report at end of call leg (like transfer)
+*/
+void sip_rtcp_report(struct sip_pvt *dialog, struct ast_rtp_instance *instance, enum media_type media, int reporttype)
+{
+	struct ast_rtp_instance_stats qual;
+	//char *rtpqstring = NULL;
+	//int qosrealtime = ast_check_realtime("rtpcqr");
+	unsigned int duration;	/* Duration in secs */
+	memset(&qual, 0, sizeof(qual));
+	
+	sip_rtcp_set_data(dialog, instance, media);
+
+	if (ast_rtp_instance_get_stats(instance, &qual, AST_RTP_INSTANCE_STAT_ALL)) {
+ 		ast_debug(1, "######## Did not get any statistics... bad, bad, RTP instance\n");
+		/* Houston, we got a problem */
+		return;
+	}
+	
+	if (dialog->sip_cfg->rtcpevents) {
+		/* 
+		   If numberofreports == 0 we have no incoming RTCP active, thus we can't
+		   get any reliable data to handle packet loss or any RTT timing.
+		*/
+
+		duration = (unsigned int)(ast_tvdiff_ms(ast_tvnow(), qual.start) / 1000);
+		manager_event(EVENT_FLAG_CALL, "RTPQuality", 
+			"Channel: %s\r\n"			/* AST_CHANNEL for this call */
+			"Uniqueid: %s\r\n"			/* AST_CHANNEL for this call */
+			"BridgedChannel: %s\r\n"
+			"BridgedUniqueid: %s\r\n"
+			"RTPreporttype: %s\r\n"
+			"RTPrtcpstatus: %s\r\n"
+			"Duration: %u\r\n"		/* used in cdr_manager */
+			"PvtCallid: %s\r\n"		/* ??? Generic PVT identifier */
+			"RTPipaddress: %s\r\n"
+			"RTPmedia: %s\r\n"		/* Audio, video, text */
+			"RTPsendformat: %s\r\n"
+			"RTPrecvformat: %s\r\n"
+			"RTPlocalssrc: %u\r\n"
+			"RTPremotessrc: %u\r\n"
+			"RTPrtt: %f\r\n"
+			"RTPrttMax: %f\r\n"
+			"RTPrttMin: %f\r\n"
+			"RTPLocalJitter: %f\r\n"
+			"RTPRemoteJitter: %f\r\n" 
+			"RTPInPacketLoss: %d\r\n" 
+			"RTPInLocalPlPercent: %5.2f\r\n"
+			"RTPOutPacketLoss: %d\r\n"
+			"RTPOutPlPercent: %5.2f\r\n"
+			"TranslateRead: %s\r\n"
+			"TranslateReadCost: %d\r\n"
+			"TranslateWrite: %s\r\n"
+			"TranslateWriteCost: %d\r\n"
+			"\r\n", 
+			dialog->owner ? dialog->owner->name : "",
+			dialog->owner ? dialog->owner->uniqueid : "",
+			qual.bridgedchannel[0] ? qual.bridgedchannel : "" ,
+			qual.bridgeduniqueid[0] ? qual.bridgeduniqueid : "",
+			reporttype == 1 ? "Final" : "Update",
+			qual.numberofreports == 0 ? "Inactive" : "Active",
+			duration,
+			dialog->callid, 
+			ast_inet_ntoa(qual.them.sin_addr), 	
+			media == SDP_AUDIO ? "audio" : (media == SDP_VIDEO ? "video" : "fax") ,
+			ast_getformatname(qual.lasttxformat),
+			ast_getformatname(qual.lastrxformat),
+			qual.local_ssrc, 
+			qual.remote_ssrc,
+			qual.rtt,
+			qual.maxrtt,
+			qual.minrtt,
+			qual.rxjitter,
+			qual.txjitter,
+			qual.rxploss,
+			/* The local counter of lost packets in inbound stream divided with received packets plus lost packets */
+			(qual.remote_txcount + qual.rxploss) > 0 ? (double) qual.rxploss / (qual.remote_txcount + qual.rxploss) * 100 : 0,
+			qual.txploss,
+			/* The remote counter of lost packets (if we got the reports)
+			   divided with our counter of sent packets
+			 */
+			(qual.rxcount + qual.txploss) > 0 ? (double) qual.txploss / qual.rxcount  * 100 : 0,
+			qual.readtranslator, qual.readcost,
+			qual.writetranslator, qual.writecost
+		);
+	}
+
+	/* CDR records are not reliable when it comes to near-death-of-channel events, so we need to store the RTCP
+	   report in realtime when we have it.
+	   Tests have proven that storing to realtime from the call thread is NOT a good thing. Therefore, we just save
+	   the quality report structure in the PVT and let the function that kills the pvt store the stuff in the
+	   monitor thread instead.
+	 */
+	if (reporttype == 1) {
+		ast_log(LOG_DEBUG, "---- Activation qual structure in dialog \n");
+		qual.end = ast_tvnow();
+ 		qual.mediatype = media;
+		if (media == SDP_AUDIO) {  /* Audio */
+			dialog->audioqual = ast_calloc(1, sizeof(struct ast_rtp_instance_stats));
+			(* dialog->audioqual) = qual;
+		} else if (media == SDP_VIDEO) {  /* Video */
+			dialog->videoqual = ast_calloc(1,sizeof(struct ast_rtp_instance_stats));
+			(* dialog->videoqual) = qual;
+		}
+	}
+}
+
+/*! \brief Write quality report to realtime storage */
+void qos_write_realtime(struct sip_pvt *dialog, struct ast_rtp_instance_stats *qual)
+{
+	unsigned int duration;	/* Duration in secs */
+	char buf_duration[10], buf_lssrc[30], buf_rssrc[30];
+	char buf_rtt[10], buf_rttmin[10], buf_rttmax[10];
+	char localjitter[10], remotejitter[10];
+	char buf_readcost[5], buf_writecost[5];
+	char buf_mediatype[10];
+	char buf_remoteip[25];
+	char buf_inpacketloss[25], buf_outpacketloss[25];
+	char buf_outpackets[25], buf_inpackets[25];
+	int qosrealtime = ast_check_realtime("rtpcqr");
+
+	ast_log(LOG_DEBUG, "************* QOS END REPORTS: The final countdown!!!!! Yeah. \n");
+
+	if (!qual) {
+		ast_log(LOG_ERROR, "No CQR data provided \n");
+		return;
+	}
+
+	/* Since the CDR is already gone, we need to calculate our own duration.
+	   The CDR duration is the definitive resource for billing, this is
+	   the RTP stream duration which may include early media (ringing and
+	   provider messages). Only useful for measurements.
+	 */
+	if (!ast_tvzero(qual->end) && !ast_tvzero(qual->start)) {
+		duration = (unsigned int)(ast_tvdiff_ms(qual->end, qual->start) / 1000);
+	} else {
+		ast_log(LOG_DEBUG, "**** WTF? No duration? What type of call is THAT? \n");
+		duration = 0;
+	}
+
+	/* Realtime is based on strings, so let's make strings */
+	sprintf(localjitter, "%f", qual->rxjitter);
+	sprintf(remotejitter, "%f", qual->txjitter);
+	sprintf(buf_lssrc, "%u", qual->local_ssrc);
+	sprintf(buf_rssrc, "%u", qual->remote_ssrc);
+	sprintf(buf_rtt, "%.0f", qual->rtt);
+	sprintf(buf_rttmax, "%.0f", qual->maxrtt);
+	sprintf(buf_rttmin, "%.0f", qual->minrtt);
+	sprintf(buf_duration, "%u", duration);
+	sprintf(buf_readcost, "%d", qual->readcost);
+	sprintf(buf_writecost, "%d", qual->writecost);
+	sprintf(buf_mediatype,"%s", qual->mediatype == SDP_AUDIO ? "audio" : (qual->mediatype == SDP_VIDEO ? "video" : "fax") );
+	sprintf(buf_remoteip,"%s", ast_inet_ntoa(qual->them.sin_addr));
+	sprintf(buf_inpacketloss, "%d", qual->rxploss);
+	sprintf(buf_outpacketloss, "%d", qual->txploss);
+	sprintf(buf_inpackets, "%d", qual->rxcount);		/* Silly value. Need to check this */
+	sprintf(buf_outpackets, "%d", qual->txcount);
+	//sprintf(buf_inpackets, "%d", qual->remote_count);	/* Do check again */
+	//sprintf(buf_outpackets, "%d", qual->local_count);
+
+	ast_log(LOG_DEBUG, "************* QOS END REPORTS: Probing new logging channel LOG_CQR!!!!! Yeah. \n");
+	ast_log(LOG_CQR, "CQR Channel: %s Uid %s Bch %s Buid %s Pvt %s Media %s Lssrc %s Rssrc %s Rip %s Rtt %s:%s:%s Ljitter %s Rjitter %s Rtcpstatus %s Dur %s Pout %s Plossout %s Pin %s Plossin %s\n",
+		qual->channel[0] ? qual->channel : "",
+		qual->uniqueid[0] ? qual->uniqueid : "",
+		qual->bridgedchannel[0] ? qual->bridgedchannel : "" ,
+		qual->bridgeduniqueid[0] ? qual->bridgeduniqueid : "",
+		dialog->callid,
+		buf_mediatype,
+		buf_lssrc,
+		buf_rssrc,
+		buf_remoteip,
+		buf_rtt, buf_rttmax, buf_rttmin,
+		localjitter,
+		remotejitter,
+		qual->numberofreports == 0 ? "Inactive" : "Active",
+		buf_duration,
+		buf_outpackets,
+		buf_outpacketloss,
+		buf_inpackets,
+		buf_inpacketloss);
+
+	if (!qosrealtime) {
+		return;
+	}
+/* Example database schema for MySQL:
+CREATE TABLE `astcqr` (
+  `channel` varchar(50) NOT NULL,
+  `uniqueid` varchar(35) NOT NULL,
+  `bridgedchannel` varchar(50) NOT NULL,
+  `bridgeduniqueid` varchar(35) NOT NULL,
+  `pvtcallid` varchar(80) NOT NULL,
+  `rtpmedia` varchar(50) NOT NULL,
+  `localssrc` varchar(50) NOT NULL,
+  `remotessrc` varchar(50) NOT NULL,
+  `rtt` varchar(10) NOT NULL,
+  `localjitter` varchar(10) NOT NULL,
+  `remotejitter` varchar(10) NOT NULL,
+  `sendformat` varchar(10) NOT NULL,
+  `receiveformat` varchar(10) NOT NULL,
+  `rtcpstatus` varchar(10) NOT NULL,
+  `duration` varchar(10) NOT NULL,
+  `packetsent` varchar(30) NOT NULL,
+  `packetreceived` varchar(30) NOT NULL,
+  `packetlossin` varchar(30) NOT NULL,
+  `packetlossout` varchar(30) NOT NULL,
+  `rttmax` varchar(12) NOT NULL,
+  `rttmin` varchar(12) NOT NULL,
+  `writetranslator` varchar(15) NOT NULL,
+  `readtranslator` varchar(15) NOT NULL,
+  `writecost` varchar(10) NOT NULL,
+  `readcost` varchar(10) NOT NULL,
+  `remoteip` varchar(25) NOT NULL,
+  KEY `ChannelUnique` (`channel`,`uniqueid`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1 COMMENT='FOr pinefrog stats'
+*/
+
+	ast_store_realtime("rtpcqr", 
+		"channel", qual->channel[0] ? qual->channel : "--no channel--",
+		"uniqueid", qual->uniqueid[0] ? qual->uniqueid : "--no uniqueid --",
+		"bridgedchannel", qual->bridgedchannel[0] ? qual->bridgedchannel : "" ,
+		"bridgeduniqueid", qual->bridgeduniqueid[0] ? qual->bridgeduniqueid : "",
+		"pvtcallid", dialog->callid, 
+		"rtpmedia", buf_mediatype, 
+		"localssrc", buf_lssrc, 
+		"remotessrc", buf_rssrc,
+		"remoteip", buf_remoteip,
+		"rtt", buf_rtt, 
+		"rttmax", buf_rttmax, 
+		"rttmin", buf_rttmin, 
+		"localjitter", localjitter, 
+		"remotejitter", remotejitter, 
+		"sendformat", ast_getformatname(qual->lasttxformat),
+		"receiveformat", ast_getformatname(qual->lastrxformat),
+		"rtcpstatus", qual->numberofreports == 0 ? "Inactive" : "Active",
+		"duration", buf_duration,
+		"writetranslator", qual->writetranslator[0] ? qual->writetranslator : "",
+		"writecost", buf_writecost,
+		"readtranslator", qual->readtranslator[0] ? qual->readtranslator : "",
+		"readcost", buf_readcost,
+		"packetlossin", buf_inpacketloss,
+		"packetlossout", buf_outpacketloss,
+		"packetsent", buf_outpackets,
+		"packetreceived", buf_inpackets,
+		NULL);
+}
+
+/*! \brief Send RTCP manager events */
+int send_rtcp_events(const void *data)
+{
+	struct sip_pvt *dialog = (struct sip_pvt *) data;
+	ast_log(LOG_DEBUG, "***** SENDING RTCP EVENT \n");
+
+	if (dialog->rtp && !ast_rtp_instance_isactive(dialog->rtp)) {
+		ast_debug(1, "          ***** Activating RTCP report \n");
+		sip_rtcp_report(dialog, dialog->rtp, SDP_AUDIO, FALSE);
+	} else {
+		ast_debug(1, "          ***** NOT Activating RTCP report \n");
+	}
+	if (dialog->vrtp && !ast_rtp_instance_isactive(dialog->vrtp)) {
+		sip_rtcp_report(dialog, dialog->vrtp, SDP_VIDEO, FALSE);
+	}
+	return (dialog->sip_cfg ? dialog->sip_cfg->rtcptimer : 0);
+}
+
+/*! \brief Activate RTCP events at start of call */
+void start_rtcp_events(struct sip_pvt *dialog, struct sched_context *sched)
+{
+	ast_debug(2, "***** STARTING SENDING RTCP EVENT \n");
+	/* Check if it's already active */
+
+	if (dialog->rtp && !ast_rtp_instance_isactive(dialog->rtp)) {
+		sip_rtcp_set_data(dialog, dialog->rtp, SDP_AUDIO);
+	}
+	if (dialog->vrtp && !ast_rtp_instance_isactive(dialog->vrtp)) {
+		sip_rtcp_set_data(dialog, dialog->vrtp, SDP_VIDEO);
+	}
+
+	if (!dialog->sip_cfg->rtcpevents || !dialog->sip_cfg->rtcptimer) {
+		ast_debug(2, "***** NOT SENDING RTCP EVENTS \n");
+		return;
+	}
+
+	if (dialog->rtcpeventid != -1) {
+		return;
+	}
+
+
+	/*! \brief Schedule events */
+	dialog->rtcpeventid = ast_sched_add(sched, dialog->sip_cfg->rtcptimer * 1000, send_rtcp_events, dialog);
+}

Egenskapsändringar för: channels/sip/rtcp.c
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+Author Date Id Revision
\ No newline at end of property
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: channels/sip/dialplan_functions.c
===================================================================
--- channels/sip/dialplan_functions.c	(.../branches/1.8)	(revision 383011)
+++ channels/sip/dialplan_functions.c	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -140,7 +140,9 @@
 
 		snprintf(buf, buflen, "%s", ast_sockaddr_stringify(&sa));
 	} else if (!strcasecmp(args.param, "rtpqos")) {
+/* OEJ - Check this part, different from 1.4 */
 		struct ast_rtp_instance *rtp = NULL;
+		struct ast_rtp_quality *qos;
 
 		if (ast_strlen_zero(args.type)) {
 			args.type = "audio";
@@ -162,6 +164,11 @@
 			if (!ast_rtp_instance_get_quality(rtp, AST_RTP_INSTANCE_STAT_FIELD_QUALITY, quality_buf, sizeof(quality_buf))) {
 				return -1;
 			}
+#ifdef OEJ
+			if (!ast_rtp_instance_get_qualdata(rtp, ???, &qos)) {
+				this_needs_some_love;
+			}
+#endif
 
 			ast_copy_string(buf, quality_buf, buflen);
 			return res;
Index: CREDITS
===================================================================
--- CREDITS	(.../branches/1.8)	(revision 383011)
+++ CREDITS	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -23,6 +23,9 @@
 Omnitor AB, Gunnar Hellström, for funding work with videocaps, T.140 RED,
 originate with video/text and many more contributions.
 
+Nordicom Norge AS, Kristiansand, Norway, for funding work with RTCP support
+and Call Quality Records.
+
 === WISHLIST CONTRIBUTERS ===
 Jeremy McNamara - SpeeX support
 Nick Seraphin - RDNIS support
@@ -116,6 +119,7 @@
 	SIP presence support, SIP call state updates (dialog-info), 
 	QUEUE_EXISTS function, device state provider architecture,
 	multiparking (together with mvanbaak), meetme and parking device states,
+        RTCP improvements, Call Quality Records,
 	MiniVM - the small voicemail system, many documentation
 	updates/corrections, and many bug fixes.
 	oej(AT)edvina.net, http://edvina.net
@@ -217,7 +221,8 @@
 Viagenie, Canada - IPv6 support in socket layers and SIP implementation
 	Developers: Marc Blanchet, Simon Perreault and Jean-Philippe Dionne
 
-ClearIT AB, Sweden - res_mutestream, queue_exists and various other patches (developed by oej)
+ClearIT AB, Sweden - res_mutestream, queue_exists, RTCP improvements and various 
+        other patches (developed by oej)
 
 Despegar.com, Argentina - AstData API implementation, also sponsored by Google as part of the
 	gsoc/2009 program (developed by Eliel)
Index: README.pinefrog-rtcp
===================================================================
--- README.pinefrog-rtcp	(.../branches/1.8)	(revision 0)
+++ README.pinefrog-rtcp	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -0,0 +1,168 @@
+Olle E. Johansson
+oej@edvina.net
+
+2013-03-05
+
+
+
+
+
+
+Pinefrog - RTCP cleanup and additions
+-------------------------------------
+
+This branch is aimed at porting the code in pinefrog-1.4, which is now a few years old,
+to Asterisk 1.8 and hopefully (with some help) to Asterisk trunk to be integrated.
+The 1.4 code has been running in production for years in universities, call centers
+and service providers.
+
+The 1.8 port of Pinefrog is supported by Nordicom, Norway (http://www.nordicom.no). 
+The 1.4 work was sponsored by several companies, including ClearIT AB, Sweden.
+
+Status of 1.8 port
+------------------
+2013-03-05	Started
+
+Todo for 1.8
+------------
+- Add support of outbound and inbound SDES. The SDES includes a stream identifier, CNAME. 
+- Add support of outbound SDES end and goodbye
+- Add manager events at end-of call
+- Add realtime storage of RTCP reports
+- Add time manager events (configured in sip.conf)
+- Add more information to RTCP debug
+- Add more data aggregation to ast_rtcp structure (from svn trunk really)
+- Add RTCP for p2p RTP bridges. Needs to be tested and validated.
+
+Background
+==========
+RTCP, as defined in RFC 3550, is a protocol that co-exists with RTP, the protocol used
+for realtime multimedia in VoIP. RTCP gives the endpoints a tool to exchange data about
+the media streams exchanged. As a result, both ends can get informaiton about the
+latency for data sent in both directions, packet loss and jitter for each media stream.
+
+A VoIP call is at least two media streams and they can have different properties in
+regards of quality. A router or switch in the middle could have a lot of outbound traffic,
+causing delays and possible packet loss. This might not affect inbound traffic.
+
+In Asterisk, the RTCP handler is part of the RTP module. The RTP module produces RTCP
+report that can be added to channel variables, cdr logs or sent through AMI.
+
+In 1.4, the data used is mostly based on the latest report, it's not aggregated. This
+is fixed in trunk.
+
+In both implementations (and the 1.6 releases in between) the RTCP support is not
+very complete.
+
+- It doesn't handle RTCP SDES packets
+- It doesn't send RTCP END packets at end of session
+- It doesn't handle receiving END packets
+- It doesn't handle re-invites in a good way.
+- It seems to mix sender and receiver reports, thus mixing data from two streams 
+    - when does this happen, if at all?
+
+RTCP and NAT
+------------
+I suspect that RTCP doesn't traverse NAT very well in our implementation. For RTP,
+we start with sending media to probe NAT. I've added emtpy RTCP RR+SDES CNAME packets
+to start probing a NAT (if Asterisk is behind a NAT). I am afraid that very few devices
+do that early on.
+The idea is (like RTP)
+ - Send a few RTCP packets in the start of the session.
+ - The receiver can then apply symmetric RTCP and start sending to the NAT outside port
+   that we're sending from and we'll get their packets.
+
+Todo
+----
+- When CNAME changes, we have a different stream and need to restart the stats.
+  Should we add ability to produce multiple RTCP reports for one "call" and aggregate them?
+  The different parts might have different properties.
+- Document realtime storage format. Add missing fields.
+- BUG: RTCP is halted during hold. It should not stop.
+- During HOLD, send RTCP SR reports without report block, only the header and no chunks 
+
+Done in 1.4
+-----------
+- Added support of outbound and inbound SDES. The SDES includes a stream identifier, CNAME. 
+- Added support of outbound SDES end and goodbye
+- Added manager events at end-of call
+- Added realtime storage of RTCP reports
+- Added time manager events (configured in sip.conf)
+- Added more information to RTCP debug
+- Added more data aggregation to ast_rtcp structure (from svn trunk really)
+- Added RTCP for p2p RTP bridges. Needs to be tested and validated.
+
+Open Issues
+-----------
+The final manager report lacks (in the case of the second channel) the bridged channel. We could save that data.  This will affect realtime as well, so we need to copy the channel name to a stored variable while it exists.
+
+Do we have a counter of consecutive lost packets? How do we measure lost packets on inbound
+stream? Gaps in seq numbers or just the sender reports from the other end compared with received 
+no of packets?
+
+
+Ideas and thoughts for the future
+---------------------------------
+- Asterisk propagates jitter and packet loss over a bridge (especially the p2p RTP bridge).
+  If the call is transfered on the OTHER side of the bridge, we have a new call with new
+  properties. Maybe events like this should generate a new SDES and reset RTCP?
+  Part A of the call can have very different properties than part B. If I have a call with
+  someone internally, that then transfers me to a call with someone on the Internet, the
+  call quality (jitter etc) will change dramatically. This will require some sort of CONTROL
+  packet over the bridge, informing about changes on the other side of the bridge (masq).
+- Can we have some sort of ring buffer for the latest RTCP reports for a device (peer) 
+  and use that to determine the status of the connection to the peer?
+- Can we use the RTCP APP packet for relaying events in joined bridges, like meetme?
+- What should we use as CNAME? Currently SIP call ID.
+- Separate on the IPs of different media servers. IE we can have one SIP peer with
+  multiple media IPs with different properties
+
+Scenarios to test
+------------------
+- normal bridged call
+- RTP p2p bridged call
+- Nat traversal - Asterisk outside of NAT and inside (as client to external service)
+- Call hold
+- Call with music-on-hold
+
+Database structure
+-------------------
+Example database schema for MySQL:
+
+CREATE TABLE `astcqr` (
+  `channel` varchar(50) NOT NULL,
+  `uniqueid` varchar(35) NOT NULL,
+  `bridgedchannel` varchar(50) NOT NULL,
+  `bridgeduniqueid` varchar(35) NOT NULL,
+  `pvtcallid` varchar(80) NOT NULL,
+  `rtpmedia` varchar(50) NOT NULL,
+  `localssrc` varchar(50) NOT NULL,
+  `remotessrc` varchar(50) NOT NULL,
+  `rtt` varchar(10) NOT NULL,
+  `localjitter` varchar(10) NOT NULL,
+  `remotejitter` varchar(10) NOT NULL,
+  `sendformat` varchar(10) NOT NULL,
+  `receiveformat` varchar(10) NOT NULL,
+  `rtcpstatus` varchar(10) NOT NULL,
+  `duration` varchar(10) NOT NULL,
+  `packetsent` varchar(30) NOT NULL,
+  `packetreceived` varchar(30) NOT NULL,
+  `packetlossin` varchar(30) NOT NULL,
+  `packetlossout` varchar(30) NOT NULL,
+  `rttmax` varchar(12) NOT NULL,
+  `rttmin` varchar(12) NOT NULL,
+  `writetranslator` varchar(15) NOT NULL,
+  `readtranslator` varchar(15) NOT NULL,
+  `writecost` varchar(10) NOT NULL,
+  `readcost` varchar(10) NOT NULL,
+  `remoteip` varchar(25) NOT NULL,
+  KEY `ChannelUnique` (`channel`,`uniqueid`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1 COMMENT='FOr pinefrog stats'
+
+Realtime configuration
+========================
+In extconfig.conf add
+
+rtpcqr => mysql,asterisk,astqos
+
+When you run "sip show settings"

Egenskapsändringar för: README.pinefrog-rtcp
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+Author Date Id Revision
\ No newline at end of property
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: include/asterisk/rtp_engine.h
===================================================================
--- include/asterisk/rtp_engine.h	(.../branches/1.8)	(revision 383011)
+++ include/asterisk/rtp_engine.h	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -74,6 +74,7 @@
 #include "asterisk/netsock2.h"
 #include "asterisk/sched.h"
 #include "asterisk/res_srtp.h"
+#include "asterisk/channel.h"
 
 /* Maximum number of payloads supported */
 #define AST_RTP_MAX_PT 256
@@ -211,6 +212,14 @@
 	AST_RTP_INSTANCE_STAT_LOCAL_SSRC,
 	/*! Retrieve remote SSRC */
 	AST_RTP_INSTANCE_STAT_REMOTE_SSRC,
+	/*! Retrieve local CNAME */
+	AST_RTP_INSTANCE_STAT_LOCAL_CNAME,
+	/*! Retrieve remote SDES */
+	AST_RTP_INSTANCE_STAT_REMOTE_CNAME,
+	/*! Retrieve start time */
+	AST_RTP_INSTANCE_STAT_START,
+	/*! Retrieve IP Address */
+	AST_RTP_INSTANCE_STAT_IP,
 };
 
 /* Codes for RTP-specific data - not defined by our AST_FORMAT codes */
@@ -237,10 +246,12 @@
 	unsigned int txcount;
 	/*! Number of packets received */
 	unsigned int rxcount;
+
 	/*! Jitter on transmitted packets */
 	double txjitter;
 	/*! Jitter on received packets */
 	double rxjitter;
+
 	/*! Maximum jitter on remote side */
 	double remote_maxjitter;
 	/*! Minimum jitter on remote side */
@@ -291,6 +302,32 @@
 	unsigned int local_ssrc;
 	/*! Their SSRC */
 	unsigned int remote_ssrc;
+
+	/* --- Pinefrog additions */
+	/*! Remote: Number of packets transmitted */
+	unsigned int remote_txcount;
+	/*! Remote: Number of packets received */
+	unsigned int remote_rxcount;
+	char channel[AST_MAX_EXTENSION];	/*!< Name of channel */
+	char uniqueid[AST_MAX_EXTENSION];	/*!< uniqueid of channel */
+	char bridgedchannel[AST_MAX_EXTENSION];	/*!< Name of bridged channel */
+	char bridgeduniqueid[AST_MAX_EXTENSION];	/*!< uniqueid of bridged channel */
+	unsigned int numberofreports;	  /*!< Number of reports received from remote end */
+	int lasttxformat;		  /*!< Last used codec on transmitted stream */
+	int lastrxformat;		  /*!< Last used codec on received stream */
+	struct sockaddr_in them;	  /*!< The IP address used for media by remote end */
+	struct sockaddr_in us;	  	  /*!< The IP address used for media by our end */
+	char ourcname[255];		/*!< Our SDES RTP session name (CNAME) */
+	size_t ourcnamelength;		/*!< Length of CNAME (utf8) */
+	char theircname[255];		/*!< Their SDES RTP session name (CNAME) */
+	size_t theircnamelength;	/*!< Length of CNAME (utf8) */
+	struct timeval start;		  /*!< When the stream started */
+	struct timeval end;		  /*!< When the stream ended */
+	char writetranslator[80];	  /*!< Translator used when writing */
+	char readtranslator[80];		  /*!< Translator providing frames when reading */
+	int writecost;		  /*!< Cost in milliseconds for encoding/decoding 1 second of outbound media */
+	int readcost;		  /*!< Cost in milliseconds for encoding/decoding 1 second of inbound media */
+	int mediatype;			/*! Type of media */
 };
 
 #define AST_RTP_STAT_SET(current_stat, combined, placement, value) \
@@ -318,6 +355,9 @@
 	int (*destroy)(struct ast_rtp_instance *instance);
 	/*! Callback for writing out a frame */
 	int (*write)(struct ast_rtp_instance *instance, struct ast_frame *frame);
+	/*! Callback for stopping the outbound RTP media for an instance,
+	    but keeping the RTCP flow (and the RTP keepalives if needed) */
+	void (*hold)(struct ast_rtp_instance *instance, int status);
 	/*! Callback for stopping the RTP instance */
 	void (*stop)(struct ast_rtp_instance *instance);
 	/*! Callback for starting RFC2833 DTMF transmission */
@@ -377,6 +417,15 @@
 	format_t (*available_formats)(struct ast_rtp_instance *instance, format_t to_endpoint, format_t to_asterisk);
 	/*! Callback to send CNG */
 	int (*sendcng)(struct ast_rtp_instance *instance, int level);
+	/*! Callback to check if a media stram is active */
+	int (*isactive)(struct ast_rtp_instance *instance);
+	/*! Callback to set CNAME in rtcp  */
+	void (*setcname)(struct ast_rtp_instance *instance, const char *cname, size_t length);
+	/*! Callback to set information about bridged channel for CQR record */
+	void (*set_bridged_chan)(struct ast_rtp_instance *instance, const char *channel, const char *uniqueid, const char *bridgedchan, const char *bridgeduniqueid);
+	/*! Callback to set translation information for the CQR record */
+	void (*set_translator) (struct ast_rtp_instance *instance, const char *readtranslator, const int readcost, const char *writetranslator, const int writecost);
+	int (*rtcp_write_empty)(struct ast_rtp_instance *instance);
 	/*! Linked list information */
 	AST_RWLIST_ENTRY(ast_rtp_engine) entry;
 };
@@ -1311,6 +1360,26 @@
 int ast_rtp_instance_set_qos(struct ast_rtp_instance *instance, int tos, int cos, const char *desc);
 
 /*!
+ * \brief Stop the RTP outbound media in a stream, but keep the RTCP flow going
+ * 	  And propably RTP keepalives too.
+ *
+ * \param instance Instance that media is no longer going to at this time
+ *
+ * Example usage:
+ *
+ * \code
+ * ast_rtp_instance_stop(instance);
+ * \endcode
+ *
+ * This tells the RTP engine being used for the instance pointed to by instance
+ * that media is no longer going to it at this time, but may in the future.
+ * Keep the RTCP flow happy
+ *
+ * \since 1.42
+ */
+void ast_rtp_instance_hold(struct ast_rtp_instance *instance, int status);
+
+/*!
  * \brief Stop an RTP instance
  *
  * \param instance Instance that media is no longer going to at this time
@@ -1834,6 +1903,36 @@
 int ast_rtp_instance_sendcng(struct ast_rtp_instance *instance, int level);
 
 /*!
+ * \brief Send empty RTCP report
+ *
+ * \param instance The RTP instance
+ * \param fd File descriptor to use
+ *
+ * \retval 0 Success
+ * \retval non-zero Failure
+ */
+int ast_rtcp_write_empty(struct ast_rtp_instance *instance);
+
+
+/*!
+ * \brief Check if RTP stream is active
+ *
+ * \param instance The RTP instance
+ *
+ * \retval 0 Active (success)
+ * \retval -1 Not supported by RTP engine, 1 Not active
+ */
+int ast_rtp_instance_isactive(struct ast_rtp_instance *instance);
+
+/*!
+ * \brief Set the name of the RTP session (used in RTCP)
+ * \param cname Session name (UTF 8 possible)
+ * \param length Name of string (needed for UTF 8 always)
+ *
+ */
+int ast_rtp_instance_setcname(struct ast_rtp_instance *instance, const char *cname, size_t length);
+
+/*!
  * \brief Add or replace the SRTP policies for the given RTP instance
  *
  * \param instance the RTP instance
@@ -1854,6 +1953,22 @@
  */
 struct ast_srtp *ast_rtp_instance_get_srtp(struct ast_rtp_instance *instance);
 
+/*!
+ * \brief set the channel information for the CQR records
+ *
+ * \retval 0 on success
+ * \retval -1 not implemented by RTP engine
+ */
+int ast_rtp_instance_set_bridged_chan(struct ast_rtp_instance *instance, const char *channel, const char *uniqueid, const char *bridgedchan, const char *bridgeduniqueid);
+
+/*!
+ * \brief set the channel translator information for the CQR records
+ *
+ * \retval 0 on success
+ * \retval -1 not implemented by RTP engine
+ */
+int ast_rtp_instance_set_translator(struct ast_rtp_instance *instance, const char *readtranslator, const int readcost, const char *writetranslator, const int writecost);
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif
Index: include/asterisk/logger.h
===================================================================
--- include/asterisk/logger.h	(.../branches/1.8)	(revision 383011)
+++ include/asterisk/logger.h	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -181,8 +181,19 @@
 #endif
 #define AST_LOG_DTMF    __LOG_DTMF, _A_
 
-#define NUMLOGLEVELS 32
+#ifdef LOG_CQR
+#undef LOG_CQR
+#endif
+#define __LOG_CQR  7
+#define LOG_CQR    __LOG_CQR, _A_
 
+#ifdef AST_LOG_CQR
+#undef AST_LOG_CQR
+#endif
+#define AST_LOG_CQR    __LOG_CQR, _A_
+
+#define NUMLOGLEVELS 64		/* Highest bit */
+
 /*!
  * \brief Get the debug level for a module
  * \param module the name of module
Index: main/logger.c
===================================================================
--- main/logger.c	(.../branches/1.8)	(revision 383011)
+++ main/logger.c	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -174,6 +174,7 @@
 	"ERROR",
 	"VERBOSE",
 	"DTMF",
+	"CQR",
 };
 
 /*! \brief Colors used in the console for logging */
@@ -185,6 +186,7 @@
 	COLOR_RED,
 	COLOR_GREEN,
 	COLOR_BRGREEN,
+	COLOR_BRBLUE,
 	0,
 	0,
 	0,
@@ -193,7 +195,6 @@
 	0,
 	0,
 	0,
-	0,
 	COLOR_BRBLUE,
 	COLOR_BRBLUE,
 	COLOR_BRBLUE,
Index: main/rtp_engine.c
===================================================================
--- main/rtp_engine.c	(.../branches/1.8)	(revision 383011)
+++ main/rtp_engine.c	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -21,6 +21,9 @@
  * \brief Pluggable RTP Architecture
  *
  * \author Joshua Colp <jcolp@digium.com>
+ *
+ * Improved RTCP support by
+ * \author Olle E. Johansson  <oej@edvina.net>
  */
 
 /*** MODULEINFO
@@ -776,6 +779,13 @@
 	return instance->engine->qos ? instance->engine->qos(instance, tos, cos, desc) : -1;
 }
 
+void ast_rtp_instance_hold(struct ast_rtp_instance *instance, int status)
+{
+	if (instance->engine->hold) {
+		instance->engine->hold(instance, status);
+	}
+}
+
 void ast_rtp_instance_stop(struct ast_rtp_instance *instance)
 {
 	if (instance->engine->stop) {
@@ -829,6 +839,7 @@
 		return AST_BRIDGE_FAILED_NOWARN;
 	}
 
+	/* Now let go of the channel locks and be on our way */
 	ast_channel_unlock(c0);
 	ast_channel_unlock(c1);
 
@@ -837,6 +848,10 @@
 
 	ast_poll_channel_add(c0, c1);
 
+	/* Kick the RTCP stream going by sending one empty stupid little packet */
+	ast_rtcp_write_empty(instance0);
+	ast_rtcp_write_empty(instance1);
+
 	/* Hop into a loop waiting for a frame from either channel */
 	cs[0] = c0;
 	cs[1] = c1;
@@ -1836,11 +1851,58 @@
 	return instance->srtp;
 }
 
+int ast_rtp_instance_isactive(struct ast_rtp_instance *instance)
+{
+	if (instance->engine->isactive) {
+		return instance->engine->isactive(instance);
+	}
+
+	return -1;
+}
+
+int ast_rtcp_write_empty(struct ast_rtp_instance *instance)
+{
+	if (instance->engine->rtcp_write_empty) {
+		instance->engine->rtcp_write_empty(instance);
+		return 0;
+	}
+	return -1;
+}
+
 int ast_rtp_instance_sendcng(struct ast_rtp_instance *instance, int level)
 {
 	if (instance->engine->sendcng) {
 		return instance->engine->sendcng(instance, level);
 	}
-
 	return -1;
 }
+
+int ast_rtp_instance_setcname(struct ast_rtp_instance *instance, const char *cname, size_t length)
+{
+	if (instance->engine->setcname) {
+		instance->engine->setcname(instance, cname, length);
+		return 0;
+	}
+
+	return -1;	/* Function does not exist */
+}
+
+int ast_rtp_instance_set_bridged_chan(struct ast_rtp_instance *instance, const char *channel, const char *uniqueid, const char *bridgedchan, const char *bridgeduniqueid)
+{
+	if (instance->engine->set_bridged_chan) {
+		instance->engine->set_bridged_chan(instance, channel, uniqueid, bridgedchan, bridgeduniqueid);
+		return 0;
+	}
+
+	return -1;	/* Function does not exist */
+}
+
+int ast_rtp_instance_set_translator(struct ast_rtp_instance *instance, const char *readtranslator, const int readcost, const char *writetranslator, const int writecost)
+{
+	if (instance->engine->set_translator) {
+		instance->engine->set_translator(instance, readtranslator, readcost, writetranslator, writecost);
+		return 0;
+	}
+
+	return -1;	/* Function does not exist */
+}
Index: configs/extconfig.conf.sample
===================================================================
--- configs/extconfig.conf.sample	(.../branches/1.8)	(revision 383011)
+++ configs/extconfig.conf.sample	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -76,6 +76,7 @@
 ;queue_members => odbc,asterisk
 ;musiconhold => mysql,general
 ;queue_log => mysql,general
+;rtpcqr => mysql,general	; RTP Call Quality Records
 ;
 ;
 ; While most dynamic realtime engines are automatically used when defined in
Index: res/res_rtp_asterisk.c
===================================================================
--- res/res_rtp_asterisk.c	(.../branches/1.8)	(revision 383011)
+++ res/res_rtp_asterisk.c	(.../team/oej/pinefrog-rtcp-1.8)	(revision 383011)
@@ -67,13 +67,33 @@
 #define MINIMUM_RTP_PORT 1024 /*!< Minimum port number to accept */
 #define MAXIMUM_RTP_PORT 65535 /*!< Maximum port number to accept */
 
-#define RTCP_PT_FUR     192
-#define RTCP_PT_SR      200
-#define RTCP_PT_RR      201
-#define RTCP_PT_SDES    202
-#define RTCP_PT_BYE     203
-#define RTCP_PT_APP     204
+#define RTCP_PT_FUR     192		/*!< FIR  - Full Intra-frame request (h.261) */
+#define RTCP_PT_NACK    193		/*!< NACK - Negative acknowledgement (h.261) */
+#define RTCP_PT_IJ      195		/*!< IJ   - RFC 5450 Extended Inter-arrival jitter report */
+#define RTCP_PT_SR      200		/*!< SR   - RFC 3550 Sender report */
+#define RTCP_PT_RR      201		/*!< RR   - RFC 3550 Receiver report */
+#define RTCP_PT_SDES    202		/*!< SDES - Source Description */
+#define RTCP_PT_BYE     203		/*!< BYE  - Goodbye */
+#define RTCP_PT_APP     204		/*!< APP  - Application defined */
+#define RTCP_PT_RTPFB   205		/*!< RTPFB - Generic RTP feedback RFC 4585 */
+#define RTCP_PT_PSFB    206		/*!< PSFB - Payload specific data  RFC 4585 */
+#define RTCP_PT_XR      207		/*!< XR   - Extended report - RFC3611 */
 
+/*! \brief RFC 3550 RTCP SDES Item types */
+enum rtcp_sdes {
+	SDES_END	= 0,		/*!< End of SDES list */
+	SDES_CNAME	= 1,		/*!< Canonical name */
+	SDES_NAME	= 2,		/*!< User name */
+	SDES_EMAIL	= 3,		/*!< User's e-mail address */
+	SDES_PHONE	= 4,		/*!< User's phone number */
+	SDES_LOC	= 5,		/*!< Geographic user location */
+	SDES_TOOL	= 6,		/*!< Name of application or tool */
+	SDES_NOTE	= 7,		/*!< Notice about the source */
+	SDES_PRIV	= 8,		/*!< SDES Private extensions */
+	SDES_H323_CADDR	= 9,		/*!< H.323 Callable address */
+	SDES_APSI	= 10,		/*!< Application Specific Identifier (RFC 6776) */
+};
+
 #define RTP_MTU		1200
 
 #define DEFAULT_DTMF_TIMEOUT (150 * (8000 / 1000))	/*!< samples */
@@ -89,7 +109,7 @@
 static int rtpend = DEFAULT_RTP_END;			/*!< Last port for RTP sessions (set in rtp.conf) */
 static int rtpdebug;			/*!< Are we debugging? */
 static int rtcpdebug;			/*!< Are we debugging RTCP? */
-static int rtcpstats;			/*!< Are we debugging RTCP? */
+static int rtcpstats;			/*!< Are we gathering stats? */
 static int rtcpinterval = RTCP_DEFAULT_INTERVALMS; /*!< Time between rtcp reports in millisecs */
 static struct ast_sockaddr rtpdebugaddr;	/*!< Debug packets to/from this host */
 static struct ast_sockaddr rtcpdebugaddr;	/*!< Debug RTCP packets to/from this host */
@@ -113,6 +133,7 @@
 #define FLAG_NAT_INACTIVE_NOWARN        (1 << 1)
 #define FLAG_NEED_MARKER_BIT            (1 << 3)
 #define FLAG_DTMF_COMPENSATE            (1 << 4)
+#define FLAG_HOLD	        	(1 << 4)	/* This RTP stream is put on hold by someone else, a:sendonly */
 
 /*! \brief RTP session description */
 struct ast_rtp {
@@ -154,20 +175,22 @@
 	unsigned int dtmf_timeout;        /*!< When this timestamp is reached we consider END frame lost and forcibly abort digit */
 	unsigned int dtmfsamples;
 	enum ast_rtp_dtmf_mode dtmfmode;  /*!< The current DTMF mode of the RTP stream */
+
 	/* DTMF Transmission Variables */
 	unsigned int lastdigitts;
-	char sending_digit;	/*!< boolean - are we sending digits */
-	char send_digit;	/*!< digit we are sending */
+	char sending_digit;		  /*!< boolean - are we sending digits */
+	char send_digit;		  /*!< digit we are sending */
 	int send_payload;
 	int send_duration;
 	unsigned int flags;
 	struct timeval rxcore;
 	struct timeval txcore;
 	double drxcore;                 /*!< The double representation of the first received packet */
+	struct timeval start;           /*!< When the stream started (we can't depend on CDRs) */
 	struct timeval lastrx;          /*!< timeval when we last received a packet */
 	struct timeval dtmfmute;
+	struct timeval holdstart;       /*!< When the stream was put on hold */
 	struct ast_smoother *smoother;
-	int *ioid;
 	unsigned short seqno;		/*!< Sequence number, RFC 3550, page 13. */
 	unsigned short rxseqno;
 	struct sched_context *sched;
@@ -186,6 +209,7 @@
 	 */
 	uint16_t learning_max_seq;		/*!< Highest sequence number heard */
 	int learning_probation;		/*!< Sequential packets untill source is valid */
+	int isactive;			/*!< Whether the RTP stream is active or not */
 
 	struct rtp_red *red;
 };
@@ -197,11 +221,18 @@
  * this structure is analogous to ast_rtp, which tracks a RTP session,
  * it is logical to think of this as a RTCP session.
  *
+ * On the other hand, RTCP SDES defines the names for the actual
+ * RTP session so it's one session - RTP and RTCP together (OEJ)
+ *
  * RTCP packet is defined on page 9 of RFC 3550.
  *
  */
 struct ast_rtcp {
 	int rtcp_info;
+	char ourcname[255];		/*!< Our SDES RTP session name (CNAME) */
+	size_t ourcnamelength;		/*!< Length of CNAME (utf8) */
+	char theircname[255];		/*!< Their SDES RTP session name (CNAME) */
+	size_t theircnamelength;	/*!< Length of CNAME (utf8) */
 	int s;				/*!< Socket */
 	struct ast_sockaddr us;		/*!< Socket representation of the local endpoint. */
 	struct ast_sockaddr them;	/*!< Socket representation of the remote endpoint. */
@@ -215,17 +246,19 @@
 	int schedid;			/*!< Schedid returned from ast_sched_add() to schedule RTCP-transmissions*/
 	unsigned int rr_count;		/*!< number of RRs we've sent, not including report blocks in SR's */
 	unsigned int sr_count;		/*!< number of SRs we've sent */
+	unsigned int rec_rr_count;      /*!< Number of RRs we've received */
+	unsigned int rec_sr_count;      /*!< Number of SRs we've received */
 	unsigned int lastsrtxcount;     /*!< Transmit packet count when last SR sent */
 	double accumulated_transit;	/*!< accumulated a-dlsr-lsr */
 	double rtt;			/*!< Last reported rtt */
 	unsigned int reported_jitter;	/*!< The contents of their last jitter entry in the RR */
 	unsigned int reported_lost;	/*!< Reported lost packets in their RR */
 
-	double reported_maxjitter;
-	double reported_minjitter;
+	double reported_maxjitter;	/*!< The contents of their max jitter entry received by us */
+	double reported_minjitter;	/*!< The contents of their min jitter entry received by us */
 	double reported_normdev_jitter;
 	double reported_stdev_jitter;
-	unsigned int reported_jitter_count;
+	unsigned int reported_jitter_count; /*! Number of reports received */
 
 	double reported_maxlost;
 	double reported_minlost;
@@ -237,25 +270,33 @@
 	double minrxlost;
 	double normdev_rxlost;
 	double stdev_rxlost;
-	unsigned int rxlost_count;
+	unsigned int rxlost_count;	/*! Number of reports received */
 
 	double maxrxjitter;
 	double minrxjitter;
 	double normdev_rxjitter;
 	double stdev_rxjitter;
-	unsigned int rxjitter_count;
+	unsigned int rxjitter_count;	/*! Number of reports received */
 	double maxrtt;
 	double minrtt;
 	double normdevrtt;
 	double stdevrtt;
-	unsigned int rtt_count;
+	unsigned int rtt_count;		/*! Number of reports received */
+	char bridgedchannel[AST_MAX_EXTENSION];		/*!< Bridged channel name */
+	char bridgeduniqueid[AST_MAX_EXTENSION];	/*!< Bridged channel uniqueid */
+	char channel[AST_MAX_EXTENSION];		/*!< Our channel name */
+	char uniqueid[AST_MAX_EXTENSION];	/*!< Our channel uniqueid */
+	char readtranslator[80];	/* Translation done on reading audio from PBX */
+	char writetranslator[80];	/* Translation done on writing audio to PBX - bridged channel */
+	int readcost;			/* Delay in milliseconds for translation of 1 second of audio */
+	int writecost;			/* Delay in milliseconds for translation of 1 second of audio */
 };
 
 struct rtp_red {
 	struct ast_frame t140;  /*!< Primary data  */
 	struct ast_frame t140red;   /*!< Redundant t140*/
 	unsigned char pt[AST_RED_MAX_GENERATION];  /*!< Payload types for redundancy data */
-	unsigned char ts[AST_RED_MAX_GENERATION]; /*!< Time stamps */
+unsigned char ts[AST_RED_MAX_GENERATION]; /*!< Time stamps */
 	unsigned char len[AST_RED_MAX_GENERATION]; /*!< length of each generation */
 	int num_gen; /*!< Number of generations */
 	int schedid; /*!< Timer id */
@@ -290,9 +331,18 @@
 static int ast_rtp_get_stat(struct ast_rtp_instance *instance, struct ast_rtp_instance_stats *stats, enum ast_rtp_instance_stat stat);
 static int ast_rtp_dtmf_compatible(struct ast_channel *chan0, struct ast_rtp_instance *instance0, struct ast_channel *chan1, struct ast_rtp_instance *instance1);
 static void ast_rtp_stun_request(struct ast_rtp_instance *instance, struct ast_sockaddr *suggestion, const char *username);
+static void ast_rtp_hold(struct ast_rtp_instance *instance, int status);
 static void ast_rtp_stop(struct ast_rtp_instance *instance);
 static int ast_rtp_qos_set(struct ast_rtp_instance *instance, int tos, int cos, const char* desc);
 static int ast_rtp_sendcng(struct ast_rtp_instance *instance, int level);
+static int ast_rtcp_write(const void *data);
+static void ast_rtcp_setcname(struct ast_rtp_instance *instance, const char *cname, size_t length);
+static void ast_rtcp_set_bridged(struct ast_rtp_instance *instance, const char *channel, const char *uniqueid, const char *bridgedchan, const char *bridgeduniqueid);
+void ast_rtcp_set_translator(struct ast_rtp_instance *instance, const char *readtranslator, const int readcost, const char *writetranslator, const int writecost);
+static int ast_rtp_isactive(struct ast_rtp_instance *instance);
+static int add_sdes_bodypart(struct ast_rtp *rtp, unsigned int *rtcp_packet, int len, int type);
+static int add_sdes_header(struct ast_rtp *rtp, unsigned int *rtcp_packet, int len);
+static int ast_rtcp_write_empty_frame(struct ast_rtp_instance *instance);
 
 /* RTP Engine Declaration */
 static struct ast_rtp_engine asterisk_rtp_engine = {
@@ -318,9 +368,15 @@
 	.get_stat = ast_rtp_get_stat,
 	.dtmf_compatible = ast_rtp_dtmf_compatible,
 	.stun_request = ast_rtp_stun_request,
+	.hold = ast_rtp_hold,
 	.stop = ast_rtp_stop,
 	.qos = ast_rtp_qos_set,
 	.sendcng = ast_rtp_sendcng,
+	.setcname = ast_rtcp_setcname,
+	.set_bridged_chan = ast_rtcp_set_bridged,
+	.set_translator = ast_rtcp_set_translator,
+	.isactive = ast_rtp_isactive,
+	.rtcp_write_empty = ast_rtcp_write_empty_frame,
 };
 
 static inline int rtp_debug_test_addr(struct ast_sockaddr *addr)
@@ -421,6 +477,24 @@
 	return interval;
 }
 
+/*! \brief Schedule RTCP transmissions for RTP channel */
+static void ast_rtcp_schedule(struct ast_rtp_instance *instance)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+
+	/* Do not schedule RR if RTCP isn't run */
+	if (rtp->rtcp && !ast_sockaddr_isnull(&rtp->rtcp->them)  && rtp->rtcp->schedid < 1) {
+		/* Schedule transmission of Receiver Report */
+		ast_rtcp_write_empty(instance);
+		ao2_ref(instance, +1);
+		rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, instance);
+		if (rtp->rtcp->schedid < 0) {
+			ao2_ref(instance, -1);
+			ast_log(LOG_WARNING, "scheduling RTCP transmission failed.\n");
+		}
+	}
+}
+
 /*! \brief Calculate normal deviation */
 static double normdev_compute(double normdev, double sample, unsigned int sample_count)
 {
@@ -580,6 +654,9 @@
 	/* Associate the RTP structure with the RTP instance and be done */
 	ast_rtp_instance_set_data(instance, rtp);
 
+	gettimeofday(&rtp->start, NULL);
+	rtp->isactive = 1;
+
 	return 0;
 }
 
@@ -890,7 +967,7 @@
 }
 
 /*! \brief Send RTCP recipient's report */
-static int ast_rtcp_write_rr(struct ast_rtp_instance *instance)
+static int ast_rtcp_write_rr(struct ast_rtp_instance *instance, int goodbye)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	int res;
@@ -902,7 +979,7 @@
 	unsigned int received_interval;
 	int lost_interval;
 	struct timeval now;
-	unsigned int *rtcpheader;
+	unsigned int *rtcpheader, *start;
 	char bdata[1024];
 	struct timeval dlsr;
 	int fraction;
@@ -950,7 +1027,7 @@
 		fraction = (lost_interval << 8) / expected_interval;
 	gettimeofday(&now, NULL);
 	timersub(&now, &rtp->rtcp->rxlsr, &dlsr);
-	rtcpheader = (unsigned int *)bdata;
+	rtcpheader = (unsigned int *) bdata;
 	rtcpheader[0] = htonl((2 << 30) | (1 << 24) | (RTCP_PT_RR << 16) | ((len/4)-1));
 	rtcpheader[1] = htonl(rtp->ssrc);
 	rtcpheader[2] = htonl(rtp->themssrc);
@@ -960,13 +1037,13 @@
 	rtcpheader[6] = htonl(rtp->rtcp->themrxlsr);
 	rtcpheader[7] = htonl((((dlsr.tv_sec * 1000) + (dlsr.tv_usec / 1000)) * 65536) / 1000);
 
-	/*! \note Insert SDES here. Probably should make SDES text equal to mimetypes[code].type (not subtype 'cos
-	  it can change mid call, and SDES can't) */
-	rtcpheader[len/4]     = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | 2);
-	rtcpheader[(len/4)+1] = htonl(rtp->ssrc);               /* Our SSRC */
-	rtcpheader[(len/4)+2] = htonl(0x01 << 24);              /* Empty for the moment */
-	len += 12;
 
+	start = &rtcpheader[len/4];
+	len +=8; /* SKip header for now */
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_CNAME);
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_END);
+	/* Now, add header when we know the actual length */
+	add_sdes_header(rtp, start, len);
 	res = rtcp_sendto(instance, (unsigned int *)rtcpheader, len, 0, &rtp->rtcp->them);
 
 	if (res < 0) {
@@ -992,15 +1069,16 @@
 }
 
 /*! \brief Send RTCP sender's report */
-static int ast_rtcp_write_sr(struct ast_rtp_instance *instance)
+static int ast_rtcp_write_sr(struct ast_rtp_instance *instance, int goodbye)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	int res;
-	int len = 0;
+	int len = 0;	/* Measured in chunks of four bytes */
+	int srlen = 0;
 	struct timeval now;
 	unsigned int now_lsw;
 	unsigned int now_msw;
-	unsigned int *rtcpheader;
+	unsigned int *rtcpheader, *start;
 	unsigned int lost;
 	unsigned int extended;
 	unsigned int expected;
@@ -1023,7 +1101,8 @@
 	}
 
 	gettimeofday(&now, NULL);
-	timeval2ntp(now, &now_msw, &now_lsw); /* fill thses ones in from utils.c*/
+	timeval2ntp(now, &now_msw, &now_lsw); /* fill these ones in from utils.c*/
+	/* Set the header for sender's report */
 	rtcpheader = (unsigned int *)bdata;
 	rtcpheader[1] = htonl(rtp->ssrc);               /* Our SSRC */
 	rtcpheader[2] = htonl(now_msw);                 /* now, MSW. gettimeofday() + SEC_BETWEEN_1900_AND_1970*/
@@ -1058,13 +1137,22 @@
 
 	rtcpheader[0] = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SR << 16) | ((len/4)-1));
 
-	/* Insert SDES here. Probably should make SDES text equal to mimetypes[code].type (not subtype 'cos */
-	/* it can change mid call, and SDES can't) */
-	rtcpheader[len/4]     = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | 2);
-	rtcpheader[(len/4)+1] = htonl(rtp->ssrc);               /* Our SSRC */
-	rtcpheader[(len/4)+2] = htonl(0x01 << 24);                    /* Empty for the moment */
-	len += 12;
+	start = &rtcpheader[len/4];
+	srlen = len;
+	len +=8; /* SKip header for now */
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_CNAME);
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_END);
+	/* Now, add header when we know the actual length */
+	add_sdes_header(rtp, start, len - srlen);
 
+	if (goodbye) {
+		/* An additional RTCP block */
+		rtcpheader[len/4] = htonl((2 << 30) | (1 << 24) | (RTCP_PT_BYE << 16) | 1);
+		len += 4;
+		rtcpheader[len/4] = htonl(rtp->ssrc);               /* Our SSRC */
+		len += 4;
+	}
+
 	res = rtcp_sendto(instance, (unsigned int *)rtcpheader, len, 0, &rtp->rtcp->them);
 	if (res < 0) {
 		ast_log(LOG_ERROR, "RTCP SR transmission error to %s, rtcp halted %s\n",
@@ -1087,11 +1175,11 @@
 		ast_verbose("  Sent packets: %u\n", rtp->txcount);
 		ast_verbose("  Sent octets: %u\n", rtp->txoctetcount);
 		ast_verbose("  Report block:\n");
-		ast_verbose("  Fraction lost: %u\n", fraction);
-		ast_verbose("  Cumulative loss: %u\n", lost);
-		ast_verbose("  IA jitter: %.4f\n", rtp->rxjitter);
-		ast_verbose("  Their last SR: %u\n", rtp->rtcp->themrxlsr);
-		ast_verbose("  DLSR: %4.4f (sec)\n\n", (double)(ntohl(rtcpheader[12])/65536.0));
+		ast_verbose("    Fraction lost (since last report): %u\n", fraction);
+		ast_verbose("    Cumulative loss: %u\n", lost);
+		ast_verbose("    IA jitter: %.4f\n", rtp->rxjitter);
+		ast_verbose("    Their last SR: %u\n", rtp->rtcp->themrxlsr);
+		ast_verbose("    Delay since last SR (DLSR): %4.4f (sec)\n\n", (double)(ntohl(rtcpheader[12])/65536.0));
 	}
 	manager_event(EVENT_FLAG_REPORTING, "RTCPSent", "To: %s\r\n"
 					    "OurSSRC: %u\r\n"
@@ -1134,9 +1222,9 @@
 	}
 
 	if (rtp->txcount > rtp->rtcp->lastsrtxcount) {
-		res = ast_rtcp_write_sr(instance);
+		res = ast_rtcp_write_sr(instance, 0);
 	} else {
-		res = ast_rtcp_write_rr(instance);
+		res = ast_rtcp_write_rr(instance, 0);
 	}
 
 	if (!res) {
@@ -1255,15 +1343,7 @@
 			rtp->txcount++;
 			rtp->txoctetcount += (res - hdrlen);
 
-			if (rtp->rtcp && rtp->rtcp->schedid < 1) {
-				ast_debug(1, "Starting RTCP transmission on RTP instance '%p'\n", instance);
-				ao2_ref(instance, +1);
-				rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, instance);
-				if (rtp->rtcp->schedid < 0) {
-					ao2_ref(instance, -1);
-					ast_log(LOG_WARNING, "scheduling RTCP transmission failed.\n");
-				}
-			}
+			ast_rtcp_schedule(instance);
 		}
 
 		if (rtp_debug_test_addr(&remote_address)) {
@@ -1321,6 +1401,12 @@
 	struct ast_sockaddr remote_address = { {0,} };
 	format_t codec, subclass;
 
+	if (ast_test_flag(rtp, FLAG_HOLD)) {
+		/* This stream is on hold, just keep on happily and don't do anything */
+		ast_debug(1, "** Frame muted since we're on hold. \n");
+		return 0;
+	}
+
 	ast_rtp_instance_get_remote_address(instance, &remote_address);
 
 	/* If we don't actually know the remote address don't even bother doing anything */
@@ -1468,20 +1554,23 @@
 		d=-d;
 	rtp->rxjitter += (1./16.) * (d - rtp->rxjitter);
 
-	if (rtp->rtcp) {
-		if (rtp->rxjitter > rtp->rtcp->maxrxjitter)
-			rtp->rtcp->maxrxjitter = rtp->rxjitter;
-		if (rtp->rtcp->rxjitter_count == 1)
-			rtp->rtcp->minrxjitter = rtp->rxjitter;
-		if (rtp->rtcp && rtp->rxjitter < rtp->rtcp->minrxjitter)
-			rtp->rtcp->minrxjitter = rtp->rxjitter;
+	if (!rtp->rtcp) {
+		return;
+	}
+	if (rtp->rxjitter > rtp->rtcp->maxrxjitter)
+		rtp->rtcp->maxrxjitter = rtp->rxjitter;
+	if (rtp->rtcp->rxjitter_count == 1) {
+		rtp->rtcp->minrxjitter = rtp->rxjitter;
+	}
+	if (rtp->rtcp && rtp->rxjitter < rtp->rtcp->minrxjitter) {
+		rtp->rtcp->minrxjitter = rtp->rxjitter;
+	}
 
-		normdev_rxjitter_current = normdev_compute(rtp->rtcp->normdev_rxjitter,rtp->rxjitter,rtp->rtcp->rxjitter_count);
-		rtp->rtcp->stdev_rxjitter = stddev_compute(rtp->rtcp->stdev_rxjitter,rtp->rxjitter,rtp->rtcp->normdev_rxjitter,normdev_rxjitter_current,rtp->rtcp->rxjitter_count);
+	normdev_rxjitter_current = normdev_compute(rtp->rtcp->normdev_rxjitter,rtp->rxjitter,rtp->rtcp->rxjitter_count);
+	rtp->rtcp->stdev_rxjitter = stddev_compute(rtp->rtcp->stdev_rxjitter,rtp->rxjitter,rtp->rtcp->normdev_rxjitter,normdev_rxjitter_current,rtp->rtcp->rxjitter_count);
 
-		rtp->rtcp->normdev_rxjitter = normdev_rxjitter_current;
-		rtp->rtcp->rxjitter_count++;
-	}
+	rtp->rtcp->normdev_rxjitter = normdev_rxjitter_current;
+	rtp->rtcp->rxjitter_count++;
 }
 
 static struct ast_frame *create_dtmf_frame(struct ast_rtp_instance *instance, enum ast_frame_type type, int compensate)
@@ -1772,16 +1861,41 @@
 	return &rtp->f;
 }
 
-static struct ast_frame *ast_rtcp_read(struct ast_rtp_instance *instance)
+static struct ast_frame *ast_rtcp_read_fd(int fd, struct ast_rtp_instance *instance);
+struct ast_frame *ast_rtcp_read(struct ast_rtp_instance *instance);
+
+#ifdef NOT_NEEDED_ANYMORE
+static int p2p_rtcp_callback(int *id, int fd, short events, void *cbdata)
 {
+	struct ast_rtp *rtp = cbdata;
+	ast_rtcp_read_fd(fd, instance);	
+	/* For now, skip any frames that is output. Which is bad for FUR's, but well. DEBUG */
+	return 1;
+}
+#endif
+
+struct ast_frame *ast_rtcp_read(struct ast_rtp_instance *instance)
+{
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	return ast_rtcp_read_fd(rtp->rtcp->s, instance);
+}
+
+static struct ast_frame *ast_rtcp_read_fd(int fd, struct ast_rtp_instance *instance)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	struct ast_sockaddr addr;
 	unsigned int rtcpdata[8192 + AST_FRIENDLY_OFFSET];
 	unsigned int *rtcpheader = (unsigned int *)(rtcpdata + AST_FRIENDLY_OFFSET);
-	int res, packetwords, position = 0;
+	int j, res, packetwords, position = 0;
+	char *sdes;
+	unsigned int sdeslength, sdestype;
 	struct ast_frame *f = &ast_null_frame;
 
 	/* Read in RTCP data from the socket */
+
+/* OEJ - ouch, we need to send a file handle here. Check this
+	isntance replaces the fd
+*/
 	if ((res = rtcp_recvfrom(instance, rtcpdata + AST_FRIENDLY_OFFSET,
 				sizeof(rtcpdata) - sizeof(unsigned int) * AST_FRIENDLY_OFFSET,
 				0, &addr)) < 0) {
@@ -1793,7 +1907,7 @@
 		return &ast_null_frame;
 	}
 
-	packetwords = res / 4;
+	packetwords = res / 4;	 /* Each RTCP segment is 32 bits */
 
 	if (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT)) {
 		/* Send to whoever sent to us */
@@ -1805,8 +1919,15 @@
 		}
 	}
 
-	ast_debug(1, "Got RTCP report of %d bytes\n", res);
+	if (rtcp_debug_test_addr(&addr)) {
+		ast_debug(1, "Got RTCP report of %d bytes - %d messages\n", res, packetwords);
+	}
 
+	/* Process a compound packet 
+	   - A compound packet should start with a sender or receiver report. BYE can start as well
+		(seen in implementations) 
+	   -  Packet length should be a multiple of four bytes
+	*/
 	while (position < packetwords) {
 		int i, pt, rc;
 		unsigned int length, dlsr, lsr, msw, lsw, comp;
@@ -1815,15 +1936,20 @@
 		uint64_t rtt = 0;
 
 		i = position;
+		if (rtcp_debug_test_addr(&addr)) {
+			ast_debug(3, "***** Debug - position = %d\n", position     );
+		}
 		length = ntohl(rtcpheader[i]);
-		pt = (length & 0xff0000) >> 16;
-		rc = (length & 0x1f000000) >> 24;
+		pt = (length & 0xff0000) >> 16;		/* Packet type */
+		rc = (length & 0x1f000000) >> 24;	/* Number of chunks, i.e. streams reported */
 		length &= 0xffff;
 
 		if ((i + length) > packetwords) {
-			if (option_debug || rtpdebug)
-				ast_log(LOG_DEBUG, "RTCP Read too short\n");
-			return &ast_null_frame;
+			if (option_debug || rtpdebug) {
+				ast_log(LOG_WARNING, "RTCP Read too short - packet type %d position %d\n", pt, i);
+			}
+			//return &ast_null_frame;
+			return f;
 		}
 
 		if (rtcp_debug_test_addr(&addr)) {
@@ -1831,7 +1957,11 @@
 				    ast_sockaddr_stringify(&addr));
 			ast_verbose("PT: %d(%s)\n", pt, (pt == 200) ? "Sender Report" : (pt == 201) ? "Receiver Report" : (pt == 192) ? "H.261 FUR" : "Unknown");
 			ast_verbose("Reception reports: %d\n", rc);
-			ast_verbose("SSRC of sender: %u\n", rtcpheader[i + 1]);
+			ast_verbose("   SSRC of packet sender: %u (%x)", ntohl(rtcpheader[i + 1]), ntohl(rtcpheader[i + 1]));
+			ast_verbose("   (Position %d of %d)\n", i, packetwords);
+			if (rc == 0) {  
+				ast_verbose("   Empty - no reports! \n");
+			}
 		}
 
 		i += 2; /* Advance past header and ssrc */
@@ -1840,27 +1970,46 @@
 			continue;
 		}
 
+
+		if (rc == 0 && pt == RTCP_PT_RR) {	/* We're receiving a receiver report with no reports, which is ok */
+			position += (length + 1);
+			continue;
+		}
+		if (pt == RTCP_PT_SR) {
+			rtp->rtcp->rec_sr_count++;
+		} else if (pt == RTCP_PT_RR) {
+			rtp->rtcp->rec_rr_count++;
+		}
 		switch (pt) {
-		case RTCP_PT_SR:
-			gettimeofday(&rtp->rtcp->rxlsr,NULL); /* To be able to populate the dlsr */
-			rtp->rtcp->spc = ntohl(rtcpheader[i+3]);
-			rtp->rtcp->soc = ntohl(rtcpheader[i + 4]);
-			rtp->rtcp->themrxlsr = ((ntohl(rtcpheader[i]) & 0x0000ffff) << 16) | ((ntohl(rtcpheader[i + 1]) & 0xffff0000) >> 16); /* Going to LSR in RR*/
+		case RTCP_PT_SR:	/* Sender's report - about what they have sent us */
+			if (rtcp_debug_test_addr(&addr)) {
+				ast_verbose("    - RTCP SR (sender report) from %s\n", ast_sockaddr_stringify(&rtp->rtcp->them));
+			}
+			/* Don't handle multiple reception reports (rc > 1) yet */
+			gettimeofday(&rtp->rtcp->rxlsr, NULL); /* To be able to populate the dlsr */
+			rtp->rtcp->spc = ntohl(rtcpheader[i + 3]);	/* Sender packet count */
+			rtp->rtcp->soc = ntohl(rtcpheader[i + 4]);	/* Sender octet count */
 
+ 			rtp->rtcp->themrxlsr = ((ntohl(rtcpheader[i]) & 0x0000ffff) << 16) | ((ntohl(rtcpheader[i + 1]) & 0xffff0000) >> 16); /* Going to LSR in RR*/
+     
+ 			if (rtcp_debug_test_addr(&addr)) {
+				ast_verbose("      NTP timestamp: %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[i]), (unsigned long) ntohl(rtcpheader[i + 1]) * 4096);
+				ast_verbose("      RTP timestamp: %lu\n", (unsigned long) ntohl(rtcpheader[i + 2]));
+				ast_verbose("      SPC: %lu\tSOC: %lu\n", (unsigned long) ntohl(rtcpheader[i + 3]), (unsigned long) ntohl(rtcpheader[i + 4]));
+				ast_verbose("      RC (number of reports) %d\n", rc);
+ 			}
+			i += 5;	/* Sender's info report is five bytes */
+ 			if (rc < 1)
+ 				break;
+
+		case RTCP_PT_RR:	/* Receiver report - data about what we have sent to them */
 			if (rtcp_debug_test_addr(&addr)) {
-				ast_verbose("NTP timestamp: %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[i]), (unsigned long) ntohl(rtcpheader[i + 1]) * 4096);
-				ast_verbose("RTP timestamp: %lu\n", (unsigned long) ntohl(rtcpheader[i + 2]));
-				ast_verbose("SPC: %lu\tSOC: %lu\n", (unsigned long) ntohl(rtcpheader[i + 3]), (unsigned long) ntohl(rtcpheader[i + 4]));
+				ast_verbose("Received a RTCP RR (receiver report) from %s\n", ast_sockaddr_stringify(&rtp->rtcp->them));
 			}
-			i += 5;
-			if (rc < 1)
-				break;
-			/* Intentional fall through */
-		case RTCP_PT_RR:
-			/* Don't handle multiple reception reports (rc > 1) yet */
 			/* Calculate RTT per RFC */
 			gettimeofday(&now, NULL);
 			timeval2ntp(now, &msw, &lsw);
+			/* Get timing */ 
 			if (ntohl(rtcpheader[i + 4]) && ntohl(rtcpheader[i + 5])) { /* We must have the LSR && DLSR */
 				comp = ((msw & 0xffff) << 16) | ((lsw & 0xffff0000) >> 16);
 				lsr = ntohl(rtcpheader[i + 4]);
@@ -1882,13 +2031,16 @@
 				if (comp - dlsr >= lsr) {
 					rtp->rtcp->accumulated_transit += rttsec;
 
-					if (rtp->rtcp->rtt_count == 0)
+					if (rtp->rtcp->rtt_count == 0) {
 						rtp->rtcp->minrtt = rttsec;
+					}
 
-					if (rtp->rtcp->maxrtt<rttsec)
+					if (rtp->rtcp->maxrtt<rttsec) {
 						rtp->rtcp->maxrtt = rttsec;
-					if (rtp->rtcp->minrtt>rttsec)
+					}
+					if (rtp->rtcp->minrtt > rttsec || rtp->rtcp->minrtt == 0) {
 						rtp->rtcp->minrtt = rttsec;
+					}
 
 					normdevrtt_current = normdev_compute(rtp->rtcp->normdevrtt, rttsec, rtp->rtcp->rtt_count);
 
@@ -2009,8 +2161,9 @@
 			}
 			break;
 		case RTCP_PT_FUR:
-			if (rtcp_debug_test_addr(&addr))
-				ast_verbose("Received an RTCP Fast Update Request\n");
+			if (rtcp_debug_test_addr(&addr)) {
+				ast_verbose("Received an RTCP Fast Update Request from %s\n", ast_sockaddr_stringify(&rtp->rtcp->them));
+			}
 			rtp->f.frametype = AST_FRAME_CONTROL;
 			rtp->f.subclass.integer = AST_CONTROL_VIDUPDATE;
 			rtp->f.datalen = 0;
@@ -2020,23 +2173,139 @@
 			f = &rtp->f;
 			break;
 		case RTCP_PT_SDES:
-			if (rtcp_debug_test_addr(&addr))
-				ast_verbose("Received an SDES from %s\n",
-					    ast_sockaddr_stringify(&rtp->rtcp->them));
+			/* SDES messages are divided into chunks, each one containing one or
+			   several items. Each chunk is for a different CSRC, so it is not really
+			   relevant in most cases of voip calls - unless you have an advanced
+			   mixer in the network that separates the different streams with CSRC 
+
+			   A chunk starts with SSRC/CSRC (four bytes), then SDES items 
+			   In the SDES message, there can be several items, ending with SDES_END
+			   The length of the all items is length - header 
+			   Chunk starts on a 32-bit boundary and needs padding by 0's
+		
+			   the "rc" variable contains the number of chunks 
+			   When we start, we're beyond the SSRC and starts with SDES items in the
+			   first chunk.
+			
+				an SDES item is one byte of type, one byte of length then data 
+				(no null termination). Text is UTF-8.
+				the last item is a zero (END) type with no length indication.
+			*/
+			
+			j = i * 4;
+			sdes = (char *) &rtcpheader[i];
+			if (rtcp_debug_test_addr(&addr)) {
+				ast_verbose("   Received an SDES from %s - Total length %d (%d bytes)\n", ast_sockaddr_stringify(&rtp->rtcp->them), length-i, ((length-i)*4) - 6);
+			}
+			while (j < length * 4) {
+				sdestype = (int) *sdes;
+				sdes++;
+				sdeslength = (int) *sdes;
+				sdes++;
+				if (rtcp_debug_test_addr(&addr)) {
+					ast_verbose(" --- SDES Type %u, Length %u Curj %d)\n", sdestype, sdeslength, j);
+				}
+				switch (sdestype) {
+				case SDES_CNAME:
+					if (!ast_strlen_zero(rtp->rtcp->theircname)) {
+						if (strncmp(rtp->rtcp->theircname, sdes, sdeslength)) {
+							ast_log(LOG_WARNING, "New RTP stream received (new RTCP CNAME for session. Old name: %s\n", rtp->rtcp->theircname);
+						}
+					}
+					strncpy(rtp->rtcp->theircname, sdes, sdeslength);
+					rtp->rtcp->theircname[sdeslength + 1] = '\0';
+					rtp->rtcp->theircnamelength = sdeslength;
+					if (rtcp_debug_test_addr(&addr)) {
+						ast_verbose(" --- SDES CNAME (utf8) %s\n", rtp->rtcp->theircname);
+					}
+					break;
+				case SDES_TOOL:
+					if (rtcp_debug_test_addr(&addr)) {
+						ast_verbose(" --- SDES TOOL \n");
+					}
+					break;
+				case SDES_NAME:
+					if (rtcp_debug_test_addr(&addr)) {
+						ast_verbose(" --- SDES NAME \n");
+					}
+					break;
+				case SDES_EMAIL:
+					if (rtcp_debug_test_addr(&addr)) {
+						ast_verbose(" --- SDES EMAIL \n");
+					}
+					break;
+				case SDES_PHONE:
+					if (rtcp_debug_test_addr(&addr)) {
+						ast_verbose(" --- SDES PHONE \n");
+					}
+					break;
+				case SDES_LOC:
+					if (rtcp_debug_test_addr(&addr)) {
+						ast_verbose(" --- SDES LOC \n");
+					}
+					break;
+				case SDES_NOTE:
+					if (rtcp_debug_test_addr(&addr)) {
+						ast_verbose(" --- SDES NOTE \n");
+					}
+					break;
+				case SDES_PRIV:
+					if (rtcp_debug_test_addr(&addr)) {
+						ast_verbose(" --- SDES PRIV \n");
+					}
+					break;
+				case SDES_END:
+					if (rtcp_debug_test_addr(&addr)) {
+						ast_verbose(" --- SDES END \n");
+					}
+					break;
+				case SDES_APSI:
+					if (rtcp_debug_test_addr(&addr)) {
+						ast_verbose(" --- SDES APSI \n");
+					}
+					break;
+				}
+				j += 2 + sdeslength;	/* Header (1 byte) + length */
+				sdes += sdeslength;
+				if (sdestype == SDES_END) {
+					break;	/* The while loop */
+				}
+			}
+
 			break;
-		case RTCP_PT_BYE:
-			if (rtcp_debug_test_addr(&addr))
-				ast_verbose("Received a BYE from %s\n",
-					    ast_sockaddr_stringify(&rtp->rtcp->them));
+		case RTCP_PT_NACK:
+			if (rtcp_debug_test_addr(&addr)) {
+				ast_verbose("   Received a RTCP NACK from %s\n", ast_sockaddr_stringify(&rtp->rtcp->them));
+			}
 			break;
+ 		case RTCP_PT_BYE:
+			if (rtcp_debug_test_addr(&addr)) {
+				ast_verbose("   Received a RTCP BYE from %s\n", ast_sockaddr_stringify(&rtp->rtcp->them));
+			}
+ 			break;
+		case RTCP_PT_XR:
+			if (rtcp_debug_test_addr(&addr)) {
+				ast_verbose("   Received a RTCP Extended Report (XR) packet from %s\n", ast_sockaddr_stringify(&rtp->rtcp->them));
+			}
+			break;
+		case RTCP_PT_APP:
+			if (rtcp_debug_test_addr(&addr)) {
+				ast_verbose("   Received a RTCP APP packet from %s\n", ast_sockaddr_stringify(&rtp->rtcp->them));
+			}
+			break;
+		case RTCP_PT_IJ:
+			if (rtcp_debug_test_addr(&addr)) {
+				ast_verbose("   Received a RTCP IJ from %s\n", ast_sockaddr_stringify(&rtp->rtcp->them));
+			}
+			break;
 		default:
-			ast_debug(1, "Unknown RTCP packet (pt=%d) received from %s\n",
-				  pt, ast_sockaddr_stringify(&rtp->rtcp->them));
+			ast_debug(1, "Unknown RTCP packet (pt=%d) received from %s\n", pt, ast_sockaddr_stringify(&rtp->rtcp->them));
 			break;
 		}
 		position += (length + 1);
-	}
+	}	/* While loop */
 
+	/* OEJ CHECK next line */
 	rtp->rtcp->rtcp_info = 1;
 
 	return f;
@@ -2050,6 +2319,10 @@
 	struct ast_rtp_payload_type payload_type;
 	int reconstruct = ntohl(rtpheader[0]);
 	struct ast_sockaddr remote_address = { {0,} };
+	struct timeval rxtime;
+	unsigned int timestamp;
+	int rate;
+	unsigned int ms;
 
 	/* Get fields from packet */
 	payload = (reconstruct & 0x7f0000) >> 16;
@@ -2077,12 +2350,29 @@
 		ast_clear_flag(rtp, FLAG_NEED_MARKER_BIT);
 	}
 
+	/* Calculate timestamp for reception of the packet */
+	timestamp = ntohl(rtpheader[1]);
+	calc_rxstamp(&rxtime, rtp, timestamp, mark);
+
+ 	rate = rtp_get_rate(bridged_payload) / 1000;
+
+	/* Now, calculate tx timestamp */
+	ms = calc_txstamp(rtp, &rxtime);
+	if (bridged_payload == AST_FRAME_VOICE) {
+		bridged->lastts = bridged->lastts + ms * rate;
+	} else if (bridged_payload == AST_FRAME_VIDEO) {
+		bridged->lastts = bridged->lastts + ms * 90;
+		/* This is not exact, but a best effort example that can be improved */
+	}
+
 	/* Reconstruct part of the packet */
 	reconstruct &= 0xFF80FFFF;
 	reconstruct |= (bridged_payload << 16);
 	reconstruct |= (mark << 23);
 	rtpheader[0] = htonl(reconstruct);
 
+	bridged->lasttxformat = rtp->lastrxformat = bridged_payload;
+
 	ast_rtp_instance_get_remote_address(instance1, &remote_address);
 
 	if (ast_sockaddr_isnull(&remote_address)) {
@@ -2108,7 +2398,12 @@
 			ast_set_flag(bridged, FLAG_NAT_INACTIVE_NOWARN);
 		}
 		return 0;
-	} else if (rtp_debug_test_addr(&remote_address)) {
+	}
+
+	bridged->txcount++;
+	bridged->txoctetcount += (res - hdrlen);
+
+	if (rtp_debug_test_addr(&remote_address)) {
 		ast_verbose("Sent RTP P2P packet to %s (type %-2.2d, len %-6.6u)\n",
 			    ast_sockaddr_stringify(&remote_address),
 			    bridged_payload, len - hdrlen);
@@ -2154,7 +2449,7 @@
 
 	/* Make sure the data that was read in is actually enough to make up an RTP packet */
 	if (res < hdrlen) {
-		ast_log(LOG_WARNING, "RTP Read too short\n");
+		ast_log(LOG_WARNING, "RTP Read too short (%d expecting %d)\n", res, hdrlen);
 		return &ast_null_frame;
 	}
 
@@ -2235,10 +2530,6 @@
 		}
 	}
 
-	/* If we are directly bridged to another instance send the audio directly out */
-	if (ast_rtp_instance_get_bridged(instance) && !bridge_p2p_rtp_write(instance, rtpheader, res, hdrlen)) {
-		return &ast_null_frame;
-	}
 
 	/* If the version is not what we expected by this point then just drop the packet */
 	if (version != 2) {
@@ -2279,6 +2570,15 @@
 
 	rtp->rxssrc = ssrc;
 
+	/* Schedule RTCP report transmissions if possible */
+	ast_rtcp_schedule(instance);
+
+	/* This needs to be after RTCP calculations to get more RTCP data */
+	/* If we are directly bridged to another instance send the audio directly out */
+	if (ast_rtp_instance_get_bridged(instance) && !bridge_p2p_rtp_write(instance, rtpheader, res, hdrlen)) {
+		return &ast_null_frame;
+	}
+
 	/* Remove any padding bytes that may be present */
 	if (padding) {
 		res -= rtp->rawdata[AST_FRIENDLY_OFFSET + res - 1];
@@ -2724,6 +3024,45 @@
 	AST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_LOCAL_SSRC, -1, stats->local_ssrc, rtp->ssrc);
 	AST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_REMOTE_SSRC, -1, stats->remote_ssrc, rtp->themssrc);
 
+	AST_RTP_STAT_SET(AST_RTP_INSTANCE_STAT_START, -1, stats->start, rtp->start);
+	if (stat == AST_RTP_INSTANCE_STAT_IP || stat == AST_RTP_INSTANCE_STAT_ALL) {
+		memcpy(&stats->them, &rtp->rtcp->them, sizeof(stats->them));
+	}
+	if (stat == AST_RTP_INSTANCE_STAT_LOCAL_CNAME || stat == AST_RTP_INSTANCE_STAT_ALL) {
+		memcpy(&stats->ourcname, &rtp->rtcp->ourcname, rtp->rtcp->ourcnamelength);	/* UTF8 safe */
+		stats->ourcnamelength = rtp->rtcp->ourcnamelength;
+	}
+	if (stat == AST_RTP_INSTANCE_STAT_REMOTE_CNAME || stat == AST_RTP_INSTANCE_STAT_ALL) {
+		memcpy(&stats->theircname, &rtp->rtcp->theircname, rtp->rtcp->theircnamelength);	/* UTF8 safe */
+		stats->theircnamelength = rtp->rtcp->theircnamelength;
+	}
+
+	/* To fix */
+	stats->readcost = rtp->rtcp->readcost;
+        stats->writecost = rtp->rtcp->writecost;
+	stats->lasttxformat = rtp->lasttxformat;
+	stats->lastrxformat = rtp->lastrxformat;
+	if (!ast_strlen_zero(rtp->rtcp->readtranslator)) {
+		ast_copy_string(stats->readtranslator, rtp->rtcp->readtranslator, sizeof(stats->readtranslator));
+	}
+	if (!ast_strlen_zero(rtp->rtcp->writetranslator)) {
+		ast_copy_string(stats->writetranslator, rtp->rtcp->writetranslator, sizeof(stats->writetranslator));
+	}
+	if (!ast_strlen_zero(rtp->rtcp->readtranslator)) {
+		ast_copy_string(stats->readtranslator, rtp->rtcp->readtranslator, sizeof(stats->readtranslator));
+	}
+	if (!ast_strlen_zero(rtp->rtcp->channel)) {
+		ast_copy_string(stats->channel, rtp->rtcp->channel, sizeof(stats->channel));
+	}
+	if (!ast_strlen_zero(rtp->rtcp->bridgedchannel)) {
+		ast_copy_string(stats->bridgedchannel, rtp->rtcp->bridgedchannel, sizeof(stats->bridgedchannel));
+	}
+	if (!ast_strlen_zero(rtp->rtcp->uniqueid)) {
+		ast_copy_string(stats->uniqueid, rtp->rtcp->uniqueid, sizeof(stats->uniqueid));
+	}
+	if (!ast_strlen_zero(rtp->rtcp->bridgeduniqueid)) {
+		ast_copy_string(stats->bridgeduniqueid, rtp->rtcp->bridgeduniqueid, sizeof(stats->bridgeduniqueid));
+	}
 	return 0;
 }
 
@@ -2753,17 +3092,41 @@
 	ast_sockaddr_from_sin(suggestion, &suggestion_tmp);
 }
 
+/* \brief Put stream on/off hold, mute outbound RTP but keep
+	RTP keepalives and RTCP going
+ */
+static void ast_rtp_hold(struct ast_rtp_instance *instance, int status)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	if (status) {
+		ast_debug(1, "##### HOLDING RTCP, Have a nice day \n");
+		ast_set_flag(rtp, FLAG_HOLD);
+	} else {
+		/* CLEAR */
+		ast_debug(1, "##### UNHOLDING RTCP, You will get audio now. \n");
+		ast_clear_flag(rtp, FLAG_HOLD);
+	}
+}
+
 static void ast_rtp_stop(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	struct ast_sockaddr addr = { {0,} };
 
+	ast_debug(1, "##### Stopping RTP, Sending good bye \n");
+
+	/* Send RTCP goodbye packet */
+	if (rtp->isactive && rtp->rtcp) {
+		ast_rtcp_write_sr(instance, 1);
+		ast_debug(1, "##### Stopping RTCP, Sent good bye \n");
+	}
 	if (rtp->rtcp && rtp->rtcp->schedid > 0) {
 		if (!ast_sched_del(rtp->sched, rtp->rtcp->schedid)) {
 			/* successfully cancelled scheduler entry. */
 			ao2_ref(instance, -1);
 		}
 		rtp->rtcp->schedid = -1;
+		ast_debug(1, "##### Stopping RTCP, Removing scheduler \n");
 	}
 
 	if (rtp->red) {
@@ -2778,6 +3141,7 @@
 	}
 
 	ast_set_flag(rtp, FLAG_NEED_MARKER_BIT);
+	rtp->isactive = 0;
 }
 
 static int ast_rtp_qos_set(struct ast_rtp_instance *instance, int tos, int cos, const char *desc)
@@ -2787,6 +3151,91 @@
 	return ast_set_qos(rtp->s, tos, cos, desc);
 }
 
+
+/*! \brief set RTP cname used to describe session in RTCP sdes messages */
+void ast_rtcp_setcname(struct ast_rtp_instance *instance, const char *cname, size_t length)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+
+	if (!rtp || !rtp->rtcp) {
+		return;
+	}
+	if (length > 255) {
+		length=255;
+	}
+	ast_copy_string(rtp->rtcp->ourcname, cname, length+1);
+	rtp->rtcp->ourcnamelength = length;
+	if (option_debug > 3) {
+		ast_log(LOG_DEBUG, "--- Copied CNAME %s to RTCP structure (length %d)\n", cname, (int) length);
+	}
+}
+
+/*! \brief set the name of the bridged channel
+
+At the time when we write the report there might not be a bridge, so we need
+to store this so we can correlate the reports. If a channel changes bridge,
+it can be reset by first setting it to an empty string, then setting to 
+a new name 
+*/
+void ast_rtcp_set_bridged(struct ast_rtp_instance *instance, const char *channel, const char *uniqueid, const char *bridgedchan, const char *bridgeduniqueid)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+
+	if (!rtp) {		/* For some reason, there's no RTP */
+		ast_debug(1, "??????????????? NO RTP \n");
+		return;
+	}
+	if (!rtp->rtcp) {	/* No RTCP? Strange */
+		ast_debug(1, "??????????????? NO RTCP \n");
+		return;
+	}
+	/* If we already have data, don't replace it. 
+		NOTE: Should we replace it at a masquerade or something? Hmm.
+	*/
+	if (!ast_strlen_zero(channel) && !rtp->rtcp->channel[0]) {
+		ast_debug(1, "!!!!!! Setting channel name to %s\n", channel);
+		ast_copy_string(rtp->rtcp->channel, channel, sizeof(rtp->rtcp->channel));
+	}
+	if (!ast_strlen_zero(uniqueid) && !rtp->rtcp->uniqueid[0]) {
+		ast_debug(1, "!!!!!! Setting unique id to %s\n", uniqueid);
+		ast_copy_string(rtp->rtcp->uniqueid, uniqueid, sizeof(rtp->rtcp->uniqueid));
+	}
+	if (!ast_strlen_zero(bridgedchan)) {
+		ast_debug(1, "!!!!!! Setting bridged channel name to %s\n", bridgedchan);
+		ast_copy_string(rtp->rtcp->bridgedchannel, bridgedchan, sizeof(rtp->rtcp->bridgedchannel));
+	} else {
+		if(rtp->rtcp->bridgedchannel[0] != '\0') {
+			ast_debug(1, "!!!!!! Keeping bridged channel name %s\n", rtp->rtcp->bridgedchannel);
+		}
+		//rtp->rtcp->bridgedchan[0] = '\0';
+	}
+	if (!ast_strlen_zero(bridgeduniqueid)) {
+		ast_debug(1, "!!!!!! Setting bridged unique id to %s\n", bridgeduniqueid);
+		ast_copy_string(rtp->rtcp->bridgeduniqueid, bridgeduniqueid, sizeof(rtp->rtcp->bridgeduniqueid));
+	} else {
+		if(rtp->rtcp->bridgeduniqueid[0] != '\0') {
+			ast_debug(1, "!!!!!! Keeping bridged unique id \n");
+		}
+	}
+}
+
+
+/*! \brief Set the transcoding variables for the QoS reports */
+void ast_rtcp_set_translator(struct ast_rtp_instance *instance, const char *readtranslator, const int readcost, const char *writetranslator, const int writecost)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	if (!rtp || !rtp->rtcp) {
+		return;
+	}
+	ast_copy_string(rtp->rtcp->readtranslator, S_OR(readtranslator,""), sizeof(rtp->rtcp->readtranslator));
+	ast_copy_string(rtp->rtcp->writetranslator, S_OR(writetranslator,""), sizeof(rtp->rtcp->writetranslator));
+	rtp->rtcp->readcost = readcost;
+	rtp->rtcp->writecost = writecost;
+	
+}
+
+
+
 /*! \brief generate comfort noice (CNG) */
 static int ast_rtp_sendcng(struct ast_rtp_instance *instance, int level)
 {
@@ -2830,6 +3279,120 @@
 	return res;
 }
 
+/*! \brief Check if rtp stream is active */
+static int ast_rtp_isactive(struct ast_rtp_instance *instance)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	return rtp->isactive ? 0 : 1;
+}
+
+/*! \brief Basically add SSRC */
+static int add_sdes_header(struct ast_rtp *rtp, unsigned int *rtcp_packet, int len)
+{
+	/* 2 is version, 1 is number of chunks, then RTCP packet type (SDES) and length */
+	*rtcp_packet = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | ((len/4)-1));
+
+	rtcp_packet++;	/* Move 32 bits ahead for the header */
+	*rtcp_packet = htonl(rtp->ssrc);               /* Our SSRC */
+	rtcp_packet ++;
+
+	/* Header + SSRC */
+	return len + 8;
+}
+
+static int add_sdes_bodypart(struct ast_rtp *rtp, unsigned int *rtcp_packet, int len, int type)
+{
+	int cnamelen;
+	int sdeslen = 0;
+	char *sdes;
+
+	sdes = (char *) rtcp_packet;
+	switch (type) {
+	case SDES_CNAME:
+		cnamelen = (int) rtp->rtcp->ourcnamelength;
+
+		*sdes = SDES_CNAME;
+		sdes++;
+		*sdes = (char) cnamelen;
+		sdes++;
+		strncpy(sdes, rtp->rtcp->ourcname, cnamelen);	/* NO terminating 0 */
+
+		/* THere must be a multiple of four bytes in the packet */
+		sdeslen = cnamelen;
+		break;
+	case SDES_END:
+		*sdes = SDES_END;
+		sdes++;
+		*sdes = (char) 0;
+		sdes++;
+		sdeslen = 2;
+	}
+	len += sdeslen + (sdeslen % 4 == 0 ? 0 : 4 - (sdeslen % 4)) ;
+
+	return len;
+}
+
+/*! \brief Send emtpy RTCP receiver's report and SDES message 
+ 	Mainly used to open NAT sessions  */
+static int ast_rtcp_write_empty_frame(struct ast_rtp_instance *instance)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+	char bdata[512];
+	unsigned int *rtcpheader, *start;
+	int fd, len, res;
+
+	if (!rtp || !rtp->rtcp) {
+		return 0;
+	} 
+	ast_debug(1,  "************ ---- About to send empty RTCP packet\n");
+	fd = rtp->rtcp->s;
+	
+	if (fd == -1) {
+		ast_debug(1, "--- No file descriptor to use \n");
+	}
+	
+	if (!ast_sockaddr_isnull(&rtp->rtcp->them)) { /* This'll stop rtcp for this rtp session */
+		ast_verbose("RTCP SR transmission error, rtcp halted\n");
+		AST_SCHED_DEL(rtp->sched, rtp->rtcp->schedid);
+		return 0;
+	}
+	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
+		ast_debug(1,  "---- About to send empty RTCP packet\n");
+	}
+	rtcpheader = (unsigned int *)bdata;
+	/* Add a RR header with no reports (chunks = 0) - The RFC says that it's always needed 
+		first in a compound packet.
+	 */
+	rtcpheader[0] = htonl((2 << 30) | (0 << 24) | (RTCP_PT_RR << 16) | 1);
+	rtcpheader[1] = htonl(rtp->ssrc);
+	len = 8;
+	start = &rtcpheader[len/4];
+	len +=8; /* SKip header for now */
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_CNAME);
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_END);
+	/* Now, add header when we know the actual length */
+	add_sdes_header(rtp, start, len);
+
+	res = sendto(fd, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&rtp->rtcp->them, sizeof(rtp->rtcp->them));
+
+	if (res < 0) {
+		ast_log(LOG_ERROR, "RTCP RR transmission error, rtcp halted: %s\n",strerror(errno));
+		/* Remove the scheduler */
+		AST_SCHED_DEL(rtp->sched, rtp->rtcp->schedid);
+		return 0;
+	}
+
+	rtp->rtcp->rr_count++;
+
+	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
+		ast_verbose("\n* Sending Empty RTCP RR to %s  Our SSRC: %u\n",
+			ast_sockaddr_stringify(&rtp->rtcp->them),
+			rtp->ssrc);
+	}
+
+	return res;
+}
+
 static char *rtp_do_debug_ip(struct ast_cli_args *a)
 {
 	char *arg = ast_strdupa(a->argv[4]);
@@ -2841,8 +3404,7 @@
 		return CLI_FAILURE;
 	}
 	rtpdebugport = (!ast_strlen_zero(debugport) && debugport[0] != '0');
-	ast_cli(a->fd, "RTP Debugging Enabled for address: %s\n",
-		ast_sockaddr_stringify(&rtpdebugaddr));
+	ast_cli(a->fd, "RTP Debugging Enabled for address: %s\n", ast_sockaddr_stringify(&rtpdebugaddr));
 	rtpdebug = 1;
 	return CLI_SUCCESS;
 }
