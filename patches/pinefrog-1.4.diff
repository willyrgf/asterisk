Index: channels/chan_sip.c
===================================================================
--- channels/chan_sip.c	(.../branches/1.4)	(revision 382456)
+++ channels/chan_sip.c	(.../team/oej/pinefrog-1.4)	(revision 382456)
@@ -478,6 +478,13 @@
 	{ SIP_OPT_RESPRIORITY,	NOT_SUPPORTED,	"resource-priority" },
 };
 
+/*! Media types for declaration of RTP streams */
+enum media_type {
+	SDP_AUDIO,	/* AUDIO class */
+	SDP_VIDEO,
+	SDP_IMAGE,
+/* For later versions that 1.4 we need to add SDP_TEXT for T.140 */
+};
 
 /*! \brief SIP Methods we support */
 #define ALLOWED_METHODS "INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, SUBSCRIBE, NOTIFY, INFO"
@@ -574,6 +581,8 @@
 static char global_useragent[AST_MAX_EXTENSION];	/*!< Useragent for the SIP channel */
 static int allow_external_domains;	/*!< Accept calls to external SIP domains? */
 static int global_callevents;		/*!< Whether we send manager events or not */
+static int global_rtcpevents;		/*!< Whether we send manager RTCP events or not */
+static int global_rtcptimer;		/*!< How often, during a call, to report RTCP stats */
 static int global_t1min;		/*!< T1 roundtrip time minimum */
 static int global_autoframing;          /*!< Turn autoframing on or off. */
 static enum transfermodes global_allowtransfer;	/*!< SIP Refer restriction scheme */
@@ -1042,6 +1051,7 @@
 	int initid;				/*!< Auto-congest ID if appropriate (scheduler) */
 	int waitid;				/*!< Wait ID for scheduler after 491 or other delays */
 	int autokillid;				/*!< Auto-kill ID (scheduler) */
+	int rtcpeventid;			/*!< Scheduler ID for RTCP Events */
 	enum transfermodes allowtransfer;	/*!< REFER: restriction scheme */
 	struct sip_refer *refer;		/*!< REFER: SIP transfer data structure */
 	enum subscriptiontype subscribed;	/*!< SUBSCRIBE: Is this dialog a subscription?  */
@@ -1068,6 +1078,8 @@
 	struct sip_invite_param *options;	/*!< Options for INVITE */
 	int autoframing;
 	int hangupcause;			/*!< Storage of hangupcause copied from our owner before we disconnect from the AST channel (only used at hangup) */
+	struct ast_rtp_quality *audioqual;		/*!< Audio: The latest quality report, for realtime storage */
+	struct ast_rtp_quality *videoqual;		/*!< Video: The latest quality report, for realtime storage */
 	/*! When receiving an SDP offer, it is important to take note of what media types were offered.
 	 * By doing this, even if we don't want to answer a particular media stream with something meaningful, we can
 	 * still put an m= line in our answer with the port set to 0.
@@ -1421,7 +1433,11 @@
 				char **m_buf, size_t *m_size, char **a_buf, size_t *a_size,
 				int debug);
 static enum sip_result add_sdp(struct sip_request *resp, struct sip_pvt *p, int add_audio, int add_t38);
+static int send_rtcp_events(const void *data);
+static void start_rtcp_events(struct sip_pvt *dialog);
+static void sip_rtcp_report(struct sip_pvt *p, struct ast_rtp *rtp, enum media_type type, int reporttype);
 static void stop_media_flows(struct sip_pvt *p);
+static void qos_write_realtime(struct sip_pvt *dialog, struct ast_rtp_quality *qual);
 
 /*--- Authentication stuff */
 static int reply_digest(struct sip_pvt *p, struct sip_request *req, char *header, int sipmethod, char *digest, int digest_len);
@@ -2754,9 +2770,12 @@
 	if (option_debug > 2)
 		ast_log(LOG_DEBUG, "Destroying SIP peer %s\n", peer->name);
 
+
 	/* Delete it, it needs to disappear */
-	if (peer->call)
+	if (peer->call) {
 		sip_destroy(peer->call);
+		peer->call = NULL;
+	}
 
 	if (peer->mwipvt) 	/* We have an active subscription, delete it */
 		sip_destroy(peer->mwipvt);
@@ -3441,11 +3460,25 @@
 	if (dumphistory)
 		sip_dump_history(p);
 
+	if (p->audioqual) {
+		/* We have a quality report to write to realtime before we leave this world. */
+		qos_write_realtime(p, p->audioqual);
+		free(p->audioqual);
+		p->audioqual = NULL;
+	}
+	if (p->videoqual) {
+		/* We have a quality report to write to realtime before we leave this world. */
+		qos_write_realtime(p, p->videoqual);
+		free(p->videoqual);
+		p->videoqual = NULL;
+	}
+
 	if (p->options)
 		free(p->options);
 
 	if (p->stateid > -1)
 		ast_extension_state_del(p->stateid, NULL);
+	AST_SCHED_DEL(sched, p->rtcpeventid);
 
 	/* remove any pending extension notify that could be left in
 	 * the extension update queue relating to this dialog. */
@@ -3957,10 +3990,12 @@
 			if (!p->pendinginvite) {
 				char *audioqos = "";
 				char *videoqos = "";
-				if (p->rtp)
-					audioqos = ast_rtp_get_quality(p->rtp, NULL);
-				if (p->vrtp)
-					videoqos = ast_rtp_get_quality(p->vrtp, NULL);
+				if (p->rtp) {
+					audioqos = ast_rtp_get_quality(p->rtp);
+				}
+				if (p->vrtp) {
+					videoqos = ast_rtp_get_quality(p->vrtp);
+				}
 				/* Send a hangup */
 				if (oldowner->_state == AST_STATE_UP) {
 					transmit_request_with_auth(p, SIP_BYE, 0, XMIT_RELIABLE, 1);
@@ -4035,6 +4070,7 @@
 		ast_rtp_new_source(p->rtp);
 		res = transmit_response_with_sdp(p, "200 OK", &p->initreq, XMIT_CRITICAL);
 		ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
+		start_rtcp_events(p);
 	}
 	ast_mutex_unlock(&p->lock);
 	return res;
@@ -4846,6 +4882,7 @@
 	ast_mutex_init(&p->lock);
 
 	p->method = intended_method;
+	p->rtcpeventid = -1;
 	p->initid = -1;
 	p->waitid = -1;
 	p->autokillid = -1;
@@ -4877,8 +4914,9 @@
 	if (sip_methods[intended_method].need_rtp) {
 		p->rtp = ast_rtp_new_with_bindaddr(sched, io, 1, 0, bindaddr.sin_addr);
 		/* If the global videosupport flag is on, we always create a RTP interface for video */
-		if (ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT))
+		if (ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT)) {
 			p->vrtp = ast_rtp_new_with_bindaddr(sched, io, 1, 0, bindaddr.sin_addr);
+		}
 		if (ast_test_flag(&p->flags[1], SIP_PAGE2_T38SUPPORT))
 			p->udptl = ast_udptl_new_with_bindaddr(sched, io, 0, bindaddr.sin_addr);
 		if (!p->rtp || (ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) && !p->vrtp)) {
@@ -4936,6 +4974,12 @@
 	else
 		ast_string_field_set(p, callid, callid);
 	/* Assign default music on hold class */
+	if (p->rtp) {
+		ast_rtcp_setcname(p->rtp, p->callid, strlen(p->callid));
+	}
+	if (p->vrtp) {
+		ast_rtcp_setcname(p->vrtp, p->callid, strlen(p->callid));
+	}
 	ast_string_field_set(p, mohinterpret, default_mohinterpret);
 	ast_string_field_set(p, mohsuggest, default_mohsuggest);
 	p->capability = global_capability;
@@ -5603,11 +5647,6 @@
 	return;
 }
 
-enum media_type {
-	SDP_AUDIO,
-	SDP_VIDEO,
-	SDP_IMAGE,
-};
 
 static int get_ip_and_port_from_sdp(struct sip_request *req, const enum media_type media, struct sockaddr_in *sin)
 {
@@ -12019,6 +12058,10 @@
 	int realtimepeers;
 	int realtimeusers;
 	char codec_buf[SIPBUFSIZE];
+	int realtimertpqos = FALSE;
+#ifdef REALTIME2
+	realtimertpqos = ast_check_realtime("rtpqos");
+#endif
 
 	realtimepeers = ast_check_realtime("sippeers");
 	realtimeusers = ast_check_realtime("sipusers");
@@ -12050,6 +12093,8 @@
 	ast_cli(fd, "  From: Domain:           %s\n", default_fromdomain);
 	ast_cli(fd, "  Record SIP history:     %s\n", recordhistory ? "On" : "Off");
 	ast_cli(fd, "  Call Events:            %s\n", global_callevents ? "On" : "Off");
+	ast_cli(fd, "  RTCP Events:            %s\n", global_rtcpevents ? "On" : "Off");
+	ast_cli(fd, "  RTCP Event timer:       %d\n", global_rtcptimer);
 	ast_cli(fd, "  IP ToS SIP:             %s\n", ast_tos2str(global_tos_sip));
 	ast_cli(fd, "  IP ToS RTP audio:       %s\n", ast_tos2str(global_tos_audio));
 	ast_cli(fd, "  IP ToS RTP video:       %s\n", ast_tos2str(global_tos_video));
@@ -12063,6 +12108,7 @@
 		ast_cli(fd, "  SIP realtime:           Disabled\n" );
 	else
 		ast_cli(fd, "  SIP realtime:           Enabled\n" );
+	ast_cli(fd, "  QOS realtime reports:   %s\n", realtimertpqos ? "Enabled" : "Disabled" );
 
 	ast_cli(fd, "\nGlobal Signalling Settings:\n");
 	ast_cli(fd, "---------------------------\n");
@@ -13650,6 +13696,7 @@
 		ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
 		xmitres = transmit_request(p, SIP_ACK, seqno, XMIT_UNRELIABLE, TRUE);
 		check_pendings(p);
+		start_rtcp_events(p);
 		break;
 	case 407: /* Proxy authentication */
 	case 401: /* Www auth */
@@ -14046,14 +14093,286 @@
 	}
 }
 
+/*! \brief send manager report of RTCP 
+	reporttype = 0  means report during call (if configured)
+	reporttype = 1  means endof-call (hangup) report
+	reporttype = 10  means report at end of call leg (like transfer)
+*/
+static void sip_rtcp_report(struct sip_pvt *p, struct ast_rtp *rtp, enum media_type type, int reporttype)
+{
+	struct ast_rtp_quality *qual;
+	char *rtpqstring = NULL;
+	int qosrealtime = ast_check_realtime("rtpqos");
+	unsigned int duration;	/* Duration in secs */
+ 	int readtrans = FALSE, writetrans = FALSE;
+
+	memset(&qual, sizeof(qual), 0);
+  
+	if (p && p->owner) {
+		struct ast_channel *bridgepeer = ast_bridged_channel(p->owner);
+		if (bridgepeer) {
+			/* Store the bridged peer data while we have it */
+			ast_rtcp_set_bridged(rtp, p->owner->name, p->owner->uniqueid, S_OR(bridgepeer->name,""), S_OR(bridgepeer->uniqueid,""));
+			ast_log(LOG_DEBUG, "---- Setting bridged peer name to %s\n", bridgepeer->name);
+		} else {
+			ast_rtcp_set_bridged(rtp, p->owner->name, p->owner->uniqueid, NULL, NULL);
+		}
+
+ 		/* Try to find out if there's active transcoding */
+		/* Currently, the only media stream that has translation is the audio stream. At some point
+		   we might have transcoding for other types of media. */
+		if (type == SDP_AUDIO) {
+			/* if we have a translator, the bridge delay is increased, which affects the QoS of the call.  */
+ 			readtrans = p->owner->readtrans != NULL;
+ 			writetrans = p->owner->writetrans != NULL;
+			ast_rtcp_settranslator(rtp, readtrans ? p->owner->readtrans->t->name : NULL, readtrans ? p->owner->readtrans->t->cost : 0,
+					writetrans ? p->owner->writetrans->t->name : NULL, writetrans ? p->owner->writetrans->t->cost : 0);
+		
+			if (option_debug > 1) {
+ 				if (readtrans && p->owner->readtrans->t) {
+ 					ast_log(LOG_DEBUG, "--- Audio Read translator: %s Cost %d\n", p->owner->readtrans->t->name, p->owner->readtrans->t->cost);
+ 				}
+ 				if (writetrans && p->owner->writetrans->t) {
+ 					ast_log(LOG_DEBUG, "--- Audio Write translator: %s Cost %d\n", p->owner->writetrans->t->name, p->owner->writetrans->t->cost);
+ 				}
+			}
+		}
+
+	}
+
+	rtpqstring =  ast_rtp_get_quality(rtp);
+	qual = ast_rtp_get_qualdata(rtp);
+	if (!qual) {
+		/* Houston, we got a problem */
+		return;
+	}
+	
+	if (global_rtcpevents) {
+		/* 
+		   If numberofreports == 0 we have no incoming RTCP active, thus we can't
+		   get any reliable data to handle packet loss or any RTT timing.
+		*/
+
+		duration = (unsigned int)(ast_tvdiff_ms(ast_tvnow(), qual->start) / 1000);
+		manager_event(EVENT_FLAG_CALL, "RTPQuality", 
+			"Channel: %s\r\n"			/* AST_CHANNEL for this call */
+			"Uniqueid: %s\r\n"			/* AST_CHANNEL for this call */
+			"BridgedChannel: %s\r\n"
+			"BridgedUniqueid: %s\r\n"
+			"RTPreporttype: %s\r\n"
+			"RTPrtcpstatus: %s\r\n"
+			"Duration: %u\r\n"		/* used in cdr_manager */
+			"PvtCallid: %s\r\n"		/* ??? Generic PVT identifier */
+			"RTPipaddress: %s\r\n"
+			"RTPmedia: %s\r\n"		/* Audio, video, text */
+			"RTPsendformat: %s\r\n"
+			"RTPrecvformat: %s\r\n"
+			"RTPlocalssrc: %u\r\n"
+			"RTPremotessrc: %u\r\n"
+			"RTPrtt: %f\r\n"
+			"RTPrttMax: %f\r\n"
+			"RTPrttMin: %f\r\n"
+			"RTPLocalJitter: %f\r\n"
+			"RTPRemoteJitter: %f\r\n" 
+			"RTPInPacketLoss: %d\r\n" 
+			"RTPInLocalPlPercent: %5.2f\r\n"
+			"RTPOutPacketLoss: %d\r\n"
+			"RTPOutPlPercent: %5.2f\r\n"
+			"TranslateRead: %s\r\n"
+			"TranslateReadCost: %d\r\n"
+			"TranslateWrite: %s\r\n"
+			"TranslateWriteCost: %d\r\n"
+			"\r\n", 
+			p->owner ? p->owner->name : "",
+			p->owner ? p->owner->uniqueid : "",
+			qual->bridgedchan[0] ? qual->bridgedchan : "" ,
+			qual->bridgeduniqueid[0] ? qual->bridgeduniqueid : "",
+			reporttype == 1 ? "Final" : "Update",
+			qual->numberofreports == 0 ? "Inactive" : "Active",
+			duration,
+			p->callid, 
+			ast_inet_ntoa(qual->them.sin_addr), 	
+			type == SDP_AUDIO ? "audio" : (type == SDP_VIDEO ? "video" : "fax") ,
+			ast_getformatname(qual->lasttxformat),
+			ast_getformatname(qual->lastrxformat),
+			qual->local_ssrc, 
+			qual->remote_ssrc,
+			qual->rtt,
+			qual->rttmax,
+			qual->rttmin,
+			qual->local_jitter,
+			qual->remote_jitter,
+			qual->local_lostpackets,
+			/* The local counter of lost packets in inbound stream divided with received packets plus lost packets */
+			(qual->remote_count + qual->local_lostpackets) > 0 ? (double) qual->local_lostpackets / (qual->remote_count + qual->local_lostpackets) * 100 : 0,
+			qual->remote_lostpackets,
+			/* The remote counter of lost packets (if we got the reports)
+			   divided with our counter of sent packets
+			 */
+			(qual->local_count + qual->remote_lostpackets) > 0 ? (double) qual->remote_lostpackets / qual->local_count  * 100 : 0,
+			qual->readtranslator, qual->readcost,
+			qual->writetranslator, qual->writecost
+		);
+	}
+
+	/* CDR records are not reliable when it comes to near-death-of-channel events, so we need to store the RTCP
+	   report in realtime when we have it.
+	   Tests have proven that storing to realtime from the call thread is NOT a good thing. Therefore, we just save
+	   the quality report structure in the PVT and let the function that kills the pvt store the stuff in the
+	   monitor thread instead.
+	 */
+	if (reporttype == 1 {
+		if (type == SDP_AUDIO) {  /* Audio */
+			p->audioqual = ast_calloc(sizeof(struct ast_rtp_quality), 1);
+			(* p->audioqual) = *qual;
+			p->audioqual->end = ast_tvnow();
+ 			p->audioqual->mediatype = type;
+		} else if (type == SDP_VIDEO) {  /* Video */
+			p->videoqual = ast_calloc(sizeof(struct ast_rtp_quality), 1);
+			(* p->videoqual) = *qual;
+ 			p->videoqual->mediatype = type;
+			p->videoqual->end = ast_tvnow();
+		}
+	}
+}
+
+/*! \brief Write quality report to realtime storage */
+void qos_write_realtime(struct sip_pvt *dialog, struct ast_rtp_quality *qual)
+{
+	unsigned int duration;	/* Duration in secs */
+	char buf_duration[10], buf_lssrc[30], buf_rssrc[30];
+	char buf_rtt[10], buf_rttmin[10], buf_rttmax[10];
+	char localjitter[10], remotejitter[10];
+	char buf_readcost[5], buf_writecost[5];
+	char buf_mediatype[10];
+	char buf_remoteip[25];
+	char buf_inpacketloss[25], buf_outpacketloss[25];
+	char buf_outpackets[25], buf_inpackets[25];
+
+	/* Since the CDR is already gone, we need to calculate our own duration.
+	   The CDR duration is the definitive resource for billing, this is
+	   the RTP stream duration which may include early media (ringing and
+	   provider messages). Only useful for measurements.
+	 */
+	if (!ast_tvzero(qual->end)) {
+		duration = (unsigned int)(ast_tvdiff_ms(qual->end, qual->start) / 1000);
+	} else {
+		duration = 0;
+	}
+
+	/* Realtime is based on strings, so let's make strings */
+	sprintf(localjitter, "%f", qual->local_jitter);
+	sprintf(remotejitter, "%f", qual->remote_jitter);
+	sprintf(buf_lssrc, "%u", qual->local_ssrc);
+	sprintf(buf_rssrc, "%u", qual->remote_ssrc);
+	sprintf(buf_rtt, "%.0f", qual->rtt);
+	sprintf(buf_rttmax, "%.0f", qual->rttmax);
+	sprintf(buf_rttmin, "%.0f", qual->rttmin);
+	sprintf(buf_duration, "%u", duration);
+	sprintf(buf_readcost, "%d", qual->readcost);
+	sprintf(buf_writecost, "%d", qual->writecost);
+	sprintf(buf_mediatype,"%s", qual->mediatype == SDP_AUDIO ? "audio" : (qual->mediatype == SDP_VIDEO ? "video" : "fax") );
+	sprintf(buf_remoteip,"%s", ast_inet_ntoa(qual->them.sin_addr));
+	sprintf(buf_inpacketloss, "%d", qual->local_lostpackets);
+	sprintf(buf_outpacketloss, "%d", qual->remote_lostpackets);
+	sprintf(buf_inpackets, "%d", qual->remote_count);	/* Do check again */
+	sprintf(buf_outpackets, "%d", qual->local_count);
+
+	ast_log(LOG_NOTICE,"RTPQOS Channel: %s Uid %s Bch %s Buid %s Pvt %s Media %s Lssrc %s Rssrc %s Rip %s Rtt %s:%s:%s Ljitter %s Rjitter %s Rtcpstatus %s Dur %s Pout %s Plossout %s Pin %s Plossin %s\n",
+		qual->channel[0] ? qual->channel : "",
+		qual->uniqueid[0] ? qual->uniqueid : "",
+		qual->bridgedchan[0] ? qual->bridgedchan : "" ,
+		qual->bridgeduniqueid[0] ? qual->bridgeduniqueid : "",
+		dialog->callid,
+		buf_mediatype,
+		buf_lssrc,
+		buf_rssrc,
+		buf_remoteip,
+		buf_rtt, buf_rttmax, buf_rttmin,
+		localjitter,
+		remotejitter,
+		qual->numberofreports == 0 ? "Inactive" : "Active",
+		buf_duration,
+		buf_outpackets,
+		buf_outpacketloss,
+		buf_inpackets,
+		buf_inpacketloss);
+
+#ifdef REALTIME2
+	ast_store_realtime("rtpqos", 
+		"channel", qual->channel[0] ? qual->channel : "--no channel--",
+		"uniqueid", qual->uniqueid[0] ? qual->uniqueid : "--no uniqueid --",
+		"bridgedchan", qual->bridgedchan[0] ? qual->bridgedchan : "" ,
+		"bridgeduniqueid", qual->bridgeduniqueid[0] ? qual->bridgeduniqueid : "",
+		"pvtcallid", dialog->callid, 
+		"rtpmedia", buf_mediatype, 
+		"localssrc", buf_lssrc, 
+		"remotessrc", buf_rssrc,
+		"remoteip", buf_remoteip,
+		"rtt", buf_rtt, 
+		"rttmax", buf_rttmax, 
+		"rttmin", buf_rttmin, 
+		"localjitter", localjitter, 
+		"remotejitter", remotejitter, 
+		"sendformat", ast_getformatname(qual->lasttxformat),
+		"receiveformat", ast_getformatname(qual->lastrxformat),
+		"rtcpstatus", qual->numberofreports == 0 ? "Inactive" : "Active",
+		"duration", buf_duration,
+		"writetranslator", qual->writetranslator[0] ? qual->writetranslator : "",
+		"writecost", buf_writecost,
+		"readtranslator", qual->readtranslator[0] ? qual->readtranslator : "",
+		"readcost", buf_readcost,
+		"packetlossin", buf_inpacketloss,
+		"packetlossout", buf_outpacketloss,
+		"packetsent", buf_outpackets,
+		"packetreceived", buf_inpackets,
+		NULL);
+#endif
+}
+
+/*! \brief Send RTCP manager events */
+static int send_rtcp_events(const void *data)
+{
+	struct sip_pvt *dialog = (struct sip_pvt *) data;
+
+	if (dialog->rtp && ast_rtp_isactive(dialog->rtp)) {
+		sip_rtcp_report(dialog, dialog->rtp, SDP_AUDIO, FALSE);
+	}
+	if (dialog->vrtp && ast_rtp_isactive(dialog->vrtp)) {
+		sip_rtcp_report(dialog, dialog->vrtp, SDP_VIDEO, FALSE);
+	}
+	return global_rtcptimer;
+}
+
+/*! \brief Activate RTCP events at start of call */
+static void start_rtcp_events(struct sip_pvt *dialog)
+{
+	if (!global_rtcpevents || !global_rtcptimer) {
+		return;
+	}
+	/* Check if it's already active */
+	if (dialog->rtcpeventid != -1) {
+		return;
+	}
+
+	/*! \brief Schedule events */
+	dialog->rtcpeventid = ast_sched_add(sched, global_rtcptimer * 1000, send_rtcp_events, dialog);
+}
+
+
 /*! \brief Immediately stop RTP, VRTP and UDPTL as applicable */
 static void stop_media_flows(struct sip_pvt *p)
 {
+
 	/* Immediately stop RTP, VRTP and UDPTL as applicable */
-	if (p->rtp)
+	if (p->rtp && ast_rtp_isactive(p->rtp)) {
 		ast_rtp_stop(p->rtp);
-	if (p->vrtp)
+		sip_rtcp_report(p, p->rtp, SDP_AUDIO, TRUE);
+	}
+	if (p->vrtp && ast_rtp_isactive(p->vrtp)) {
 		ast_rtp_stop(p->vrtp);
+		sip_rtcp_report(p, p->vrtp, SDP_VIDEO, TRUE);
+	}
 	if (p->udptl)
 		ast_udptl_stop(p->udptl);
 }
@@ -16523,9 +16842,10 @@
 
 static int acf_channel_read(struct ast_channel *chan, char *funcname, char *preparse, char *buf, size_t buflen)
 {
-	struct ast_rtp_quality qos;
 	struct sip_pvt *p = chan->tech_pvt;
 	char *all = "", *parse = ast_strdupa(preparse);
+	struct ast_rtp_quality *qos;
+
 	AST_DECLARE_APP_ARGS(args,
 		AST_APP_ARG(param);
 		AST_APP_ARG(type);
@@ -16549,36 +16869,41 @@
 		args.field = "all";
 
 	memset(buf, 0, buflen);
-	memset(&qos, 0, sizeof(qos));
 
 	if (p == NULL) {
 		return -1;
 	}
 
 	if (strcasecmp(args.type, "AUDIO") == 0) {
-		all = ast_rtp_get_quality(p->rtp, &qos);
+		all = ast_rtp_get_quality(p->rtp);
+		qos = ast_rtp_get_qualdata(p->rtp);
 	} else if (strcasecmp(args.type, "VIDEO") == 0) {
-		all = ast_rtp_get_quality(p->vrtp, &qos);
+		all = ast_rtp_get_quality(p->vrtp);
+		qos = ast_rtp_get_qualdata(p->vrtp);
+	} else {
+		ast_log(LOG_WARNING, "Unrecognized stream '%s in call to %s'\n", args.typecname, funcname);
+		return -1;
+		
 	}
 
 	if (strcasecmp(args.field, "local_ssrc") == 0)
-		snprintf(buf, buflen, "%u", qos.local_ssrc);
+		snprintf(buf, buflen, "%u", qos->local_ssrc);
 	else if (strcasecmp(args.field, "local_lostpackets") == 0)
-		snprintf(buf, buflen, "%u", qos.local_lostpackets);
+		snprintf(buf, buflen, "%u", qos->local_lostpackets);
 	else if (strcasecmp(args.field, "local_jitter") == 0)
-		snprintf(buf, buflen, "%.0lf", qos.local_jitter * 1000.0);
+		snprintf(buf, buflen, "%.0lf", qos->local_jitter * 1000.0);
 	else if (strcasecmp(args.field, "local_count") == 0)
-		snprintf(buf, buflen, "%u", qos.local_count);
+		snprintf(buf, buflen, "%u", qos->local_count);
 	else if (strcasecmp(args.field, "remote_ssrc") == 0)
-		snprintf(buf, buflen, "%u", qos.remote_ssrc);
+		snprintf(buf, buflen, "%u", qos->remote_ssrc);
 	else if (strcasecmp(args.field, "remote_lostpackets") == 0)
-		snprintf(buf, buflen, "%u", qos.remote_lostpackets);
+		snprintf(buf, buflen, "%u", qos->remote_lostpackets);
 	else if (strcasecmp(args.field, "remote_jitter") == 0)
-		snprintf(buf, buflen, "%.0lf", qos.remote_jitter * 1000.0);
+		snprintf(buf, buflen, "%.0lf", qos->remote_jitter * 1000.0);
 	else if (strcasecmp(args.field, "remote_count") == 0)
-		snprintf(buf, buflen, "%u", qos.remote_count);
+		snprintf(buf, buflen, "%u", qos->remote_count);
 	else if (strcasecmp(args.field, "rtt") == 0)
-		snprintf(buf, buflen, "%.0lf", qos.rtt * 1000.0);
+		snprintf(buf, buflen, "%.0lf", qos->rtt * 1000.0);
 	else if (strcasecmp(args.field, "all") == 0)
 		ast_copy_string(buf, all, buflen);
 	else {
@@ -16611,14 +16936,14 @@
 	if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY) || p->owner) {
 		char *audioqos, *videoqos;
 		if (p->rtp) {
-			audioqos = ast_rtp_get_quality(p->rtp, NULL);
+			audioqos = ast_rtp_get_quality(p->rtp);
 			if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY))
 				append_history(p, "RTCPaudio", "Quality:%s", audioqos);
 			if (p->owner)
 				pbx_builtin_setvar_helper(p->owner, "RTPAUDIOQOS", audioqos);
 		}
 		if (p->vrtp) {
-			videoqos = ast_rtp_get_quality(p->vrtp, NULL);
+			videoqos = ast_rtp_get_quality(p->vrtp);
 			if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY))
 				append_history(p, "RTCPvideo", "Quality:%s", videoqos);
 			if (p->owner)
@@ -19120,6 +19445,8 @@
 	/* Misc settings for the channel */
 	global_relaxdtmf = FALSE;
 	global_callevents = FALSE;
+	global_rtcpevents = FALSE;
+	global_rtcptimer = 0;	/* Only report at end of call (if enabled) */
 	global_t1min = DEFAULT_T1MIN;
 	global_shrinkcallerid = 1;
 
@@ -19366,6 +19693,13 @@
 				ast_log(LOG_WARNING, "Qualification default should be 'yes', 'no', or a number of milliseconds at line %d of sip.conf\n", v->lineno);
 				default_qualify = 0;
 			}
+		} else if (!strcasecmp(v->name, "rtcpevents")) {
+			global_rtcpevents = ast_true(v->value);
+		} else if (!strcasecmp(v->name, "rtcpeventtimer")) {
+			if (sscanf(v->value, "%30d", &global_rtcptimer) != 1) {
+				ast_log(LOG_WARNING, "RTCP event timer needs to be value (seconds between reports) at line %d of sip.conf\n", v->lineno);
+				global_rtcptimer = 0;
+			}
 		} else if (!strcasecmp(v->name, "callevents")) {
 			global_callevents = ast_true(v->value);
 		} else if (!strcasecmp(v->name, "maxcallbitrate")) {
Index: README.pinefrog-rtcp
===================================================================
--- README.pinefrog-rtcp	(.../branches/1.4)	(revision 0)
+++ README.pinefrog-rtcp	(.../team/oej/pinefrog-1.4)	(revision 382456)
@@ -0,0 +1,97 @@
+Olle E. Johansson
+oej@edvina.net
+
+
+
+
+
+
+Pinefrog - RTCP cleanup and additions
+-------------------------------------
+
+RTCP, as defined in RFC 3550, is a protocol that co-exists with RTP, the protocol used
+for realtime multimedia in VoIP. RTCP gives the endpoints a tool to exchange data about
+the media streams exchanged. As a result, both ends can get informaiton about the
+latency for data sent in both directions, packet loss and jitter for each media stream.
+
+A VoIP call is at least two media streams and they can have different properties in
+regards of quality. A router or switch in the middle could have a lot of outbound traffic,
+causing delays and possible packet loss. This might not affect inbound traffic.
+
+In Asterisk, the RTCP handler is part of the RTP module. The RTP module produces RTCP
+report that can be added to channel variables, cdr logs or sent through AMI.
+
+In 1.4, the data used is mostly based on the latest report, it's not aggregated. This
+is fixed in trunk.
+
+In both implementations (and the 1.6 releases in between) the RTCP support is not
+very complete.
+
+- It doesn't handle RTCP SDES packets
+- It doesn't send RTCP END packets at end of session
+- It doesn't handle receiving END packets
+- It doesn't handle re-invites in a good way.
+- It seems to mix sender and receiver reports, thus mixing data from two streams 
+    - when does this happen, if at all?
+
+RTCP and NAT
+------------
+I suspect that RTCP doesn't traverse NAT very well in our implementation. For RTP,
+we start with sending media to probe NAT. I've added emtpy RTCP RR+SDES CNAME packets
+to start probing a NAT (if Asterisk is behind a NAT). I am afraid that very few devices
+do that early on.
+The idea is (like RTP)
+ - Send a few RTCP packets in the start of the session.
+ - The receiver can then apply symmetric RTCP and start sending to the NAT outside port
+   that we're sending from and we'll get their packets.
+
+Todo
+----
+- When CNAME changes, we have a different stream and need to restart the stats.
+  Should we add ability to produce multiple RTCP reports for one "call" and aggregate them?
+  The different parts might have different properties.
+- Document realtime storage format. Add missing fields.
+- BUG: RTCP is halted during hold. It should not stop.
+- During HOLD, send RTCP SR reports without report block, only the header and no chunks 
+
+Done
+----
+- Added support of outbound and inbound SDES. The SDES includes a stream identifier, CNAME. 
+- Added support of outbound SDES end and goodbye
+- Added manager events at end-of call
+- Added realtime storage of RTCP reports
+- Added time manager events (configured in sip.conf)
+- Added more information to RTCP debug
+- Added more data aggregation to ast_rtcp structure (from svn trunk really)
+- Added RTCP for p2p RTP bridges. Needs to be tested and validated.
+
+Open Issues
+-----------
+The final manager report lacks (in the case of the second channel) the bridged channel. We could save that data.  This will affect realtime as well, so we need to copy the channel name to a stored variable while it exists.
+
+Do we have a counter of consecutive lost packets? How do we measure lost packets on inbound
+stream? Gaps in seq numbers or just the sender reports from the other end compared with received 
+no of packets?
+
+
+Ideas and thoughts for the future
+---------------------------------
+- Asterisk propagates jitter and packet loss over a bridge (especially the p2p RTP bridge).
+  If the call is transfered on the OTHER side of the bridge, we have a new call with new
+  properties. Maybe events like this should generate a new SDES and reset RTCP?
+  Part A of the call can have very different properties than part B. If I have a call with
+  someone internally, that then transfers me to a call with someone on the Internet, the
+  call quality (jitter etc) will change dramatically. This will require some sort of CONTROL
+  packet over the bridge, informing about changes on the other side of the bridge (masq).
+- Can we have some sort of ring buffer for the latest RTCP reports for a device (peer) 
+  and use that to determine the status of the connection to the peer?
+- Can we use the RTCP APP packet for relaying events in joined bridges, like meetme?
+- What should we use as CNAME? Currently SIP call ID.
+- Separate on the IPs of different media servers. IE we can have one SIP peer with
+  multiple media IPs with different properties
+
+Scenarios to test
+------------------
+- normal bridged call
+- RTP p2p bridged call
+- Nat traversal - Asterisk outside of NAT and inside (as client to external service)

Egenskapsändringar för: README.pinefrog-rtcp
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+Author Date Id Revision
\ No newline at end of property
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: include/asterisk/rtp.h
===================================================================
--- include/asterisk/rtp.h	(.../branches/1.4)	(revision 382456)
+++ include/asterisk/rtp.h	(.../team/oej/pinefrog-1.4)	(revision 382456)
@@ -77,16 +77,38 @@
 	AST_LIST_ENTRY(ast_rtp_protocol) list;
 };
 
+/*! \brief Data structure only used for RTCP reports */
 struct ast_rtp_quality {
-	unsigned int local_ssrc;          /* Our SSRC */
-	unsigned int local_lostpackets;   /* Our lost packets */
-	double       local_jitter;        /* Our calculated jitter */
-	unsigned int local_count;         /* Number of received packets */
-	unsigned int remote_ssrc;         /* Their SSRC */
-	unsigned int remote_lostpackets;  /* Their lost packets */
-	double       remote_jitter;       /* Their reported jitter */
-	unsigned int remote_count;        /* Number of transmitted packets */
-	double       rtt;                 /* Round trip time */
+	char channel[AST_MAX_EXTENSION];	/*!< Name of channel */
+	char uniqueid[AST_MAX_EXTENSION];	/*!< uniqueid of channel */
+	char bridgedchan[AST_MAX_EXTENSION];	/*!< Name of bridged channel */
+	char bridgeduniqueid[AST_MAX_EXTENSION];	/*!< uniqueid of bridged channel */
+	unsigned int numberofreports;	  /*!< Number of reports received from remote end */
+	unsigned int local_ssrc;          /*!< Our SSRC */
+	unsigned int local_lostpackets;   /*!< Our lost packets */
+	double       local_jitter;        /*!< Our calculated jitter */
+	double       local_jitter_max;    /*!< Our calculated jitter */
+	double       local_jitter_min;    /*!< Our calculated jitter */
+	unsigned int local_count;         /*!< Number of received packets */
+	unsigned int remote_ssrc;         /*!< Their SSRC */
+	unsigned int remote_lostpackets;  /*!< Their lost packets */
+	double       remote_jitter;       /*!< Their reported jitter */
+	double       remote_jitter_max;   /*!< Their reported jitter */
+	double       remote_jitter_min;   /*!< Their reported jitter */
+	unsigned int remote_count;        /*!< Number of transmitted packets */
+	double       rtt;                 /*!< Round trip time */
+	double       rttmax;              /*!< Max observed round trip time */
+	double       rttmin;              /*!< Max observed round trip time */
+	int lasttxformat;		  /*!< Last used codec on transmitted stream */
+	int lastrxformat;		  /*!< Last used codec on received stream */
+	struct sockaddr_in them;	  /*!< The IP address used for media by remote end */
+	struct timeval start;		  /*!< When the call started */
+	struct timeval end;		  /*!< When the call ended */
+	char writetranslator[80];	  /*!< Translator used when writing */
+	char readtranslator[80];		  /*!< Translator providing frames when reading */
+	int writecost;		  /*!< Cost in milliseconds for encoding/decoding 1 second of outbound media */
+	int readcost;		  /*!< Cost in milliseconds for encoding/decoding 1 second of inbound media */
+	int mediatype;			/*! Type of media */
 };
 
 
@@ -180,9 +202,35 @@
 
 int ast_rtp_settos(struct ast_rtp *rtp, int tos);
 
+void ast_rtcp_setcname(struct ast_rtp *rtp, const char *cname, size_t length);
+
+/*! \brief Set the transcoding variables for the QoS reports */
+void ast_rtcp_settranslator(struct ast_rtp *rtp, const char *readtranslator, const int readcost, const char *writetranslator, const int writecost);
+
+/*! \brief set the name of the channel and the bridged channel (if any)
+
+At the time when we write the report there might not be a bridge, so we need
+to store this so we can correlate the reports. If a channel changes bridge,
+it can be reset by first setting it to an empty string, then setting to 
+a new name 
+*/
+void ast_rtcp_set_bridged(struct ast_rtp *rtp, const char *channel, const char *uniqueid, const char *bridged_name, const char *bridged_uniqueid);
+
+/*! \brief Store translator information
+
+In order to measure quality of a phone call, information about transcoding is very useful. Translation
+adds processing and latency to the bridged call.
+*/
+void ast_rtcp_set_translation(struct ast_rtp *rtp, const char *writetranslator, const int writecost,
+				const char *readtranslator, const int readcost);
+
+/*! \brief When changing sources, don't generate a new SSRC */
+void ast_rtp_set_constantssrc(struct ast_rtp *rtp);
+
 /*! \brief Indicate that we need to set the marker bit */
 void ast_rtp_new_source(struct ast_rtp *rtp);
 
+
 /*! \brief Indicate that we need to set the marker bit and change the ssrc */
 void ast_rtp_change_source(struct ast_rtp *rtp);
 
@@ -246,9 +294,13 @@
 int ast_rtp_early_bridge(struct ast_channel *dest, struct ast_channel *src);
 
 void ast_rtp_stop(struct ast_rtp *rtp);
+int ast_rtp_isactive(struct ast_rtp *rtp);
 
 /*! \brief Return RTCP quality string */
-char *ast_rtp_get_quality(struct ast_rtp *rtp, struct ast_rtp_quality *qual);
+char *ast_rtp_get_quality(struct ast_rtp *rtp);
+  
+/*! \brief Return RTCP quality data structure */
+struct ast_rtp_quality *ast_rtp_get_qualdata(struct ast_rtp *rtp);
 
 /*! \brief Send an H.261 fast update request. Some devices need this rather than the XML message  in SIP */
 int ast_rtcp_send_h261fur(void *data);
Index: main/channel.c
===================================================================
--- main/channel.c	(.../branches/1.4)	(revision 382456)
+++ main/channel.c	(.../team/oej/pinefrog-1.4)	(revision 382456)
@@ -1601,6 +1601,7 @@
 {
 	if (option_debug)
 		ast_log(LOG_DEBUG, "Soft-Hanging up channel '%s'\n", chan->name);
+
 	/* Inform channel driver that we need to be hung up, if it cares */
 	chan->_softhangup |= cause;
 	ast_queue_frame(chan, &ast_null_frame);
Index: main/rtp.c
===================================================================
--- main/rtp.c	(.../branches/1.4)	(revision 382456)
+++ main/rtp.c	(.../team/oej/pinefrog-1.4)	(revision 382456)
@@ -64,13 +64,32 @@
 #define RTCP_MIN_INTERVALMS       500	/*!< Min milli-seconds between RTCP reports we send */
 #define RTCP_MAX_INTERVALMS       60000	/*!< Max milli-seconds between RTCP reports we send */
 
-#define RTCP_PT_FUR     192
-#define RTCP_PT_SR      200
-#define RTCP_PT_RR      201
-#define RTCP_PT_SDES    202
-#define RTCP_PT_BYE     203
-#define RTCP_PT_APP     204
+#define RTCP_PT_FUR     192		/*!< FIR  - Full Intra-frame request (h.261) */
+#define RTCP_PT_NACK    193		/*!< NACK - Negative acknowledgement (h.261) */
+#define RTCP_PT_IJ      195		/*!< IJ   - RFC 5450 Extended Inter-arrival jitter report */
+#define RTCP_PT_SR      200		/*!< SR   - RFC 3550 Sender report */
+#define RTCP_PT_RR      201		/*!< RR   - RFC 3550 Receiver report */
+#define RTCP_PT_SDES    202		/*!< SDES - Source Description */
+#define RTCP_PT_BYE     203		/*!< BYE  - Goodbye */
+#define RTCP_PT_APP     204		/*!< APP  - Application defined */
+#define RTCP_PT_RTPFB   205		/*!< RTPFB - Generic RTP feedback RFC 4585 */
+#define RTCP_PT_PSFB    206		/*!< PSFB - Payload specific data  RFC 4585 */
+#define RTCP_PT_XR      207		/*!< XR   - Extended report - RFC3611 */
 
+/*! \brief RFC 3550 RTCP SDES Item types */
+enum rtcp_sdes {
+	SDES_END	= 0,		/*!< End of SDES list */
+	SDES_CNAME	= 1,		/*!< Canonical name */
+	SDES_NAME	= 2,		/*!< User name */
+	SDES_EMAIL	= 3,		/*!< User's e-mail address */
+	SDES_PHONE	= 4,		/*!< User's phone number */
+	SDES_LOC	= 5,		/*!< Geographic user location */
+	SDES_TOOL	= 6,		/*!< Name of application or tool */
+	SDES_NOTE	= 7,		/*!< Notice about the source */
+	SDES_PRIV	= 8,		/*!< SDES Private extensions */
+	SDES_H323_CADDR	= 9,		/*!< H.323 Callable address */
+};
+
 #define RTP_MTU		1200
 
 #define DEFAULT_DTMF_TIMEOUT (150 * (8000 / 1000))	/*!< samples */
@@ -155,14 +174,17 @@
 	struct timeval rxcore;
 	struct timeval txcore;
 	double drxcore;                 /*!< The double representation of the first received packet */
+	struct timeval start;		/*!< When the stream started (we can't depend on CDRs) */
 	struct timeval lastrx;          /*!< timeval when we last received a packet */
 	struct timeval dtmfmute;
 	struct ast_smoother *smoother;
 	int *ioid;
+	int *ioidrtcp;
 	unsigned short seqno;		/*!< Sequence number, RFC 3550, page 13. */
 	unsigned short rxseqno;
-	struct sched_context *sched;
-	struct io_context *io;
+	struct sched_context *sched;	/*!< The scheduler context */
+	struct io_context *io;		/*!< for RTP callback */
+	struct io_context *iortcp;	/*!< for RTCP callback */
 	void *data;
 	ast_rtp_callback callback;
 	ast_mutex_t bridge_lock;
@@ -173,7 +195,9 @@
 	struct ast_rtcp *rtcp;
 	struct ast_codec_pref pref;
 	struct ast_rtp *bridged;        /*!< Who we are Packet bridged to */
+	struct ast_rtp_quality *qual;	/*!< Optional QoS data storage for this stream */
 	int set_marker_bit:1;           /*!< Whether to set the marker bit or not */
+	int isactive:2;                 /*!< Whether the RTP stream is active or not */
 };
 
 AST_LIST_HEAD_NOLOCK(frame_list, ast_frame);
@@ -181,11 +205,15 @@
 /* Forward declarations */
 static int ast_rtcp_write(const void *data);
 static void timeval2ntp(struct timeval tv, unsigned int *msw, unsigned int *lsw);
-static int ast_rtcp_write_sr(const void *data);
-static int ast_rtcp_write_rr(const void *data);
+static int ast_rtcp_write_sr(const void *data, int goodbye);
+static int ast_rtcp_write_rr(const void *data, int goodbye);
 static unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp);
 static int ast_rtp_senddigit_continuation(struct ast_rtp *rtp);
 int ast_rtp_senddigit_end(struct ast_rtp *rtp, char digit);
+static struct ast_frame *ast_rtcp_read_fd(int fd, struct ast_rtp *rtp);
+static int ast_rtcp_write_empty(struct ast_rtp *rtp, int fd);
+static int p2p_rtcp_callback(int *id, int fd, short events, void *cbdata);
+static unsigned int calc_txstamp(struct ast_rtp *rtp, struct timeval *delivery);
 int ast_rtp_senddigit_end_with_duration(struct ast_rtp *rtp, char digit, unsigned int duration);
 
 #define FLAG_3389_WARNING		(1 << 0)
@@ -211,6 +239,10 @@
  */
 struct ast_rtcp {
 	int s;				/*!< Socket */
+	char ourcname[255];		/*!< Our SDES RTP session name (CNAME) */
+	size_t ourcnamelength;		/*!< Length of CNAME (utf8) */
+	char theircname[255];		/*!< Their SDES RTP session name (CNAME) */
+	size_t theircnamelength;	/*!< Length of CNAME (utf8) */
 	struct sockaddr_in us;		/*!< Socket representation of the local endpoint. */
 	struct sockaddr_in them;	/*!< Socket representation of the remote endpoint. */
 	struct sockaddr_in altthem;	/*!< Alternate source for RTCP */
@@ -224,17 +256,38 @@
 	int schedid;			/*!< Schedid returned from ast_sched_add() to schedule RTCP-transmissions*/
 	unsigned int rr_count;		/*!< number of RRs we've sent, not including report blocks in SR's */
 	unsigned int sr_count;		/*!< number of SRs we've sent */
+	unsigned int rec_rr_count;	/*!< Number of RRs we've received */
+	unsigned int rec_sr_count;	/*!< Number of SRs we've received */
 	unsigned int lastsrtxcount;     /*!< Transmit packet count when last SR sent */
 	double accumulated_transit;	/*!< accumulated a-dlsr-lsr */
 	double rtt;			/*!< Last reported rtt */
 	unsigned int reported_jitter;	/*!< The contents of their last jitter entry in the RR */
+	double reported_maxjitter;	/*!< The contents of their max jitter entry received by us */
+	double reported_minjitter;	/*!< The contents of their min jitter entry received by us */
+	unsigned int reported_jitter_count;	/*! Number of reports received */
 	unsigned int reported_lost;	/*!< Reported lost packets in their RR */
+	double reported_maxlost;
+	double reported_minlost;
+	double rxlost;
+	double maxrxlost;
+	double minrxlost;
+	unsigned int rxlost_count;	/*! Number of reports received */
 	char quality[AST_MAX_USER_FIELD];
 	double maxrxjitter;
 	double minrxjitter;
+	unsigned int rxjitter_count;	/*! Number of reports received */
 	double maxrtt;
 	double minrtt;
+	unsigned int rtt_count;		/*! Number of reports received */
 	int sendfur;
+	char bridgedchan[AST_MAX_EXTENSION];		/*!< Bridged channel name */
+	char bridgeduniqueid[AST_MAX_EXTENSION];	/*!< Bridged channel uniqueid */
+	char channel[AST_MAX_EXTENSION];		/*!< Our channel name */
+	char uniqueid[AST_MAX_EXTENSION];	/*!< Our channel uniqueid */
+	char readtranslator[80];	/* Translation done on reading audio from PBX */
+	char writetranslator[80];	/* Translation done on writing audio to PBX - bridged channel */
+	int readcost;			/* Delay in milliseconds for translation of 1 second of audio */
+	int writecost;			/* Delay in milliseconds for translation of 1 second of audio */
 };
 
 
@@ -532,6 +585,17 @@
 	return (subclass == AST_FORMAT_G722) ? 8000 : ast_format_rate(subclass);
 }
 
+/*! \brief Schedule RTCP transmissions for RTP channel */
+static void ast_rtcp_schedule(struct ast_rtp *rtp)
+{
+	/* Do not schedule RR if RTCP isn't run */
+	if (rtp->rtcp && rtp->rtcp->them.sin_addr.s_addr && rtp->rtcp->schedid < 1) {
+		/* Schedule transmission of Receiver Report */
+		ast_rtcp_write_empty(rtp, rtp->rtcp->s);
+		rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
+	}
+}
+
 unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp)
 {
 	unsigned int interval;
@@ -884,12 +948,27 @@
 	return 1;
 }
 
+static int p2p_rtcp_callback(int *id, int fd, short events, void *cbdata)
+{
+	struct ast_rtp *rtp = cbdata;
+	ast_rtcp_read_fd(fd, rtp);
+	/* For now, skip any frames that is output. Which is bad for FUR's, but well. DEBUG */
+	return 1;
+}
+
 struct ast_frame *ast_rtcp_read(struct ast_rtp *rtp)
 {
+	return ast_rtcp_read_fd(rtp->rtcp->s, rtp);
+}
+
+static struct ast_frame *ast_rtcp_read_fd(int fd, struct ast_rtp *rtp)
+{
 	socklen_t len;
-	int position, i, packetwords;
+	int position, i, j, packetwords;
 	int res;
 	struct sockaddr_in sin;
+	char *sdes;
+	unsigned int sdeslength, sdestype;
 	unsigned int rtcpdata[8192 + AST_FRIENDLY_OFFSET];
 	unsigned int *rtcpheader;
 	int pt;
@@ -903,6 +982,7 @@
 	unsigned int msw;
 	unsigned int lsw;
 	unsigned int comp;
+	double reported_jitter, reported_lost;
 	struct ast_frame *f = &ast_null_frame;
 	
 	if (!rtp || !rtp->rtcp)
@@ -910,8 +990,9 @@
 
 	len = sizeof(sin);
 	
-	res = recvfrom(rtp->rtcp->s, rtcpdata + AST_FRIENDLY_OFFSET, sizeof(rtcpdata) - sizeof(unsigned int) * AST_FRIENDLY_OFFSET,
-					0, (struct sockaddr *)&sin, &len);
+	res = recvfrom(fd, rtcpdata + AST_FRIENDLY_OFFSET, sizeof(rtcpdata) - sizeof(unsigned int) * AST_FRIENDLY_OFFSET,
+			0, (struct sockaddr *)&sin, &len);
+
 	rtcpheader = (unsigned int *)(rtcpdata + AST_FRIENDLY_OFFSET);
 	
 	if (res < 0) {
@@ -923,7 +1004,7 @@
 		return &ast_null_frame;
 	}
 
-	packetwords = res / 4;
+	packetwords = res / 4;	/* Each RTCP segment is 32 bits */
 
 	if (rtp->nat) {
 		/* Send to whoever sent to us */
@@ -932,62 +1013,91 @@
 		    ((rtp->rtcp->altthem.sin_addr.s_addr != sin.sin_addr.s_addr) ||
 		    (rtp->rtcp->altthem.sin_port != sin.sin_port))) {
 			memcpy(&rtp->rtcp->them, &sin, sizeof(rtp->rtcp->them));
-			if (option_debug || rtpdebug)
+			if (option_debug || rtpdebug) {
 				ast_log(LOG_DEBUG, "RTCP NAT: Got RTCP from other end. Now sending to address %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			}
 		}
 	}
 
-	if (option_debug)
-		ast_log(LOG_DEBUG, "Got RTCP report of %d bytes\n", res);
+	if (option_debug && rtcp_debug_test_addr(&sin)) {
+		ast_log(LOG_DEBUG, "Got RTCP report of %d bytes - %d messages\n", res, packetwords);
+	}
 
-	/* Process a compound packet */
+	/* Process a compound packet 
+	   - A compound packet should start with a sender or receiver report. BYE can start as well
+		(seen in implementations) 
+	   -  Packet length should be a multiple of four bytes
+	*/
 	position = 0;
 	while (position < packetwords) {
 		i = position;
+		if (option_debug>3 && rtcp_debug_test_addr(&sin)) {
+			ast_log(LOG_DEBUG, "***** Debug - position = %d\n", position);
+		}
+
 		length = ntohl(rtcpheader[i]);
-		pt = (length & 0xff0000) >> 16;
-		rc = (length & 0x1f000000) >> 24;
+
+		pt = (length & 0xff0000) >> 16;		/* Packet type */
+		rc = (length & 0x1f000000) >> 24;	/* Number of chunks, i.e. streams reported */
 		length &= 0xffff;
     
 		if ((i + length) > packetwords) {
-			ast_log(LOG_WARNING, "RTCP Read too short\n");
-			return &ast_null_frame;
+			ast_log(LOG_WARNING, "RTCP Read too short - packet type %d position %d\n", pt, i);
+			return f;
 		}
 		
 		if (rtcp_debug_test_addr(&sin)) {
-		  	ast_verbose("\n\nGot RTCP from %s:%d\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
-		  	ast_verbose("PT: %d(%s)\n", pt, (pt == 200) ? "Sender Report" : (pt == 201) ? "Receiver Report" : (pt == 192) ? "H.261 FUR" : "Unknown");
-		  	ast_verbose("Reception reports: %d\n", rc);
-		  	ast_verbose("SSRC of sender: %u\n", rtcpheader[i + 1]);
+		  	ast_verbose("\n-- Got RTCP from %s:%d\n", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
+		  	ast_verbose("   Length : %d Chunks: %d\n", length, rc);
+		  	ast_verbose("   SSRC of packet sender: %u (%x)", ntohl(rtcpheader[i + 1]), ntohl(rtcpheader[i + 1]));
+		  	ast_verbose("   (Position %d of %d)\n", i, packetwords);
+			if (rc == 0) {
+		  		ast_verbose("   Empty - no reports! \n");
+			}
 		}
     
 		i += 2; /* Advance past header and ssrc */
-		if (rc == 0 && pt == RTCP_PT_RR) {      /* We're receiving a receiver report with no reports, which is ok */
-                        position += (length + 1);
-                        continue;
-                }
-		
-		switch (pt) {
-		case RTCP_PT_SR:
-			gettimeofday(&rtp->rtcp->rxlsr,NULL); /* To be able to populate the dlsr */
-			rtp->rtcp->spc = ntohl(rtcpheader[i+3]);
-			rtp->rtcp->soc = ntohl(rtcpheader[i + 4]);
+		if (rc == 0 && pt == RTCP_PT_RR) {	/* We're receiving a receiver report with no reports, which is ok */
+			position += (length + 1);
+			continue;
+		}
+		if (pt == RTCP_PT_SR) {
+			rtp->rtcp->rec_sr_count++;
+		} else if (pt == RTCP_PT_RR) {
+			rtp->rtcp->rec_rr_count++;
+		}
+
+		switch (pt) {	/* Find the RTCP Packet type */
+		case RTCP_PT_SR:	/* Sender's report - about what they have sent us */
+			if (rtcp_debug_test_addr(&sin)) {
+				ast_verbose("    - RTCP SR (sender report) from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			}
+			/* Don't handle multiple reception reports (rc > 1) yet */
+			gettimeofday(&rtp->rtcp->rxlsr, NULL); /* To be able to populate the dlsr */
+			rtp->rtcp->spc = ntohl(rtcpheader[i + 3]);	/* Sender packet count */
+			rtp->rtcp->soc = ntohl(rtcpheader[i + 4]);	/* Sender octet count */
+
 			rtp->rtcp->themrxlsr = ((ntohl(rtcpheader[i]) & 0x0000ffff) << 16) | ((ntohl(rtcpheader[i + 1]) & 0xffff0000) >> 16); /* Going to LSR in RR*/
     
 			if (rtcp_debug_test_addr(&sin)) {
-				ast_verbose("NTP timestamp: %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[i]), (unsigned long) ntohl(rtcpheader[i + 1]) * 4096);
-				ast_verbose("RTP timestamp: %lu\n", (unsigned long) ntohl(rtcpheader[i + 2]));
-				ast_verbose("SPC: %lu\tSOC: %lu\n", (unsigned long) ntohl(rtcpheader[i + 3]), (unsigned long) ntohl(rtcpheader[i + 4]));
+				ast_verbose("      NTP timestamp: %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[i]), (unsigned long) ntohl(rtcpheader[i + 1]) * 4096);
+				ast_verbose("      RTP timestamp: %lu\n", (unsigned long) ntohl(rtcpheader[i + 2]));
+				ast_verbose("      SPC: %lu\tSOC: %lu\n", (unsigned long) ntohl(rtcpheader[i + 3]), (unsigned long) ntohl(rtcpheader[i + 4]));
+				ast_verbose("      RC (number of reports) %d\n", rc);
 			}
-			i += 5;
+			i += 5;	/* Sender's info report is five bytes */
 			if (rc < 1)
 				break;
-			/* Intentional fall through */
-		case RTCP_PT_RR:
+			/* Intentional fall through - the report blocks are the same for RR and SR */
+		case RTCP_PT_RR:	/* Receiver report - data about what we have sent to them */
+			if (rtcp_debug_test_addr(&sin)) {
+				ast_verbose("Received a RTCP RR (receiver report) from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			}
 			/* Don't handle multiple reception reports (rc > 1) yet */
 			/* Calculate RTT per RFC */
 			gettimeofday(&now, NULL);
 			timeval2ntp(now, &msw, &lsw);
+			/* Get timing */
 			if (ntohl(rtcpheader[i + 4]) && ntohl(rtcpheader[i + 5])) { /* We must have the LSR && DLSR */
 				comp = ((msw & 0xffff) << 16) | ((lsw & 0xffff0000) >> 16);
 				lsr = ntohl(rtcpheader[i + 4]);
@@ -997,21 +1107,27 @@
 				/* Convert end to end delay to usec (keeping the calculation in 64bit space)
 				   sess->ee_delay = (eedelay * 1000) / 65536; */
 				if (rtt < 4294) {
-				    rtt = (rtt * 1000000) >> 16;
+					rtt = (rtt * 1000000) >> 16;
 				} else {
-				    rtt = (rtt * 1000) >> 16;
-				    rtt *= 1000;
+					rtt = (rtt * 1000) >> 16;
+					rtt *= 1000;
 				}
 				rtt = rtt / 1000.;
-				rttsec = rtt / 1000.;
+				// What is this?
+				//rttsec = rtt / 1000.;
+				rttsec = rtt;		//DEBUG OEJ
 
 				if (comp - dlsr >= lsr) {
-					rtp->rtcp->accumulated_transit += rttsec;
 					rtp->rtcp->rtt = rttsec;
-					if (rtp->rtcp->maxrtt<rttsec)
+					if (rtp->rtcp->maxrtt < rttsec) {
 						rtp->rtcp->maxrtt = rttsec;
-					if (rtp->rtcp->minrtt>rttsec)
+					}
+					if (rtp->rtcp->minrtt > rttsec || rtp->rtcp->minrtt == 0) {
 						rtp->rtcp->minrtt = rttsec;
+					}
+					/* Calculation base for average rtt */
+					rtp->rtcp->accumulated_transit += rttsec;
+					rtp->rtcp->rtt_count++;
 				} else if (rtcp_debug_test_addr(&sin)) {
 					ast_verbose("Internal RTCP NTP clock skew detected: "
 							   "lsr=%u, now=%u, dlsr=%u (%d:%03dms), "
@@ -1020,25 +1136,44 @@
 							   (dlsr % 65536) * 1000 / 65536,
 							   dlsr - (comp - lsr));
 				}
-			}
+			} 
 
 			rtp->rtcp->reported_jitter = ntohl(rtcpheader[i + 3]);
+			reported_jitter = (double) rtp->rtcp->reported_jitter;
+			if (rtp->rtcp->reported_jitter > rtp->rtcp->reported_maxjitter) {
+				rtp->rtcp->reported_maxjitter = reported_jitter;
+			} else if (rtp->rtcp->reported_jitter < rtp->rtcp->reported_minjitter || rtp->rtcp->reported_minjitter == 0) {
+				rtp->rtcp->reported_minjitter = reported_jitter;
+			}
+		
 			rtp->rtcp->reported_lost = ntohl(rtcpheader[i + 1]) & 0xffffff;
+			reported_lost = (double) rtp->rtcp->reported_lost;
+			if (rtp->rtcp->reported_lost > rtp->rtcp->reported_maxlost) {
+				rtp->rtcp->reported_maxlost = reported_lost;
+			} else if (rtp->rtcp->reported_lost < rtp->rtcp->reported_minlost || rtp->rtcp->reported_jitter_count == 0) {
+				rtp->rtcp->reported_minlost = reported_lost;
+			}
+			rtp->rtcp->reported_jitter_count++;
 			if (rtcp_debug_test_addr(&sin)) {
 				ast_verbose("  Fraction lost: %ld\n", (((long) ntohl(rtcpheader[i + 1]) & 0xff000000) >> 24));
 				ast_verbose("  Packets lost so far: %d\n", rtp->rtcp->reported_lost);
 				ast_verbose("  Highest sequence number: %ld\n", (long) (ntohl(rtcpheader[i + 2]) & 0xffff));
 				ast_verbose("  Sequence number cycles: %ld\n", (long) (ntohl(rtcpheader[i + 2]) & 0xffff) >> 16);
-				ast_verbose("  Interarrival jitter: %u\n", rtp->rtcp->reported_jitter);
-				ast_verbose("  Last SR(our NTP): %lu.%010lu\n",(unsigned long) ntohl(rtcpheader[i + 4]) >> 16,((unsigned long) ntohl(rtcpheader[i + 4]) << 16) * 4096);
-				ast_verbose("  DLSR: %4.4f (sec)\n",ntohl(rtcpheader[i + 5])/65536.0);
-				if (rtt)
-					ast_verbose("  RTT: %lu(sec)\n", (unsigned long) rtt);
+				ast_verbose("  Interarrival jitter: %u Max %f Min %f\n", rtp->rtcp->reported_jitter,
+					rtp->rtcp->reported_maxjitter, rtp->rtcp->reported_minjitter);
+				ast_verbose("  Last SR (our NTP): %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[i + 4]) >> 16,((unsigned long) ntohl(rtcpheader[i + 4]) << 16) * 4096);
+				ast_verbose("  DLSR: %4.4f (sec)\n", ntohl(rtcpheader[i + 5])/65536.0);
+				if (rtt) {
+					ast_verbose("  RTT: %lu (msec) Max %lu Min %lu\n", (unsigned long) rtt, 
+						(unsigned long) rtp->rtcp->maxrtt,
+						(unsigned long) rtp->rtcp->minrtt );
+				}
 			}
 			break;
 		case RTCP_PT_FUR:
-			if (rtcp_debug_test_addr(&sin))
+			if (rtcp_debug_test_addr(&sin)) {
 				ast_verbose("Received an RTCP Fast Update Request\n");
+			}
 			rtp->f.frametype = AST_FRAME_CONTROL;
 			rtp->f.subclass = AST_CONTROL_VIDUPDATE;
 			rtp->f.datalen = 0;
@@ -1048,24 +1183,139 @@
 			f = &rtp->f;
 			break;
 		case RTCP_PT_SDES:
-			if (rtcp_debug_test_addr(&sin))
-				ast_verbose("Received an SDES from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			/* SDES messages are divided into chunks, each one containing one or
+			   several items. Each chunk is for a different CSRC, so it's not really
+			   relevant in most cases of voip calls - unless you have an advanced
+			   mixer in the network that separates the different streams with CSRC 
+
+			   A chunk starts with SSRC/CSRC (four bytes), then SDES items 
+			   In the SDES message, there can be several items, ending with SDES_END
+			   The length of the all items is length - header 
+			   Chunk starts on a 32-bit boundary and needs padding by 0's
+		
+			   the "rc" variable contains the number of chunks 
+			   When we start, we're beyond the SSRC and starts with SDES items in the
+			   first chunk.
+			
+				an SDES item is one byte of type, one byte of length then data 
+				(no null termination). Text is UTF-8.
+				the last item is a zero (END) type with no length indication.
+			*/
+			
+			j = i * 4;
+			sdes = (char *) &rtcpheader[i];
+			if (rtcp_debug_test_addr(&sin)) {
+				ast_verbose("   Received an SDES from %s:%d - Total length %d (%d bytes)\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port), length-i, ((length-i)*4) - 6);
+			}
+			while (j < length * 4) {
+				sdestype = (int) *sdes;
+				sdes++;
+				sdeslength = (int) *sdes;
+				sdes++;
+				if (rtcp_debug_test_addr(&sin)) {
+					ast_verbose(" --- SDES Type %u, Length %u Curj %d)\n", sdestype, sdeslength, j);
+				}
+				switch (sdestype) {
+				case SDES_CNAME:
+					if (!ast_strlen_zero(rtp->rtcp->theircname)) {
+						if (strncmp(rtp->rtcp->theircname, sdes, sdeslength)) {
+							ast_log(LOG_WARNING, "New RTP stream received (new RTCP CNAME for session. Old name: %s\n", rtp->rtcp->theircname);
+						}
+					}
+					strncpy(rtp->rtcp->theircname, sdes, sdeslength);
+					rtp->rtcp->theircname[sdeslength + 1] = '\0';
+					rtp->rtcp->theircnamelength = sdeslength;
+					if (rtcp_debug_test_addr(&sin)) {
+						ast_verbose(" --- SDES CNAME (utf8) %s\n", rtp->rtcp->theircname);
+					}
+					break;
+				case SDES_TOOL:
+					if (rtcp_debug_test_addr(&sin)) {
+						ast_verbose(" --- SDES TOOL \n");
+					}
+					break;
+				case SDES_NAME:
+					if (rtcp_debug_test_addr(&sin)) {
+						ast_verbose(" --- SDES NAME \n");
+					}
+					break;
+				case SDES_EMAIL:
+					if (rtcp_debug_test_addr(&sin)) {
+						ast_verbose(" --- SDES EMAIL \n");
+					}
+					break;
+				case SDES_PHONE:
+					if (rtcp_debug_test_addr(&sin)) {
+						ast_verbose(" --- SDES PHONE \n");
+					}
+					break;
+				case SDES_LOC:
+					if (rtcp_debug_test_addr(&sin)) {
+						ast_verbose(" --- SDES LOC \n");
+					}
+					break;
+				case SDES_NOTE:
+					if (rtcp_debug_test_addr(&sin)) {
+						ast_verbose(" --- SDES NOTE \n");
+					}
+					break;
+				case SDES_PRIV:
+					if (rtcp_debug_test_addr(&sin)) {
+						ast_verbose(" --- SDES PRIV \n");
+					}
+					break;
+				case SDES_END:
+					if (rtcp_debug_test_addr(&sin)) {
+						ast_verbose(" --- SDES END \n");
+					}
+					break;
+				}
+				j += 2 + sdeslength;	/* Header (1 byte) + length */
+				sdes += sdeslength;
+				if (sdestype == SDES_END) {
+					break;	/* The while loop */
+				}
+			}
+
 			break;
+		case RTCP_PT_NACK:
+			if (rtcp_debug_test_addr(&sin)) {
+				ast_verbose("   Received a RTCP NACK from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			}
+			break;
 		case RTCP_PT_BYE:
-			if (rtcp_debug_test_addr(&sin))
-				ast_verbose("Received a BYE from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			if (rtcp_debug_test_addr(&sin)) {
+				ast_verbose("   Received a RTCP BYE from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			}
 			break;
+		case RTCP_PT_XR:
+			if (rtcp_debug_test_addr(&sin)) {
+				ast_verbose("   Received a RTCP Extended Report (XR) packet from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			}
+			break;
+		case RTCP_PT_APP:
+			if (rtcp_debug_test_addr(&sin)) {
+				ast_verbose("   Received a RTCP APP packet from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			}
+			break;
+		case RTCP_PT_IJ:
+			if (rtcp_debug_test_addr(&sin)) {
+				ast_verbose("   Received a RTCP IJ from %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			}
+			break;
 		default:
 			if (option_debug)
 				ast_log(LOG_DEBUG, "Unknown RTCP packet (pt=%d) received from %s:%d\n", pt, ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
 			break;
 		}
 		position += (length + 1);
-	}
-			
+	} /* While */
+
 	return f;
 }
 
+			
+
 static void sanitize_tv(struct timeval *tv)
 {
 	while (tv->tv_usec < 0) {
@@ -1101,6 +1351,7 @@
 	}
 
 	gettimeofday(&now,NULL);
+
 	/* rxcore is the mapping between the RTP timestamp and _our_ real time from gettimeofday() */
 	tv->tv_sec = rtp->rxcore.tv_sec + timestamp / rate;
 	tv->tv_usec = rtp->rxcore.tv_usec + (timestamp % rate) * 125;
@@ -1114,10 +1365,18 @@
 	if (d<0)
 		d=-d;
 	rtp->rxjitter += (1./16.) * (d - rtp->rxjitter);
-	if (rtp->rtcp && rtp->rxjitter > rtp->rtcp->maxrxjitter)
+	if (!rtp->rtcp) {
+		return;
+	}
+
+	if (rtp->rxjitter > rtp->rtcp->maxrxjitter)
 		rtp->rtcp->maxrxjitter = rtp->rxjitter;
-	if (rtp->rtcp && rtp->rxjitter < rtp->rtcp->minrxjitter)
+	if (rtp->rtcp->rxjitter_count == 1) {
 		rtp->rtcp->minrxjitter = rtp->rxjitter;
+	}
+	if (rtp->rxjitter < rtp->rtcp->minrxjitter)
+		rtp->rtcp->minrxjitter = rtp->rxjitter;
+	rtp->rtcp->rxjitter_count++;
 }
 
 /*! \brief Perform a Packet2Packet RTP write */
@@ -1126,6 +1385,11 @@
 	int res = 0, payload = 0, bridged_payload = 0, mark;
 	struct rtpPayloadType rtpPT;
 	int reconstruct = ntohl(rtpheader[0]);
+	unsigned int timestamp;
+	struct timeval rxtime;
+	//int header = 12;
+	int rate;
+	unsigned int ms;
 
 	/* Get fields from packet */
 	payload = (reconstruct & 0x7f0000) >> 16;
@@ -1134,6 +1398,7 @@
 	/* Check what the payload value should be */
 	rtpPT = ast_rtp_lookup_pt(rtp, payload);
 
+
 	/* If the payload is DTMF, and we are listening for DTMF - then feed it into the core */
 	if (ast_test_flag(rtp, FLAG_P2P_NEED_DTMF) && !rtpPT.isAstFormat && rtpPT.code == AST_RTP_DTMF)
 		return -1;
@@ -1152,12 +1417,29 @@
 		ast_set_flag(rtp, FLAG_P2P_SENT_MARK);
 	}
 
+	/* Calculate timestamp for reception of the packet */
+	timestamp = ntohl(rtpheader[1]);
+	calc_rxstamp(&rxtime, rtp, timestamp, mark);
+
+ 	rate = rtp_get_rate(bridged_payload) / 1000;
+
+	/* Now, calculate tx timestamp */
+        ms = calc_txstamp(rtp, &rxtime);
+        if (bridged_payload == AST_FRAME_VOICE) {
+                bridged->lastts = bridged->lastts + ms * rate;
+	} else if (bridged_payload == AST_FRAME_VIDEO) {
+		bridged->lastts = bridged->lastts + ms * 90;
+		/* This is not exact, but a best effort example that can be improved */
+	}
+
 	/* Reconstruct part of the packet */
 	reconstruct &= 0xFF80FFFF;
 	reconstruct |= (bridged_payload << 16);
 	reconstruct |= (mark << 23);
 	rtpheader[0] = htonl(reconstruct);
 
+	bridged->lasttxformat = rtp->lastrxformat = bridged_payload;
+
 	/* Send the packet back out */
 	res = sendto(bridged->s, (void *)rtpheader, len, 0, (struct sockaddr *)&bridged->them, sizeof(bridged->them));
 	if (res < 0) {
@@ -1169,8 +1451,12 @@
 			ast_set_flag(bridged, FLAG_NAT_INACTIVE_NOWARN);
 		}
 		return 0;
-	} else if (rtp_debug_test_addr(&bridged->them))
-			ast_verbose("Sent RTP P2P packet to %s:%u (type %-2.2d, len %-6.6u)\n", ast_inet_ntoa(bridged->them.sin_addr), ntohs(bridged->them.sin_port), bridged_payload, len - hdrlen);
+	} 
+	bridged->txcount++;
+	bridged->txoctetcount +=(res - hdrlen);
+	if (rtp_debug_test_addr(&bridged->them)) {
+			ast_verbose("Sent RTP P2P packet %d to %s:%u (type %-2.2d, len %-6.6u)\n", rtp->txcount, ast_inet_ntoa(bridged->them.sin_addr), ntohs(bridged->them.sin_port), bridged_payload, len - hdrlen);
+	}
 
 	return 0;
 }
@@ -1216,7 +1502,7 @@
 	}
 	
 	if (res < hdrlen) {
-		ast_log(LOG_WARNING, "RTP Read too short\n");
+		ast_log(LOG_WARNING, "RTP Read too short (%d, expecting %d)\n", res, hdrlen);
 		return &ast_null_frame;
 	}
 
@@ -1256,26 +1542,13 @@
 				ast_log(LOG_DEBUG, "RTP NAT: Got audio from other end. Now sending to address %s:%d\n", ast_inet_ntoa(rtp->them.sin_addr), ntohs(rtp->them.sin_port));
 		}
 	}
-
-	/* If we are bridged to another RTP stream, send direct */
-	if ((bridged = ast_rtp_get_bridged(rtp)) && !bridge_p2p_rtp_write(rtp, bridged, rtpheader, res, hdrlen))
-		return &ast_null_frame;
-
-	if (version != 2)
-		return &ast_null_frame;
-
-	payloadtype = (seqno & 0x7f0000) >> 16;
-	padding = seqno & (1 << 29);
+	/* Stuff that is needed for RTCP - regardless of p2p bridge or not */
 	mark = seqno & (1 << 23);
-	ext = seqno & (1 << 28);
-	cc = (seqno & 0xF000000) >> 24;
-	seqno &= 0xffff;
 	timestamp = ntohl(rtpheader[1]);
 	ssrc = ntohl(rtpheader[2]);
 
- 	AST_LIST_HEAD_INIT_NOLOCK(&frames);
- 	/* Force a marker bit and change SSRC if the SSRC changes */
- 	if (rtp->rxssrc && rtp->rxssrc != ssrc) {
+	AST_LIST_HEAD_INIT_NOLOCK(&frames);
+	if (!mark && rtp->rxssrc && rtp->rxssrc != ssrc) {
  		struct ast_frame *f, srcupdate = {
  			AST_FRAME_CONTROL,
  			.subclass = AST_CONTROL_SRCCHANGE,
@@ -1292,27 +1565,22 @@
 	}
 
 	rtp->rxssrc = ssrc;
-	
-	if (padding) {
-		/* Remove padding bytes */
-		res -= rtp->rawdata[AST_FRIENDLY_OFFSET + res - 1];
-	}
-	
-	if (cc) {
-		/* CSRC fields present */
-		hdrlen += cc*4;
-	}
 
-	if (ext) {
-		/* RTP Extension present */
-		hdrlen += (ntohl(rtpheader[hdrlen/4]) & 0xffff) << 2;
-		hdrlen += 4;
-	}
+	if (rtp->themssrc==0)
+		rtp->themssrc = ntohl(rtpheader[2]); /* Record their SSRC to put in future RR */
 
+	if (version != 2)
+		return &ast_null_frame;
+
 	if (res < hdrlen) {
 		ast_log(LOG_WARNING, "RTP Read too short (%d, expecting %d)\n", res, hdrlen);
 		return AST_LIST_FIRST(&frames) ? AST_LIST_FIRST(&frames) : &ast_null_frame;
 	}
+	payloadtype = (seqno & 0x7f0000) >> 16;
+	padding = seqno & (1 << 29);
+	ext = seqno & (1 << 28);
+	cc = (seqno & 0xF000000) >> 24;
+	seqno &= 0xffff;
 
 	rtp->rxcount++; /* Only count reasonably valid packets, this'll make the rtcp stats more accurate */
 
@@ -1321,19 +1589,39 @@
 		rtp->seedrxseqno = seqno;
 	}
 
-	/* Do not schedule RR if RTCP isn't run */
-	if (rtp->rtcp && rtp->rtcp->them.sin_addr.s_addr && rtp->rtcp->schedid < 1) {
-		/* Schedule transmission of Receiver Report */
-		rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
-	}
 	if ( (int)rtp->lastrxseqno - (int)seqno  > 100) /* if so it would indicate that the sender cycled; allow for misordering */
 		rtp->cycles += RTP_SEQ_MOD;
 
 	rtp->lastrxseqno = seqno;
+
+	/* Schedule RTCP report transmissions if possible */
+	ast_rtcp_schedule(rtp);
+
+
+	/* If we are bridged to another RTP stream, send direct */
+	if ((bridged = ast_rtp_get_bridged(rtp)) && !bridge_p2p_rtp_write(rtp, bridged, rtpheader, res, hdrlen))
+		return &ast_null_frame;
+
+
 	
-	if (rtp->themssrc==0)
-		rtp->themssrc = ntohl(rtpheader[2]); /* Record their SSRC to put in future RR */
 	
+	if (padding) {
+		/* Remove padding bytes */
+		res -= rtp->rawdata[AST_FRIENDLY_OFFSET + res - 1];
+	}
+	
+	if (cc) {
+		/* CSRC fields present */
+		hdrlen += cc*4;
+	}
+
+	if (ext) {
+		/* RTP Extension present */
+		hdrlen += (ntohl(rtpheader[hdrlen/4]) & 0xffff) << 2;
+		hdrlen += 4;
+	}
+
+	
 	if (rtp_debug_test_addr(&sin))
 		ast_verbose("Got  RTP packet from    %s:%u (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
 			ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port), payloadtype, seqno, timestamp,res - hdrlen);
@@ -2002,7 +2290,10 @@
 	rtp->ssrc = ast_random();
 	rtp->seqno = ast_random() & 0xffff;
 	ast_set_flag(rtp, FLAG_HAS_DTMF);
+	rtp->isactive = 1;
 
+	gettimeofday(&rtp->start, NULL);
+
 	return;
 }
 
@@ -2088,6 +2379,7 @@
 	if (callbackmode) {
 		rtp->ioid = ast_io_add(rtp->io, rtp->s, rtpread, AST_IO_IN, rtp);
 		ast_set_flag(rtp, FLAG_CALLBACK_MODE);
+		rtp->ioidrtcp = ast_io_add(rtp->iortcp, rtp->rtcp->s, p2p_rtcp_callback, AST_IO_IN, rtp);
 	}
 	ast_rtp_pt_default(rtp);
 	return rtp;
@@ -2101,6 +2393,71 @@
 	return ast_rtp_new_with_bindaddr(sched, io, rtcpenable, callbackmode, ia);
 }
 
+/*! \brief set RTP cname used to describe session in RTCP sdes messages */
+void ast_rtcp_setcname(struct ast_rtp *rtp, const char *cname, size_t length)
+{
+	if (!rtp || !rtp->rtcp) {
+		return;
+	}
+	if (length > 255) {
+		length=255;
+	}
+	ast_copy_string(rtp->rtcp->ourcname, cname, length+1);
+	rtp->rtcp->ourcnamelength = length;
+	if (option_debug > 3) {
+		ast_log(LOG_DEBUG, "--- Copied CNAME %s to RTCP structure (length %d)\n", cname, (int) length);
+	}
+}
+
+/*! \brief Set the transcoding variables for the QoS reports */
+void ast_rtcp_settranslator(struct ast_rtp *rtp, const char *readtranslator, const int readcost, const char *writetranslator, const int writecost)
+{
+	if (!rtp || !rtp->rtcp) {
+		return;
+	}
+	ast_copy_string(rtp->rtcp->readtranslator, S_OR(readtranslator,""), sizeof(rtp->rtcp->readtranslator));
+	ast_copy_string(rtp->rtcp->writetranslator, S_OR(writetranslator,""), sizeof(rtp->rtcp->writetranslator));
+	rtp->rtcp->readcost = readcost;
+	rtp->rtcp->writecost = writecost;
+	
+}
+
+/*! \brief set the name of the bridged channel
+
+At the time when we write the report there might not be a bridge, so we need
+to store this so we can correlate the reports. If a channel changes bridge,
+it can be reset by first setting it to an empty string, then setting to 
+a new name 
+*/
+void ast_rtcp_set_bridged(struct ast_rtp *rtp, const char *channel, const char *uniqueid, const char *bridgedchan, const char *bridgeduniqueid)
+{
+	if (!rtp) {		/* For some reason, there's no RTP */
+		return;
+	}
+	if (!rtp->rtcp) {	/* No RTCP? Strange */
+		return;
+	}
+	/* If we already have data, don't replace it. 
+		NOTE: Should we replace it at a masquerade or something? Hmm.
+	*/
+	if (channel && !rtp->rtcp->channel[0]) {
+		ast_copy_string(rtp->rtcp->channel, channel, sizeof(rtp->rtcp->channel));
+	}
+	if (uniqueid && !rtp->rtcp->uniqueid[0]) {
+		ast_copy_string(rtp->rtcp->uniqueid, uniqueid, sizeof(rtp->rtcp->uniqueid));
+	}
+	if (bridgedchan) {
+		ast_copy_string(rtp->rtcp->bridgedchan, bridgedchan, sizeof(rtp->rtcp->bridgedchan));
+	} else {
+		rtp->rtcp->bridgedchan[0] = '\0';
+	}
+	if (bridgeduniqueid) {
+		ast_copy_string(rtp->rtcp->bridgeduniqueid, bridgeduniqueid, sizeof(rtp->rtcp->bridgeduniqueid));
+	} else {
+		rtp->rtcp->bridgeduniqueid[0] = '\0';
+	}
+}
+
 int ast_rtp_settos(struct ast_rtp *rtp, int tos)
 {
 	int res;
@@ -2183,11 +2540,21 @@
 	return bridged;
 }
 
+int ast_rtp_isactive(struct ast_rtp *rtp)
+{
+	return rtp->isactive;
+}
+
 void ast_rtp_stop(struct ast_rtp *rtp)
 {
-	if (rtp->rtcp) {
+	if (rtp->rtcp && rtp->rtcp->schedid != -1) {
 		AST_SCHED_DEL(rtp->sched, rtp->rtcp->schedid);
+		rtp->rtcp->schedid = -1;
 	}
+	/* Send RTCP goodbye packet */
+	if (rtp->isactive) {
+		ast_rtcp_write_sr((const void *) rtp, 1);
+	}
 
 	memset(&rtp->them.sin_addr, 0, sizeof(rtp->them.sin_addr));
 	memset(&rtp->them.sin_port, 0, sizeof(rtp->them.sin_port));
@@ -2197,6 +2564,7 @@
 	}
 	
 	ast_clear_flag(rtp, FLAG_P2P_SENT_MARK);
+	rtp->isactive = 0;
 }
 
 void ast_rtp_reset(struct ast_rtp *rtp)
@@ -2218,8 +2586,13 @@
 	rtp->rxseqno = 0;
 }
 
-char *ast_rtp_get_quality(struct ast_rtp *rtp, struct ast_rtp_quality *qual)
+struct ast_rtp_quality *ast_rtp_get_qualdata(struct ast_rtp *rtp)
 {
+	return(rtp->qual);
+}
+
+char *ast_rtp_get_quality(struct ast_rtp *rtp)
+{
 	/*
 	*ssrc          our ssrc
 	*themssrc      their ssrc
@@ -2232,19 +2605,65 @@
 	*rtt           round trip time
 	*/
 
-	if (qual && rtp) {
-		qual->local_ssrc = rtp->ssrc;
-		qual->local_jitter = rtp->rxjitter;
-		qual->local_count = rtp->rxcount;
-		qual->remote_ssrc = rtp->themssrc;
-		qual->remote_count = rtp->txcount;
+	if (!rtp->qual) {
+		if (!(rtp->qual = ast_calloc(1, sizeof(*rtp->qual)))) {
+			ast_log(LOG_ERROR, "Memory allocation error.\n");
+		}
+	}
+	if (rtp->qual && rtp) {
+		rtp->qual->start = rtp->start;
+		rtp->qual->lasttxformat = rtp->lasttxformat;
+		rtp->qual->lastrxformat = rtp->lastrxformat;
+		rtp->qual->local_ssrc = rtp->ssrc;
+		rtp->qual->local_jitter = rtp->rxjitter;
+		rtp->qual->local_count = rtp->rxcount;
+		rtp->qual->remote_ssrc = rtp->themssrc;
+		rtp->qual->remote_count = rtp->txcount;
 		if (rtp->rtcp) {
-			qual->local_lostpackets = rtp->rtcp->expected_prior - rtp->rtcp->received_prior;
-			qual->remote_lostpackets = rtp->rtcp->reported_lost;
-			qual->remote_jitter = rtp->rtcp->reported_jitter / 65536.0;
-			qual->rtt = rtp->rtcp->rtt;
+			if (rtp->rtcp->them.sin_addr.s_addr) {
+				/* Do not change to empty address */
+				memcpy(&rtp->qual->them, &rtp->rtcp->them, sizeof(rtp->qual->them));
+			}
+			rtp->qual->numberofreports = rtp->rtcp->reported_jitter_count;	/* use the jitter counter */
+			rtp->qual->local_jitter_max = rtp->rtcp->maxrxjitter;
+			rtp->qual->local_jitter_min = rtp->rtcp->minrxjitter;
+			rtp->qual->local_lostpackets = rtp->rtcp->expected_prior - rtp->rtcp->received_prior;
+			rtp->qual->remote_lostpackets = rtp->rtcp->reported_lost;
+			rtp->qual->remote_jitter = rtp->rtcp->reported_jitter / 65536.0;
+			rtp->qual->remote_jitter_max = rtp->rtcp->reported_maxjitter;
+			rtp->qual->remote_jitter_min = rtp->rtcp->reported_minjitter;
+			rtp->qual->rtt = rtp->rtcp->rtt;
+			rtp->qual->rttmax = rtp->rtcp->maxrtt;
+			rtp->qual->rttmin = rtp->rtcp->minrtt;
+			rtp->qual->channel[0] = '\0';
+			rtp->qual->uniqueid[0] = '\0';
+			rtp->qual->bridgedchan[0] = '\0';
+			rtp->qual->bridgeduniqueid[0] = '\0';
+			rtp->qual->readtranslator[0] = '\0';
+			rtp->qual->writetranslator[0] = '\0';
+			if (!ast_strlen_zero(rtp->rtcp->bridgedchan)) {
+				ast_copy_string(rtp->qual->bridgedchan, rtp->rtcp->bridgedchan, sizeof(rtp->qual->bridgedchan));
+			}
+			if (!ast_strlen_zero(rtp->rtcp->bridgeduniqueid)) {
+				ast_copy_string(rtp->qual->bridgeduniqueid, rtp->rtcp->bridgeduniqueid, sizeof(rtp->qual->bridgeduniqueid));
+			}
+			if (!ast_strlen_zero(rtp->rtcp->channel)) {
+				ast_copy_string(rtp->qual->channel, rtp->rtcp->channel, sizeof(rtp->qual->channel));
+			}
+			if (!ast_strlen_zero(rtp->rtcp->uniqueid)) {
+				ast_copy_string(rtp->qual->uniqueid, rtp->rtcp->uniqueid, sizeof(rtp->qual->uniqueid));
+			}
+			rtp->qual->readcost = rtp->rtcp->readcost;
+			rtp->qual->writecost = rtp->rtcp->writecost;
+			if (!ast_strlen_zero(rtp->rtcp->readtranslator)) {
+				ast_copy_string(rtp->qual->readtranslator, rtp->rtcp->readtranslator, sizeof(rtp->qual->readtranslator));
+			}
+			if (!ast_strlen_zero(rtp->rtcp->writetranslator)) {
+				ast_copy_string(rtp->qual->writetranslator, rtp->rtcp->writetranslator, sizeof(rtp->qual->writetranslator));
+			}
 		}
 	}
+	/* The old way */
 	if (rtp->rtcp) {
 		snprintf(rtp->rtcp->quality, sizeof(rtp->rtcp->quality),
 			"ssrc=%u;themssrc=%u;lp=%u;rxjitter=%f;rxcount=%u;txjitter=%f;txcount=%u;rlp=%u;rtt=%f",
@@ -2258,35 +2677,59 @@
 			rtp->rtcp->reported_lost,
 			rtp->rtcp->rtt);
 		return rtp->rtcp->quality;
-	} else
+	} else {
 		return "<Unknown> - RTP/RTCP has already been destroyed";
+	}
 }
 
 void ast_rtp_destroy(struct ast_rtp *rtp)
 {
 	if (rtcp_debug_test_addr(&rtp->them) || rtcpstats) {
 		/*Print some info on the call here */
-		ast_verbose("  RTP-stats\n");
+		ast_verbose(" RTP-stats\n");
 		ast_verbose("* Our Receiver:\n");
-		ast_verbose("  SSRC:		 %u\n", rtp->themssrc);
-		ast_verbose("  Received packets: %u\n", rtp->rxcount);
-		ast_verbose("  Lost packets:	 %u\n", rtp->rtcp ? (rtp->rtcp->expected_prior - rtp->rtcp->received_prior) : 0);
-		ast_verbose("  Jitter:		 %.4f\n", rtp->rxjitter);
-		ast_verbose("  Transit:		 %.4f\n", rtp->rxtransit);
-		ast_verbose("  RR-count:	 %u\n", rtp->rtcp ? rtp->rtcp->rr_count : 0);
+		ast_verbose("   SSRC:		     %u\n", rtp->themssrc);
+		ast_verbose("   CNAME:		     %s\n", rtp->rtcp ? rtp->rtcp->theircname : "");
+		ast_verbose("   Received packets:    %u\n", rtp->rxcount);
+		ast_verbose("   Lost packets:	     %u\n", rtp->rtcp ? (rtp->rtcp->expected_prior - rtp->rtcp->received_prior) : 0);
+		ast_verbose("   Jitter:		     %.4f Max %.4f Min %.4f\n", rtp->rxjitter, 
+				rtp->rtcp ? rtp->rtcp->maxrxjitter : 0, 
+				rtp->rtcp ? rtp->rtcp->minrxjitter : 0);
+		ast_verbose("   Transit:	     %.4f\n", rtp->rxtransit);
+		ast_verbose("   Received RTCP RR/SR: %u\n", rtp->rtcp ? rtp->rtcp->rec_rr_count + rtp->rtcp->rec_sr_count : 0);
+
 		ast_verbose("* Our Sender:\n");
-		ast_verbose("  SSRC:		 %u\n", rtp->ssrc);
-		ast_verbose("  Sent packets:	 %u\n", rtp->txcount);
-		ast_verbose("  Lost packets:	 %u\n", rtp->rtcp ? rtp->rtcp->reported_lost : 0);
-		ast_verbose("  Jitter:		 %u\n", rtp->rtcp ? (rtp->rtcp->reported_jitter / (unsigned int)65536.0) : 0);
-		ast_verbose("  SR-count:	 %u\n", rtp->rtcp ? rtp->rtcp->sr_count : 0);
-		ast_verbose("  RTT:		 %f\n", rtp->rtcp ? rtp->rtcp->rtt : 0);
+		ast_verbose("   SSRC:		     %u\n", rtp->ssrc);
+		ast_verbose("   CNAME:		     %s\n", rtp->rtcp ? rtp->rtcp->ourcname : "");
+		ast_verbose("   Sent packets:	     %u\n", rtp->txcount);
+		if (rtp->rtcp && rtp->rtcp->rec_rr_count + rtp->rtcp->rec_sr_count == 0) {
+			ast_verbose("   No RTCP reports received. No stats available for packet loss, jitter and delay\n");
+		} else if (rtp->rtcp) {
+			ast_verbose("   Lost packets:	     %u\n", rtp->rtcp->reported_lost);
+			ast_verbose("   Jitter:		     %u\n", (rtp->rtcp->reported_jitter / (unsigned int)65536.0));
+			ast_verbose("   RTT:		     %lu\n", (unsigned long) rtp->rtcp->rtt);
+			ast_verbose("   RTT Max:	     %lu\n", (unsigned long) rtp->rtcp->maxrtt);
+			ast_verbose("   RTT Min:	     %lu\n", (unsigned long) rtp->rtcp->minrtt);
+			ast_verbose("	RTT count:           %u\n", rtp->rtcp->rtt_count  );
+			ast_verbose("	RTT avg:             %lu\n", rtp->rtcp->rtt_count ? 
+				 (unsigned long) rtp->rtcp->accumulated_transit / rtp->rtcp->rtt_count : 0);
+		}
+		ast_verbose("   RR-count:	     %u\n", rtp->rtcp ? rtp->rtcp->rr_count : 0);
+		ast_verbose("   SR-count:	     %u\n", rtp->rtcp ? rtp->rtcp->sr_count : 0);
+
+		ast_verbose("* Media\n");
+		ast_verbose("   Last format sent: %s\n", ast_getformatname(rtp->lasttxformat));
+		ast_verbose("   Last format recv: %s\n", ast_getformatname(rtp->lastrxformat));
+
+		ast_verbose("\n");
 	}
 
 	if (rtp->smoother)
 		ast_smoother_free(rtp->smoother);
 	if (rtp->ioid)
 		ast_io_remove(rtp->io, rtp->ioid);
+	if (rtp->ioidrtcp)
+		ast_io_remove(rtp->iortcp, rtp->ioidrtcp);
 	if (rtp->s > -1)
 		close(rtp->s);
 	if (rtp->rtcp) {
@@ -2295,6 +2738,10 @@
 		free(rtp->rtcp);
 		rtp->rtcp=NULL;
 	}
+	if (rtp->qual) {
+		free(rtp->qual);
+		rtp->qual=NULL;
+	}
 
 	ast_mutex_destroy(&rtp->bridge_lock);
 
@@ -2503,16 +2950,121 @@
 	return res;
 }
 
+/*! \brief Basically add SSRC */
+static int add_sdes_header(struct ast_rtp *rtp, unsigned int *rtcp_packet, int len)
+{
+	/* 2 is version, 1 is number of chunks, then RTCP packet type (SDES) and length */
+	*rtcp_packet = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | ((len/4)-1));
+
+	rtcp_packet++;	/* Move 32 bits ahead for the header */
+	*rtcp_packet = htonl(rtp->ssrc);               /* Our SSRC */
+	rtcp_packet ++;
+
+	/* Header + SSRC */
+	return len + 8;
+}
+
+static int add_sdes_bodypart(struct ast_rtp *rtp, unsigned int *rtcp_packet, int len, int type)
+{
+	int cnamelen;
+	int sdeslen = 0;
+	char *sdes;
+
+	sdes = (char *) rtcp_packet;
+	switch (type) {
+	case SDES_CNAME:
+		cnamelen = (int) rtp->rtcp->ourcnamelength;
+
+		*sdes = SDES_CNAME;
+		sdes++;
+		*sdes = (char) cnamelen;
+		sdes++;
+		strncpy(sdes, rtp->rtcp->ourcname, cnamelen);	/* NO terminating 0 */
+
+		/* THere must be a multiple of four bytes in the packet */
+		sdeslen = cnamelen;
+		break;
+	case SDES_END:
+		*sdes = SDES_END;
+		sdes++;
+		*sdes = (char) 0;
+		sdes++;
+		sdeslen = 2;
+	}
+	len += sdeslen + (sdeslen % 4 == 0 ? 0 : 4 - (sdeslen % 4)) ;
+
+	return len;
+}
+
+/*! \brief Send emtpy RTCP receiver's report and SDES message 
+ 	Mainly used to open NAT sessions  */
+static int ast_rtcp_write_empty(struct ast_rtp *rtp, int fd)
+{
+	char bdata[512];
+	unsigned int *rtcpheader, *start;
+	int len, res;
+
+	if (!rtp || !rtp->rtcp) {
+		return 0;
+	} 
+	if (fd == -1) {
+		ast_log(LOG_DEBUG, "--- No file descriptor to use \n");
+	}
+	
+	if (!rtp->rtcp->them.sin_addr.s_addr) {  /* This'll stop rtcp for this rtp session */
+		ast_verbose("RTCP SR transmission error, rtcp halted\n");
+		AST_SCHED_DEL(rtp->sched, rtp->rtcp->schedid);
+		return 0;
+	}
+	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
+		ast_log(LOG_DEBUG,  "---- About to send empty RTCP packet\n");
+	}
+	rtcpheader = (unsigned int *)bdata;
+	/* Add a RR header with no reports (chunks = 0) - The RFC says that it's always needed 
+		first in a compound packet.
+	 */
+	rtcpheader[0] = htonl((2 << 30) | (0 << 24) | (RTCP_PT_RR << 16) | 1);
+	rtcpheader[1] = htonl(rtp->ssrc);
+	len = 8;
+	start = &rtcpheader[len/4];
+	len +=8; /* SKip header for now */
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_CNAME);
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_END);
+	/* Now, add header when we know the actual length */
+	add_sdes_header(rtp, start, len);
+
+	res = sendto(fd, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&rtp->rtcp->them, sizeof(rtp->rtcp->them));
+
+	if (res < 0) {
+		ast_log(LOG_ERROR, "RTCP RR transmission error, rtcp halted: %s\n",strerror(errno));
+		/* Remove the scheduler */
+		AST_SCHED_DEL(rtp->sched, rtp->rtcp->schedid);
+		return 0;
+	}
+
+	rtp->rtcp->rr_count++;
+
+	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
+		ast_verbose("\n* Sending Empty RTCP RR to %s:%d  Our SSRC: %u\n",
+			ast_inet_ntoa(rtp->rtcp->them.sin_addr),
+			ntohs(rtp->rtcp->them.sin_port),
+			rtp->ssrc);
+	}
+
+	return res;
+}
+
 /*! \brief Send RTCP sender's report */
-static int ast_rtcp_write_sr(const void *data)
+static int ast_rtcp_write_sr(const void *data, int goodbye)
 {
 	struct ast_rtp *rtp = (struct ast_rtp *)data;
 	int res;
-	int len = 0;
+	int len = 0;	/* Measured in chunks of four bytes */
+	int srlen = 0;
 	struct timeval now;
 	unsigned int now_lsw;
 	unsigned int now_msw;
-	unsigned int *rtcpheader;
+	unsigned int *rtcpheader, *start;
 	unsigned int lost;
 	unsigned int extended;
 	unsigned int expected;
@@ -2523,8 +3075,7 @@
 	struct timeval dlsr;
 	char bdata[512];
 
-	/* Commented condition is always not NULL if rtp->rtcp is not NULL */
-	if (!rtp || !rtp->rtcp/* || (&rtp->rtcp->them.sin_addr == 0)*/)
+	if (!rtp || !rtp->rtcp)
 		return 0;
 	
 	if (!rtp->rtcp->them.sin_addr.s_addr) {  /* This'll stop rtcp for this rtp session */
@@ -2534,7 +3085,7 @@
 	}
 
 	gettimeofday(&now, NULL);
-	timeval2ntp(now, &now_msw, &now_lsw); /* fill thses ones in from utils.c*/
+	timeval2ntp(now, &now_msw, &now_lsw); /* fill theses ones in from utils.c*/
 	rtcpheader = (unsigned int *)bdata;
 	rtcpheader[1] = htonl(rtp->ssrc);               /* Our SSRC */
 	rtcpheader[2] = htonl(now_msw);                 /* now, MSW. gettimeofday() + SEC_BETWEEN_1900_AND_1970*/
@@ -2567,6 +3118,7 @@
 	rtcpheader[12] = htonl((((dlsr.tv_sec * 1000) + (dlsr.tv_usec / 1000)) * 65536) / 1000);
 	len += 24;
 	
+	/* Set the header for sender's report */
 	rtcpheader[0] = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SR << 16) | ((len/4)-1));
 
 	if (rtp->rtcp->sendfur) {
@@ -2575,14 +3127,23 @@
 		len += 8;
 		rtp->rtcp->sendfur = 0;
 	}
+
+	start = &rtcpheader[len/4];
+	srlen = len;
+	len +=8; /* SKip header for now */
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_CNAME);
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_END);
+	/* Now, add header when we know the actual length */
+	add_sdes_header(rtp, start, len - srlen);
+
+	if (goodbye) {
+		/* An additional RTCP block */
+		rtcpheader[len/4] = htonl((2 << 30) | (1 << 24) | (RTCP_PT_BYE << 16) | 1);
+		len += 4;
+		rtcpheader[len/4] = htonl(rtp->ssrc);               /* Our SSRC */
+		len += 4;
+	}
 	
-	/* Insert SDES here. Probably should make SDES text equal to mimetypes[code].type (not subtype 'cos */ 
-	/* it can change mid call, and SDES can't) */
-	rtcpheader[len/4]     = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | 2);
-	rtcpheader[(len/4)+1] = htonl(rtp->ssrc);               /* Our SSRC */
-	rtcpheader[(len/4)+2] = htonl(0x01 << 24);                    /* Empty for the moment */
-	len += 12;
-	
 	res = sendto(rtp->rtcp->s, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&rtp->rtcp->them, sizeof(rtp->rtcp->them));
 	if (res < 0) {
 		ast_log(LOG_ERROR, "RTCP SR transmission error to %s:%d, rtcp halted %s\n",ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port), strerror(errno));
@@ -2600,21 +3161,22 @@
 		ast_verbose("* Sent RTCP SR to %s:%d\n", ast_inet_ntoa(rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
 		ast_verbose("  Our SSRC: %u\n", rtp->ssrc);
 		ast_verbose("  Sent(NTP): %u.%010u\n", (unsigned int)now.tv_sec, (unsigned int)now.tv_usec*4096);
+		ast_verbose("  Send NTP variant: %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[2]),((unsigned long) ntohl(rtcpheader[3])) * 4096);
 		ast_verbose("  Sent(RTP): %u\n", rtp->lastts);
 		ast_verbose("  Sent packets: %u\n", rtp->txcount);
 		ast_verbose("  Sent octets: %u\n", rtp->txoctetcount);
 		ast_verbose("  Report block:\n");
-		ast_verbose("  Fraction lost: %u\n", fraction);
-		ast_verbose("  Cumulative loss: %u\n", lost);
-		ast_verbose("  IA jitter: %.4f\n", rtp->rxjitter);
-		ast_verbose("  Their last SR: %u\n", rtp->rtcp->themrxlsr);
-		ast_verbose("  DLSR: %4.4f (sec)\n\n", (double)(ntohl(rtcpheader[12])/65536.0));
+		ast_verbose("    Fraction lost (since last report): %u\n", fraction);
+		ast_verbose("    Cumulative loss: %u\n", lost);
+		ast_verbose("    IA jitter: %.4f\n", rtp->rxjitter);
+		ast_verbose("    Their last SR: %u\n", rtp->rtcp->themrxlsr);
+		ast_verbose("    Delay since last SR (DLSR): %4.4f (sec)\n\n", (double)(ntohl(rtcpheader[12])/65536.0));
 	}
 	return res;
 }
 
 /*! \brief Send RTCP recepient's report */
-static int ast_rtcp_write_rr(const void *data)
+static int ast_rtcp_write_rr(const void *data, int goodbye)
 {
 	struct ast_rtp *rtp = (struct ast_rtp *)data;
 	int res;
@@ -2626,7 +3188,7 @@
 	unsigned int received_interval;
 	int lost_interval;
 	struct timeval now;
-	unsigned int *rtcpheader;
+	unsigned int *rtcpheader, *start;
 	char bdata[1024];
 	struct timeval dlsr;
 	int fraction;
@@ -2648,6 +3210,8 @@
 	received_interval = rtp->rxcount - rtp->rtcp->received_prior;
 	rtp->rtcp->received_prior = rtp->rxcount;
 	lost_interval = expected_interval - received_interval;
+
+	rtp->rtcp->rxlost_count++;
 	if (expected_interval == 0 || lost_interval <= 0)
 		fraction = 0;
 	else
@@ -2671,13 +3235,13 @@
 		rtp->rtcp->sendfur = 0;
 	}
 
-	/*! \note Insert SDES here. Probably should make SDES text equal to mimetypes[code].type (not subtype 'cos 
-	it can change mid call, and SDES can't) */
-	rtcpheader[len/4]     = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | 2);
-	rtcpheader[(len/4)+1] = htonl(rtp->ssrc);               /* Our SSRC */
-	rtcpheader[(len/4)+2] = htonl(0x01 << 24);              /* Empty for the moment */
-	len += 12;
-	
+	start = &rtcpheader[len/4];
+	len +=8; /* SKip header for now */
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_CNAME);
+	len = add_sdes_bodypart(rtp, &rtcpheader[len/4], len, SDES_END);
+	/* Now, add header when we know the actual length */
+	add_sdes_header(rtp, start, len);
+
 	res = sendto(rtp->rtcp->s, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&rtp->rtcp->them, sizeof(rtp->rtcp->them));
 
 	if (res < 0) {
@@ -2718,9 +3282,9 @@
 		return 0;
 
 	if (rtp->txcount > rtp->rtcp->lastsrtxcount)
-		res = ast_rtcp_write_sr(data);
+		res = ast_rtcp_write_sr(data, 0);
 	else
-		res = ast_rtcp_write_rr(data);
+		res = ast_rtcp_write_rr(data, 0);
 	
 	return res;
 }
@@ -2852,10 +3416,8 @@
 			rtp->txcount++;
 			rtp->txoctetcount +=(res - hdrlen);
 			
-			/* Do not schedule RR if RTCP isn't run */
-			if (rtp->rtcp && rtp->rtcp->them.sin_addr.s_addr && rtp->rtcp->schedid < 1) {
-			    rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
-			}
+			/* Schedule RTCP report transmissions if possible */
+			ast_rtcp_schedule(rtp);
 		}
 				
 		if (rtp_debug_test_addr(&rtp->them))
@@ -3234,6 +3796,7 @@
 
 /*! \brief P2P RTP Callback */
 #ifdef P2P_INTENSE
+
 static int p2p_rtp_callback(int *id, int fd, short events, void *cbdata)
 {
 	int res = 0, hdrlen = 12;
@@ -3249,6 +3812,11 @@
 	if ((res = recvfrom(fd, rtp->rawdata + AST_FRIENDLY_OFFSET, sizeof(rtp->rawdata) - AST_FRIENDLY_OFFSET, 0, (struct sockaddr *)&sin, &len)) < 0)
 		return 1;
 
+	rtp->rxcount++;
+
+	/* Schedule RTCP report transmissions if possible */
+	ast_rtcp_schedule(rtp);
+
 	header = (unsigned int *)(rtp->rawdata + AST_FRIENDLY_OFFSET);
 
 	/* If NAT support is turned on, then see if we need to change their address */
@@ -3283,12 +3851,19 @@
 	}
 
 	/* Steal the file descriptors from the channel and stash them away */
-	fds[0] = chan->fds[0];
+	fds[0] = chan->fds[0];	/* RTP */
+	fds[1] = chan->fds[1];	/* RTCP */
 	chan->fds[0] = -1;
+	chan->fds[1] = -1;
 
 	/* Now, fire up callback mode */
 	iod[0] = ast_io_add(rtp->io, fds[0], p2p_rtp_callback, AST_IO_IN, rtp);
+	iod[1] = ast_io_add(rtp->ioc, fds[1], p2p_rtcp_callback, AST_IO_IN, rtp);
 
+	/* Kick the RTCP stream going by sending one empty stupid little packet */
+	ast_rtcp_write_empty(rtp, rtp->rtcp->s);
+	ast_log(LOG_DEBUG, "--- Enabled p2p callback for RTCP reads \n");
+
 	return 1;
 }
 #else
@@ -3305,14 +3880,18 @@
 
 	/* Remove the callback from the IO context */
 	ast_io_remove(rtp->io, iod[0]);
+	ast_io_remove(rtp->iortcp, iod[1]);
 
 	/* Restore file descriptors */
 	chan->fds[0] = fds[0];
+	chan->fds[1] = fds[1];
 	ast_channel_unlock(chan);
 
 	/* Restore callback mode if previously used */
-	if (ast_test_flag(rtp, FLAG_CALLBACK_MODE))
+	if (ast_test_flag(rtp, FLAG_CALLBACK_MODE)) {
 		rtp->ioid = ast_io_add(rtp->io, rtp->s, rtpread, AST_IO_IN, rtp);
+		rtp->ioidrtcp = ast_io_add(rtp->iortcp, fds[1], p2p_rtcp_callback, AST_IO_IN, rtp);
+	}
 
 	return 0;
 }
@@ -3351,6 +3930,10 @@
 	ast_channel_unlock(c0);
 	ast_channel_unlock(c1);
 
+	/* Kick the RTCP stream going by sending one empty stupid little packet */
+	ast_rtcp_write_empty(p0, p0->rtcp->s);
+	ast_rtcp_write_empty(p1, p1->rtcp->s);
+
 	/* Go into a loop forwarding frames until we don't need to anymore */
 	cs[0] = c0;
 	cs[1] = c1;
@@ -4011,4 +4594,3 @@
 	ast_cli_register_multiple(cli_rtp, sizeof(cli_rtp) / sizeof(struct ast_cli_entry));
 	ast_rtp_reload();
 }
-
Index: configs/sip.conf.sample
===================================================================
--- configs/sip.conf.sample	(.../branches/1.4)	(revision 382456)
+++ configs/sip.conf.sample	(.../team/oej/pinefrog-1.4)	(revision 382456)
@@ -165,6 +165,9 @@
                                  ; for peers and users as well
 ;callevents=no                   ; generate manager events when sip ua 
                                  ; performs events (e.g. hold)
+;rtcpevents=no			 ; Enable this to get QoS reports for each call in AMI
+;rtcpeventtimer=0		 ; How often during a call to send reports. 0 = only at end of call
+				 ; Other value means how many seconds between each report.
 ;alwaysauthreject = yes          ; When an incoming INVITE or REGISTER is to be rejected,
                                  ; for any reason, always reject with an identical response
                                  ; equivalent to valid username and invalid password/hash
